; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_usart.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_usart.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_usart.crf ..\..\User\uart\bsp_usart.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  _sys_exit PROC
;;;12     //定义_sys_exit()以避免使用半主机模式
;;;13     void _sys_exit(int x)
000000  4770              BX       lr
;;;14     {
;;;15     	x = x;
;;;16     }
;;;17     //重定义fputc函数
                          ENDP

                  fputc PROC
;;;18     int fputc(int ch, FILE *f)
000002  4923              LDR      r1,|L1.144|
                  |L1.4|
;;;19     {
;;;20     	while ((USART1->SR & 0X40) == 0)
000004  880a              LDRH     r2,[r1,#0]
000006  0652              LSLS     r2,r2,#25
000008  d5fc              BPL      |L1.4|
;;;21     		; //循环发送,直到发送完毕
;;;22     	USART1->DR = (u8)ch;
00000a  4a21              LDR      r2,|L1.144|
00000c  b2c1              UXTB     r1,r0
00000e  1d12              ADDS     r2,r2,#4
000010  8011              STRH     r1,[r2,#0]
;;;23     	return ch;
;;;24     }
000012  4770              BX       lr
;;;25     #endif /* printf */
                          ENDP

                  BSP_usartInit PROC
;;;31       */
;;;32     void BSP_usartInit(void)
000014  b510              PUSH     {r4,lr}
;;;33     {
000016  b086              SUB      sp,sp,#0x18
;;;34     	GPIO_InitTypeDef GPIO_InitStructure;
;;;35     	USART_InitTypeDef USART_InitStructure;
;;;36     
;;;37     	// 打开串口GPIO的时钟
;;;38     	DEBUG_USART_GPIO_APBxClkCmd(DEBUG_USART_GPIO_CLK, ENABLE);
000018  2101              MOVS     r1,#1
00001a  2004              MOVS     r0,#4
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;39     	
;;;40     	// 打开串口外设的时钟
;;;41     	DEBUG_USART_APBxClkCmd(DEBUG_USART_CLK, ENABLE);
000020  2101              MOVS     r1,#1
000022  0388              LSLS     r0,r1,#14
000024  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;42     
;;;43     	// 将USART Tx的GPIO配置为推挽复用模式
;;;44     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_TX_GPIO_PIN;
000028  f44f7000          MOV      r0,#0x200
00002c  f8ad0010          STRH     r0,[sp,#0x10]
;;;45     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;
000030  2018              MOVS     r0,#0x18
000032  f88d0013          STRB     r0,[sp,#0x13]
;;;46     	GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
000036  2003              MOVS     r0,#3
;;;47     	GPIO_Init(DEBUG_USART_TX_GPIO_PORT, &GPIO_InitStructure);
000038  4c16              LDR      r4,|L1.148|
00003a  f88d0012          STRB     r0,[sp,#0x12]         ;46
00003e  a904              ADD      r1,sp,#0x10
000040  4620              MOV      r0,r4
000042  f7fffffe          BL       GPIO_Init
;;;48     
;;;49       // 将USART Rx的GPIO配置为浮空输入模式
;;;50     	GPIO_InitStructure.GPIO_Pin = DEBUG_USART_RX_GPIO_PIN;
000046  1521              ASRS     r1,r4,#20
000048  f8ad1010          STRH     r1,[sp,#0x10]
;;;51     	GPIO_InitStructure.GPIO_Mode = GPIO_Mode_IN_FLOATING;
00004c  2104              MOVS     r1,#4
00004e  f88d1013          STRB     r1,[sp,#0x13]
;;;52     	GPIO_Init(DEBUG_USART_RX_GPIO_PORT, &GPIO_InitStructure);
000052  a904              ADD      r1,sp,#0x10
000054  4620              MOV      r0,r4
000056  f7fffffe          BL       GPIO_Init
;;;53     	
;;;54     	// 配置串口的工作参数
;;;55     	// 配置波特率
;;;56     	USART_InitStructure.USART_BaudRate = DEBUG_USART_BAUDRATE;
00005a  f44f30e1          MOV      r0,#0x1c200
;;;57     	// 配置 针数据字长
;;;58     	USART_InitStructure.USART_WordLength = USART_WordLength_8b;
00005e  9000              STR      r0,[sp,#0]
000060  2000              MOVS     r0,#0
000062  f8ad0004          STRH     r0,[sp,#4]
;;;59     	// 配置停止位
;;;60     	USART_InitStructure.USART_StopBits = USART_StopBits_1;
000066  f8ad0006          STRH     r0,[sp,#6]
;;;61     	// 配置校验位
;;;62     	USART_InitStructure.USART_Parity = USART_Parity_No ;
00006a  f8ad0008          STRH     r0,[sp,#8]
;;;63     	// 配置硬件流控制
;;;64     	USART_InitStructure.USART_HardwareFlowControl = USART_HardwareFlowControl_None;
00006e  f8ad000c          STRH     r0,[sp,#0xc]
;;;65     	// 配置工作模式，收发一起
;;;66     	USART_InitStructure.USART_Mode = USART_Mode_Rx | USART_Mode_Tx;
000072  200c              MOVS     r0,#0xc
;;;67     	// 完成串口的初始化配置
;;;68     	USART_Init(DEBUG_USARTx, &USART_InitStructure);
000074  4c06              LDR      r4,|L1.144|
000076  f8ad000a          STRH     r0,[sp,#0xa]          ;66
00007a  4669              MOV      r1,sp
00007c  4620              MOV      r0,r4
00007e  f7fffffe          BL       USART_Init
;;;69     	
;;;70     	// 使能串口
;;;71     	USART_Cmd(DEBUG_USARTx, ENABLE);	    
000082  2101              MOVS     r1,#1
000084  4620              MOV      r0,r4
000086  f7fffffe          BL       USART_Cmd
;;;72     }
00008a  b006              ADD      sp,sp,#0x18
00008c  bd10              POP      {r4,pc}
;;;73     
                          ENDP

00008e  0000              DCW      0x0000
                  |L1.144|
                          DCD      0x40013800
                  |L1.148|
                          DCD      0x40010800

                          AREA ||.data||, DATA, ALIGN=2

                  __stdout
                          DCD      0x00000000
