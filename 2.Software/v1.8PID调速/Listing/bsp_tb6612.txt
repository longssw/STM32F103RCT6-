; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_tb6612.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_tb6612.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_tb6612.crf ..\..\BSP\bsp_tb6612.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  open_gpiox_clock PROC
;;;15     
;;;16     static void open_gpiox_clock(GPIO_TypeDef *gpiox)
000000  b510              PUSH     {r4,lr}
;;;17     {
000002  4604              MOV      r4,r0
;;;18         // 根据GPIO组初始化GPIO时钟
;;;19         if (gpiox == GPIOA)
000004  48b2              LDR      r0,|L1.720|
000006  4284              CMP      r4,r0
000008  d103              BNE      |L1.18|
;;;20         {
;;;21             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 使能GPIOA时钟
00000a  2101              MOVS     r1,#1
00000c  2004              MOVS     r0,#4
00000e  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.18|
;;;22         }
;;;23         if (gpiox == GPIOB)
000012  48b0              LDR      r0,|L1.724|
000014  4284              CMP      r4,r0
000016  d103              BNE      |L1.32|
;;;24         {
;;;25             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 使能GPIOB时钟
000018  2101              MOVS     r1,#1
00001a  2008              MOVS     r0,#8
00001c  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.32|
;;;26         }
;;;27         if (gpiox == GPIOC)
000020  48ad              LDR      r0,|L1.728|
000022  4284              CMP      r4,r0
000024  d103              BNE      |L1.46|
;;;28         {
;;;29             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // 使能GPIOC时钟
000026  2101              MOVS     r1,#1
000028  2010              MOVS     r0,#0x10
00002a  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.46|
;;;30         }
;;;31         if (gpiox == GPIOD)
00002e  48ab              LDR      r0,|L1.732|
000030  4284              CMP      r4,r0
000032  d103              BNE      |L1.60|
;;;32         {
;;;33             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // 使能GPIOD时钟
000034  2101              MOVS     r1,#1
000036  2020              MOVS     r0,#0x20
000038  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.60|
;;;34         }
;;;35         if (gpiox == GPIOE)
00003c  48a8              LDR      r0,|L1.736|
00003e  4284              CMP      r4,r0
000040  d105              BNE      |L1.78|
;;;36         {
;;;37             RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); // 使能GPIOE时钟
000042  2101              MOVS     r1,#1
000044  e8bd4010          POP      {r4,lr}
000048  2040              MOVS     r0,#0x40
00004a  f7ffbffe          B.W      RCC_APB2PeriphClockCmd
                  |L1.78|
;;;38         }
;;;39     }
00004e  bd10              POP      {r4,pc}
;;;40     
                          ENDP

                  ioctl PROC
;;;176    
;;;177    static uint8_t ioctl(tb6612_t *tb6612, uint32_t gpio, u8 value)
000050  b570              PUSH     {r4-r6,lr}
;;;178    {
000052  460d              MOV      r5,r1
000054  4604              MOV      r4,r0
000056  b11a              CBZ      r2,|L1.96|
;;;179        switch (value)
000058  2a01              CMP      r2,#1
00005a  d01e              BEQ      |L1.154|
;;;180        {
;;;181        case 0: /* 低电平 */
;;;182            if (gpio == tb6612->GPIO_A1)
;;;183            {
;;;184                GPIO_ResetBits(tb6612->GPIOx_A1, tb6612->GPIO_A1);
;;;185            }
;;;186            if (gpio == tb6612->GPIO_A2)
;;;187            {
;;;188                GPIO_ResetBits(tb6612->GPIOx_A2, tb6612->GPIO_A2);
;;;189            }
;;;190            if (gpio == tb6612->GPIO_B1)
;;;191            {
;;;192                GPIO_ResetBits(tb6612->GPIOx_B1, tb6612->GPIO_B1);
;;;193            }
;;;194            if (gpio == tb6612->GPIO_B2)
;;;195            {
;;;196                GPIO_ResetBits(tb6612->GPIOx_B2, tb6612->GPIO_B2);
;;;197            }
;;;198            break;
;;;199        case 1: /* 高电平 */
;;;200            if (gpio == tb6612->GPIO_A1)
;;;201            {
;;;202                GPIO_SetBits(tb6612->GPIOx_A1, tb6612->GPIO_A1);
;;;203            }
;;;204            if (gpio == tb6612->GPIO_A2)
;;;205            {
;;;206                GPIO_SetBits(tb6612->GPIOx_A2, tb6612->GPIO_A2);
;;;207            }
;;;208            if (gpio == tb6612->GPIO_B1)
;;;209            {
;;;210                GPIO_SetBits(tb6612->GPIOx_B1, tb6612->GPIO_B1);
;;;211            }
;;;212            if (gpio == tb6612->GPIO_B2)
;;;213            {
;;;214                GPIO_SetBits(tb6612->GPIOx_B2, tb6612->GPIO_B2);
;;;215            }
;;;216            break;
;;;217        default:
;;;218            return 1; /* 参数错误 */
00005c  2001              MOVS     r0,#1
;;;219        }
;;;220        return 0;
;;;221    }
00005e  bd70              POP      {r4-r6,pc}
                  |L1.96|
000060  6920              LDR      r0,[r4,#0x10]         ;182
000062  42a8              CMP      r0,r5                 ;182
000064  d103              BNE      |L1.110|
000066  b281              UXTH     r1,r0                 ;184
000068  6820              LDR      r0,[r4,#0]            ;184
00006a  f7fffffe          BL       GPIO_ResetBits
                  |L1.110|
00006e  6960              LDR      r0,[r4,#0x14]         ;186
000070  42a8              CMP      r0,r5                 ;186
000072  d103              BNE      |L1.124|
000074  b281              UXTH     r1,r0                 ;188
000076  6860              LDR      r0,[r4,#4]            ;188
000078  f7fffffe          BL       GPIO_ResetBits
                  |L1.124|
00007c  69a0              LDR      r0,[r4,#0x18]         ;190
00007e  42a8              CMP      r0,r5                 ;190
000080  d103              BNE      |L1.138|
000082  b281              UXTH     r1,r0                 ;192
000084  68a0              LDR      r0,[r4,#8]            ;192
000086  f7fffffe          BL       GPIO_ResetBits
                  |L1.138|
00008a  69e0              LDR      r0,[r4,#0x1c]         ;194
00008c  42a8              CMP      r0,r5                 ;194
00008e  d120              BNE      |L1.210|
000090  b281              UXTH     r1,r0                 ;196
000092  68e0              LDR      r0,[r4,#0xc]          ;196
000094  f7fffffe          BL       GPIO_ResetBits
000098  e01b              B        |L1.210|
                  |L1.154|
00009a  6920              LDR      r0,[r4,#0x10]         ;200
00009c  42a8              CMP      r0,r5                 ;200
00009e  d103              BNE      |L1.168|
0000a0  b281              UXTH     r1,r0                 ;202
0000a2  6820              LDR      r0,[r4,#0]            ;202
0000a4  f7fffffe          BL       GPIO_SetBits
                  |L1.168|
0000a8  6960              LDR      r0,[r4,#0x14]         ;204
0000aa  42a8              CMP      r0,r5                 ;204
0000ac  d103              BNE      |L1.182|
0000ae  b281              UXTH     r1,r0                 ;206
0000b0  6860              LDR      r0,[r4,#4]            ;206
0000b2  f7fffffe          BL       GPIO_SetBits
                  |L1.182|
0000b6  69a0              LDR      r0,[r4,#0x18]         ;208
0000b8  42a8              CMP      r0,r5                 ;208
0000ba  d103              BNE      |L1.196|
0000bc  b281              UXTH     r1,r0                 ;210
0000be  68a0              LDR      r0,[r4,#8]            ;210
0000c0  f7fffffe          BL       GPIO_SetBits
                  |L1.196|
0000c4  69e0              LDR      r0,[r4,#0x1c]         ;212
0000c6  42a8              CMP      r0,r5                 ;212
0000c8  d103              BNE      |L1.210|
0000ca  b281              UXTH     r1,r0                 ;214
0000cc  68e0              LDR      r0,[r4,#0xc]          ;214
0000ce  f7fffffe          BL       GPIO_SetBits
                  |L1.210|
0000d2  2000              MOVS     r0,#0                 ;220
0000d4  bd70              POP      {r4-r6,pc}
;;;222    
                          ENDP

                  pwm_init PROC
;;;76      */
;;;77     static void pwm_init(tb6612_t *tb6612, uint16_t psc, uint16_t per)
0000d6  e92d47f0          PUSH     {r4-r10,lr}
;;;78     {
0000da  460d              MOV      r5,r1
;;;79     #if 0
;;;80         GPIO_InitTypeDef GPIO_InitStruct;
;;;81         TIM_TimeBaseInitTypeDef TIM_TimeBaseInitStruct;
;;;82         TIM_OCInitTypeDef TIM_OCInitStruct;
;;;83     
;;;84         RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA | RCC_APB2Periph_TIM1 | RCC_APB2Periph_AFIO, ENABLE);
;;;85     
;;;86         GPIO_InitStruct.GPIO_Mode = GPIO_Mode_AF_PP; 
;;;87         GPIO_InitStruct.GPIO_Pin = GPIO_Pin_8 | GPIO_Pin_11;
;;;88         GPIO_InitStruct.GPIO_Speed = GPIO_Speed_50MHz;
;;;89         GPIO_Init(GPIOA, &GPIO_InitStruct);
;;;90     
;;;91         TIM_TimeBaseStructInit(&TIM_TimeBaseInitStruct);            
;;;92         TIM_TimeBaseInitStruct.TIM_ClockDivision = TIM_CKD_DIV1;     
;;;93         TIM_TimeBaseInitStruct.TIM_CounterMode = TIM_CounterMode_Up; 
;;;94         TIM_TimeBaseInitStruct.TIM_Period = per;                    
;;;95         TIM_TimeBaseInitStruct.TIM_Prescaler = psc;                 
;;;96         TIM_TimeBaseInit(TIM1, &TIM_TimeBaseInitStruct);
;;;97     
;;;98         TIM_OCInitStruct.TIM_OCMode = TIM_OCMode_PWM1;             
;;;99         TIM_OCInitStruct.TIM_OCPolarity = TIM_OCPolarity_High;     
;;;100        TIM_OCInitStruct.TIM_Pulse = 0;                          
;;;101        TIM_OC1Init(TIM1, &TIM_OCInitStruct);
;;;102        TIM_OC4Init(TIM1, &TIM_OCInitStruct);
;;;103    
;;;104        TIM_CtrlPWMOutputs(TIM1, ENABLE);
;;;105    
;;;106        TIM_OC1PreloadConfig(TIM1, TIM_OCPreload_Enable);
;;;107        TIM_OC4PreloadConfig(TIM1, TIM_OCPreload_Enable);         
;;;108        TIM_ARRPreloadConfig(TIM1, ENABLE);                        
;;;109        TIM_Cmd(TIM1, ENABLE);
;;;110    #endif
;;;111        u16 CCR1_Val = 5000;
;;;112        u16 CCR2_Val = 4000;
;;;113        u16 CCR3_Val = 3000;
;;;114        u16 CCR4_Val = 2000;
;;;115    
;;;116        GPIO_InitTypeDef GPIO_InitStructure;
;;;117        TIM_TimeBaseInitTypeDef TIM_TimeBaseStructure;
;;;118        TIM_OCInitTypeDef TIM_OCInitStructure;
;;;119    
;;;120        RCC_APB2PeriphClockCmd(RCC_APB2Periph_TIM8, ENABLE);  // 使能定时器3时钟
0000dc  2101              MOVS     r1,#1
0000de  b088              SUB      sp,sp,#0x20           ;78
0000e0  4614              MOV      r4,r2                 ;78
0000e2  f2413688          MOV      r6,#0x1388            ;111
0000e6  f44f677a          MOV      r7,#0xfa0             ;112
0000ea  f64039b8          MOV      r9,#0xbb8             ;113
0000ee  f44f6afa          MOV      r10,#0x7d0            ;114
0000f2  0348              LSLS     r0,r1,#13
0000f4  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;121        RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // 使能GPIO外设和AFIO复用功能模块时钟
0000f8  2101              MOVS     r1,#1
0000fa  2010              MOVS     r0,#0x10
0000fc  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;122    
;;;123        // 设置该引脚为复用输出功能,输出TIM8 CH2的PWM脉冲波形	GPIOB.5
;;;124        GPIO_InitStructure.GPIO_Pin = GPIO_Pin_6 | GPIO_Pin_7 | GPIO_Pin_8 | GPIO_Pin_9; // TIM_CH2
000100  f44f7070          MOV      r0,#0x3c0
000104  f8ad001c          STRH     r0,[sp,#0x1c]
;;;125        GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AF_PP;                                  // 复用推挽输出
000108  2018              MOVS     r0,#0x18
00010a  f88d001f          STRB     r0,[sp,#0x1f]
;;;126        GPIO_InitStructure.GPIO_Speed = GPIO_Speed_50MHz;
00010e  2003              MOVS     r0,#3
000110  f88d001e          STRB     r0,[sp,#0x1e]
;;;127        GPIO_Init(GPIOC, &GPIO_InitStructure); // 初始化GPIO
000114  a907              ADD      r1,sp,#0x1c
000116  4870              LDR      r0,|L1.728|
000118  f7fffffe          BL       GPIO_Init
;;;128    
;;;129        // 初始化TIM8
;;;130        TIM_TimeBaseStructure.TIM_Period = per;                     // 设置在下一个更新事件装入活动的自动重装载寄存器周期的值
00011c  f8ad4014          STRH     r4,[sp,#0x14]
;;;131        TIM_TimeBaseStructure.TIM_Prescaler = psc;                  // 设置用来作为TIMx时钟频率除数的预分频值
;;;132        TIM_TimeBaseStructure.TIM_ClockDivision = TIM_CKD_DIV1;     // 设置时钟分割:TDTS = Tck_tim
000120  2400              MOVS     r4,#0
;;;133        TIM_TimeBaseStructure.TIM_CounterMode = TIM_CounterMode_Up; // TIM向上计数模式
;;;134        TIM_TimeBaseInit(TIM8, &TIM_TimeBaseStructure);             // 根据TIM_TimeBaseInitStruct中指定的参数初始化TIMx的时间基数单位
000122  f8df81c0          LDR      r8,|L1.740|
000126  f8ad5010          STRH     r5,[sp,#0x10]         ;131
00012a  f8ad4016          STRH     r4,[sp,#0x16]         ;132
00012e  f8ad4012          STRH     r4,[sp,#0x12]         ;133
000132  a904              ADD      r1,sp,#0x10
000134  4640              MOV      r0,r8
000136  f7fffffe          BL       TIM_TimeBaseInit
;;;135    
;;;136        // 初始化TIM8 Channel2 PWM模式
;;;137        TIM_OCInitStructure.TIM_OCMode = TIM_OCMode_PWM2;             // 选择定时器模式:TIM脉冲宽度调制模式2
00013a  2070              MOVS     r0,#0x70
00013c  f8ad0000          STRH     r0,[sp,#0]
;;;138        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; // 比较输出使能
000140  2501              MOVS     r5,#1
000142  f8ad5002          STRH     r5,[sp,#2]
;;;139        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     // 输出极性:TIM输出比较极性高
000146  f8ad4008          STRH     r4,[sp,#8]
;;;140        TIM_OCInitStructure.TIM_Pulse = CCR1_Val;
00014a  f8ad6006          STRH     r6,[sp,#6]
;;;141        TIM_OC1Init(TIM8, &TIM_OCInitStructure); // 根据T指定的参数初始化外设TIM8 OC2
00014e  4669              MOV      r1,sp
000150  4640              MOV      r0,r8
000152  f7fffffe          BL       TIM_OC1Init
;;;142    
;;;143        TIM_OC1PreloadConfig(TIM8, TIM_OCPreload_Enable); // 使能TIM8在CCR2上的预装载寄存器
000156  2108              MOVS     r1,#8
000158  4640              MOV      r0,r8
00015a  f7fffffe          BL       TIM_OC1PreloadConfig
;;;144    
;;;145        TIM_CtrlPWMOutputs(TIM8, ENABLE);
00015e  2101              MOVS     r1,#1
000160  4640              MOV      r0,r8
000162  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;146    
;;;147        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; // 比较输出使能
000166  f8ad5002          STRH     r5,[sp,#2]
;;;148        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     // 输出极性:TIM输出比较极性高
00016a  f8ad4008          STRH     r4,[sp,#8]
;;;149        TIM_OCInitStructure.TIM_Pulse = CCR2_Val;
00016e  f8ad7006          STRH     r7,[sp,#6]
;;;150        TIM_OC2Init(TIM8, &TIM_OCInitStructure); // 根据T指定的参数初始化外设TIM8 OC2
000172  4669              MOV      r1,sp
000174  4640              MOV      r0,r8
000176  f7fffffe          BL       TIM_OC2Init
;;;151    
;;;152        TIM_OC2PreloadConfig(TIM8, TIM_OCPreload_Enable); // 使能TIM8在CCR2上的预装载寄存器
00017a  2108              MOVS     r1,#8
00017c  4640              MOV      r0,r8
00017e  f7fffffe          BL       TIM_OC2PreloadConfig
;;;153    
;;;154        TIM_CtrlPWMOutputs(TIM8, ENABLE);
000182  2101              MOVS     r1,#1
000184  4640              MOV      r0,r8
000186  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;155    
;;;156        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; // 比较输出使能
00018a  f8ad5002          STRH     r5,[sp,#2]
;;;157        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     // 输出极性:TIM输出比较极性高
00018e  f8ad4008          STRH     r4,[sp,#8]
;;;158        TIM_OCInitStructure.TIM_Pulse = CCR3_Val;
000192  f8ad9006          STRH     r9,[sp,#6]
;;;159        TIM_OC3Init(TIM8, &TIM_OCInitStructure); // 根据T指定的参数初始化外设TIM8 OC2
000196  4669              MOV      r1,sp
000198  4640              MOV      r0,r8
00019a  f7fffffe          BL       TIM_OC3Init
;;;160    
;;;161        TIM_OC3PreloadConfig(TIM8, TIM_OCPreload_Enable); // 使能TIM8在CCR2上的预装载寄存器
00019e  2108              MOVS     r1,#8
0001a0  4640              MOV      r0,r8
0001a2  f7fffffe          BL       TIM_OC3PreloadConfig
;;;162    
;;;163        TIM_CtrlPWMOutputs(TIM8, ENABLE);
0001a6  2101              MOVS     r1,#1
0001a8  4640              MOV      r0,r8
0001aa  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;164    
;;;165        TIM_OCInitStructure.TIM_OutputState = TIM_OutputState_Enable; // 比较输出使能
0001ae  f8ad5002          STRH     r5,[sp,#2]
;;;166        TIM_OCInitStructure.TIM_OCPolarity = TIM_OCPolarity_High;     // 输出极性:TIM输出比较极性高
0001b2  f8ad4008          STRH     r4,[sp,#8]
;;;167        TIM_OCInitStructure.TIM_Pulse = CCR4_Val;
0001b6  f8ada006          STRH     r10,[sp,#6]
;;;168        TIM_OC4Init(TIM8, &TIM_OCInitStructure); // 根据T指定的参数初始化外设TIM8 OC2
0001ba  4669              MOV      r1,sp
0001bc  4640              MOV      r0,r8
0001be  f7fffffe          BL       TIM_OC4Init
;;;169    
;;;170        TIM_OC4PreloadConfig(TIM8, TIM_OCPreload_Enable); // 使能TIM8在CCR2上的预装载寄存器
0001c2  2108              MOVS     r1,#8
0001c4  4640              MOV      r0,r8
0001c6  f7fffffe          BL       TIM_OC4PreloadConfig
;;;171    
;;;172        TIM_CtrlPWMOutputs(TIM8, ENABLE);
0001ca  2101              MOVS     r1,#1
0001cc  4640              MOV      r0,r8
0001ce  f7fffffe          BL       TIM_CtrlPWMOutputs
;;;173    
;;;174        TIM_Cmd(TIM8, ENABLE); // 使能TIM8
0001d2  2101              MOVS     r1,#1
0001d4  4640              MOV      r0,r8
0001d6  f7fffffe          BL       TIM_Cmd
;;;175    }
0001da  b008              ADD      sp,sp,#0x20
0001dc  e8bd87f0          POP      {r4-r10,pc}
;;;176    
                          ENDP

                  setup PROC
;;;235     */
;;;236    uint8_t setup(tb6612_t *tb6612, enum motor_id id, uint16_t speed)
0001e0  b510              PUSH     {r4,lr}
;;;237    {
0001e2  4604              MOV      r4,r0
0001e4  b119              CBZ      r1,|L1.494|
;;;238        switch (id)
0001e6  2901              CMP      r1,#1
0001e8  d00d              BEQ      |L1.518|
;;;239        {
;;;240        case MOTORA:
;;;241            if (speed > 0)
;;;242            {
;;;243                /* 速度值大于0 电机正转 */
;;;244                ioctl(tb6612, tb6612->GPIO_A1, 0);
;;;245                ioctl(tb6612, tb6612->GPIO_A2, 1);
;;;246            }
;;;247            else
;;;248            {
;;;249                /* 电机反转 */
;;;250                ioctl(tb6612, tb6612->GPIO_A1, 1);
;;;251                ioctl(tb6612, tb6612->GPIO_A2, 0);
;;;252            }
;;;253            break;
;;;254        case MOTORB:
;;;255            if (speed > 0)
;;;256            {
;;;257                /* 速度值大于0 电机正转 */
;;;258                ioctl(tb6612, tb6612->GPIO_B1, 0);
;;;259                ioctl(tb6612, tb6612->GPIO_B2, 1);
;;;260            }
;;;261            else
;;;262            {
;;;263                /* 电机反转 */
;;;264                ioctl(tb6612, tb6612->GPIO_B1, 1);
;;;265                ioctl(tb6612, tb6612->GPIO_B2, 0);
;;;266            }
;;;267            break;
;;;268        default:
;;;269            return 1; /* ID错误 */
0001ea  2001              MOVS     r0,#1
;;;270        }
;;;271        return 0;
;;;272    }
0001ec  bd10              POP      {r4,pc}
                  |L1.494|
0001ee  6921              LDR      r1,[r4,#0x10]         ;241
0001f0  b122              CBZ      r2,|L1.508|
0001f2  2200              MOVS     r2,#0                 ;244
0001f4  f7fffffe          BL       ioctl
0001f8  6961              LDR      r1,[r4,#0x14]         ;245
0001fa  e00a              B        |L1.530|
                  |L1.508|
0001fc  2201              MOVS     r2,#1                 ;250
0001fe  f7fffffe          BL       ioctl
000202  6961              LDR      r1,[r4,#0x14]         ;251
000204  e00b              B        |L1.542|
                  |L1.518|
000206  69a1              LDR      r1,[r4,#0x18]         ;255
000208  b12a              CBZ      r2,|L1.534|
00020a  2200              MOVS     r2,#0                 ;258
00020c  f7fffffe          BL       ioctl
000210  69e1              LDR      r1,[r4,#0x1c]         ;259
                  |L1.530|
000212  2201              MOVS     r2,#1                 ;245
000214  e004              B        |L1.544|
                  |L1.534|
000216  2201              MOVS     r2,#1                 ;264
000218  f7fffffe          BL       ioctl
00021c  69e1              LDR      r1,[r4,#0x1c]         ;265
                  |L1.542|
00021e  2200              MOVS     r2,#0                 ;251
                  |L1.544|
000220  4620              MOV      r0,r4                 ;259
000222  f7fffffe          BL       ioctl
000226  2000              MOVS     r0,#0                 ;271
000228  bd10              POP      {r4,pc}
;;;273    
                          ENDP

                  tb6612_init PROC
;;;274    void tb6612_init(tb6612_t *tb6612)
00022a  b510              PUSH     {r4,lr}
;;;275    {
00022c  4604              MOV      r4,r0
;;;276        gpio_init(tb6612);
00022e  f7fffffe          BL       gpio_init
;;;277        pwm_init(tb6612, 71, 7199);
000232  f641421f          MOV      r2,#0x1c1f
000236  2147              MOVS     r1,#0x47
000238  4620              MOV      r0,r4
00023a  f7fffffe          BL       pwm_init
;;;278       // TIM_SetCompare1(TIM1, 5000);
;;;279       // TIM_SetCompare4(TIM1, 5000);
;;;280        tb6612->ioctl = ioctl;
00023e  492a              LDR      r1,|L1.744|
000240  6221              STR      r1,[r4,#0x20]
;;;281    }
000242  bd10              POP      {r4,pc}
                          ENDP

                  gpio_init PROC
;;;40     
;;;41     static void gpio_init(tb6612_t *tb6612)
000244  b538              PUSH     {r3-r5,lr}
;;;42     {
000246  4604              MOV      r4,r0
;;;43         GPIO_InitTypeDef GPIO_Initure;
;;;44     
;;;45         /* 开启时钟 */
;;;46         open_gpiox_clock(tb6612->GPIOx_A1);
000248  6800              LDR      r0,[r0,#0]
00024a  f7fffffe          BL       open_gpiox_clock
;;;47         open_gpiox_clock(tb6612->GPIOx_A2);
00024e  6860              LDR      r0,[r4,#4]
000250  f7fffffe          BL       open_gpiox_clock
;;;48         open_gpiox_clock(tb6612->GPIOx_B1);
000254  68a0              LDR      r0,[r4,#8]
000256  f7fffffe          BL       open_gpiox_clock
;;;49         open_gpiox_clock(tb6612->GPIOx_B2);
00025a  68e0              LDR      r0,[r4,#0xc]
00025c  f7fffffe          BL       open_gpiox_clock
;;;50     
;;;51         // GPIO_LED初始化设置
;;;52         GPIO_Initure.GPIO_Pin = tb6612->GPIO_A1;
000260  8a20              LDRH     r0,[r4,#0x10]
000262  f8ad0000          STRH     r0,[sp,#0]
;;;53         GPIO_Initure.GPIO_Speed = GPIO_Speed_50MHz;
000266  2003              MOVS     r0,#3
000268  f88d0002          STRB     r0,[sp,#2]
;;;54         GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_PP; // 通用推挽输出
00026c  2010              MOVS     r0,#0x10
00026e  f88d0003          STRB     r0,[sp,#3]
;;;55         GPIO_Init(tb6612->GPIOx_A1, &GPIO_Initure);
000272  4669              MOV      r1,sp
000274  6820              LDR      r0,[r4,#0]
000276  f7fffffe          BL       GPIO_Init
;;;56     
;;;57         GPIO_Initure.GPIO_Pin = tb6612->GPIO_A2;
00027a  8aa0              LDRH     r0,[r4,#0x14]
00027c  f8ad0000          STRH     r0,[sp,#0]
;;;58         GPIO_Init(tb6612->GPIOx_A2, &GPIO_Initure);
000280  4669              MOV      r1,sp
000282  6860              LDR      r0,[r4,#4]
000284  f7fffffe          BL       GPIO_Init
;;;59     
;;;60         GPIO_Initure.GPIO_Pin = tb6612->GPIO_B1;
000288  8b20              LDRH     r0,[r4,#0x18]
00028a  f8ad0000          STRH     r0,[sp,#0]
;;;61         GPIO_Init(tb6612->GPIOx_B1, &GPIO_Initure);
00028e  4669              MOV      r1,sp
000290  68a0              LDR      r0,[r4,#8]
000292  f7fffffe          BL       GPIO_Init
;;;62     
;;;63         GPIO_Initure.GPIO_Pin = tb6612->GPIO_B2;
000296  8ba0              LDRH     r0,[r4,#0x1c]
000298  f8ad0000          STRH     r0,[sp,#0]
;;;64         GPIO_Init(tb6612->GPIOx_B2, &GPIO_Initure);
00029c  4669              MOV      r1,sp
00029e  68e0              LDR      r0,[r4,#0xc]
0002a0  f7fffffe          BL       GPIO_Init
;;;65     
;;;66         ioctl(tb6612, tb6612->GPIO_A1, 1);
0002a4  2201              MOVS     r2,#1
0002a6  4620              MOV      r0,r4
0002a8  6921              LDR      r1,[r4,#0x10]
0002aa  f7fffffe          BL       ioctl
;;;67         ioctl(tb6612, tb6612->GPIO_A2, 1);
0002ae  2201              MOVS     r2,#1
0002b0  4620              MOV      r0,r4
0002b2  6961              LDR      r1,[r4,#0x14]
0002b4  f7fffffe          BL       ioctl
;;;68         ioctl(tb6612, tb6612->GPIO_B1, 1);
0002b8  2201              MOVS     r2,#1
0002ba  4620              MOV      r0,r4
0002bc  69a1              LDR      r1,[r4,#0x18]
0002be  f7fffffe          BL       ioctl
;;;69         ioctl(tb6612, tb6612->GPIO_B2, 1);
0002c2  2201              MOVS     r2,#1
0002c4  4620              MOV      r0,r4
0002c6  69e1              LDR      r1,[r4,#0x1c]
0002c8  f7fffffe          BL       ioctl
;;;70     }
0002cc  bd38              POP      {r3-r5,pc}
;;;71     
                          ENDP

0002ce  0000              DCW      0x0000
                  |L1.720|
                          DCD      0x40010800
                  |L1.724|
                          DCD      0x40010c00
                  |L1.728|
                          DCD      0x40011000
                  |L1.732|
                          DCD      0x40011400
                  |L1.736|
                          DCD      0x40011800
                  |L1.740|
                          DCD      0x40013400
                  |L1.744|
                          DCD      ioctl

                          AREA ||.data||, DATA, ALIGN=2

                  motorAB
                          DCD      0x40011000
                          DCD      0x40011000
                          DCD      0x40011000
                          DCD      0x40011000
                          DCD      0x00000001
                          DCD      0x00000002
                          DCD      0x00000004
                          DCD      0x00000008
                          DCD      0x00000000
