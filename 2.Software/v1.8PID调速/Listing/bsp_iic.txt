; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_iic.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_iic.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_iic.crf ..\..\BSP\bsp_iic.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  IIC_Init_t PROC
;;;196    // 初始化IIC引脚
;;;197    static void IIC_Init_t(const struct IIC_Type *IIC_Type_t)
000000  b5f8              PUSH     {r3-r7,lr}
;;;198    {
000002  4604              MOV      r4,r0
;;;199        GPIO_InitTypeDef GPIO_Initure;
;;;200    
;;;201        // 根据GPIO组初始化GPIO时钟
;;;202        if (IIC_Type_t->GPIOx_SCL == GPIOA || IIC_Type_t->GPIOx_SDA == GPIOA)
000004  6801              LDR      r1,[r0,#0]
000006  48bd              LDR      r0,|L1.764|
000008  4281              CMP      r1,r0
00000a  d002              BEQ      |L1.18|
00000c  6861              LDR      r1,[r4,#4]
00000e  4281              CMP      r1,r0
000010  d103              BNE      |L1.26|
                  |L1.18|
;;;203        {
;;;204            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 使能GPIOA时钟
000012  2101              MOVS     r1,#1
000014  2004              MOVS     r0,#4
000016  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.26|
;;;205        }
;;;206        if (IIC_Type_t->GPIOx_SCL == GPIOB || IIC_Type_t->GPIOx_SDA == GPIOB)
00001a  48b9              LDR      r0,|L1.768|
00001c  6821              LDR      r1,[r4,#0]
00001e  4281              CMP      r1,r0
000020  d002              BEQ      |L1.40|
000022  6861              LDR      r1,[r4,#4]
000024  4281              CMP      r1,r0
000026  d103              BNE      |L1.48|
                  |L1.40|
;;;207        {
;;;208            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 使能GPIOB时钟
000028  2101              MOVS     r1,#1
00002a  2008              MOVS     r0,#8
00002c  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.48|
;;;209        }
;;;210        if (IIC_Type_t->GPIOx_SCL == GPIOC || IIC_Type_t->GPIOx_SDA == GPIOC)
000030  48b4              LDR      r0,|L1.772|
000032  6821              LDR      r1,[r4,#0]
000034  4281              CMP      r1,r0
000036  d002              BEQ      |L1.62|
000038  6861              LDR      r1,[r4,#4]
00003a  4281              CMP      r1,r0
00003c  d103              BNE      |L1.70|
                  |L1.62|
;;;211        {
;;;212            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // 使能GPIOC时钟
00003e  2101              MOVS     r1,#1
000040  2010              MOVS     r0,#0x10
000042  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.70|
;;;213        }
;;;214        if (IIC_Type_t->GPIOx_SCL == GPIOD || IIC_Type_t->GPIOx_SDA == GPIOD)
000046  48b0              LDR      r0,|L1.776|
000048  6821              LDR      r1,[r4,#0]
00004a  4281              CMP      r1,r0
00004c  d002              BEQ      |L1.84|
00004e  6861              LDR      r1,[r4,#4]
000050  4281              CMP      r1,r0
000052  d103              BNE      |L1.92|
                  |L1.84|
;;;215        {
;;;216            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // 使能GPIOD时钟
000054  2101              MOVS     r1,#1
000056  2020              MOVS     r0,#0x20
000058  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.92|
;;;217        }
;;;218        if (IIC_Type_t->GPIOx_SCL == GPIOE || IIC_Type_t->GPIOx_SDA == GPIOE)
00005c  48ab              LDR      r0,|L1.780|
00005e  6821              LDR      r1,[r4,#0]
000060  4281              CMP      r1,r0
000062  d002              BEQ      |L1.106|
000064  6861              LDR      r1,[r4,#4]
000066  4281              CMP      r1,r0
000068  d103              BNE      |L1.114|
                  |L1.106|
;;;219        {
;;;220            RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); // 使能GPIOE时钟
00006a  2101              MOVS     r1,#1
00006c  2040              MOVS     r0,#0x40
00006e  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.114|
;;;221        }
;;;222    
;;;223        // GPIO_SCL初始化设置
;;;224        GPIO_Initure.GPIO_Pin = IIC_Type_t->GPIO_SCL;
000072  8920              LDRH     r0,[r4,#8]
000074  f8ad0000          STRH     r0,[sp,#0]
;;;225        GPIO_Initure.GPIO_Speed = GPIO_Speed_50MHz;
000078  2503              MOVS     r5,#3
00007a  f88d5002          STRB     r5,[sp,#2]
;;;226        GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_OD; // 开漏输出
00007e  2614              MOVS     r6,#0x14
000080  f88d6003          STRB     r6,[sp,#3]
;;;227        // GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出
;;;228        GPIO_Init(IIC_Type_t->GPIOx_SCL, &GPIO_Initure);
000084  4669              MOV      r1,sp
000086  6820              LDR      r0,[r4,#0]
000088  f7fffffe          BL       GPIO_Init
;;;229    
;;;230        // GPIO_SDA初始化设置
;;;231        GPIO_Initure.GPIO_Pin = IIC_Type_t->GPIO_SDA;
00008c  89a0              LDRH     r0,[r4,#0xc]
00008e  f8ad0000          STRH     r0,[sp,#0]
;;;232        GPIO_Initure.GPIO_Speed = GPIO_Speed_50MHz;
000092  f88d5002          STRB     r5,[sp,#2]
;;;233        GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_OD; // 开漏输出
000096  f88d6003          STRB     r6,[sp,#3]
;;;234        // GPIO_Initure.GPIO_Mode = GPIO_Mode_Out_PP; // 推挽输出
;;;235        GPIO_Init(IIC_Type_t->GPIOx_SDA, &GPIO_Initure);
00009a  4669              MOV      r1,sp
00009c  6860              LDR      r0,[r4,#4]
00009e  f7fffffe          BL       GPIO_Init
;;;236    
;;;237        // SCL与SDA的初始化均为高电平
;;;238        GPIO_SetBits(IIC_Type_t->GPIOx_SCL, IIC_Type_t->GPIO_SCL);
0000a2  8920              LDRH     r0,[r4,#8]
0000a4  b281              UXTH     r1,r0
0000a6  6820              LDR      r0,[r4,#0]
0000a8  f7fffffe          BL       GPIO_SetBits
;;;239        GPIO_SetBits(IIC_Type_t->GPIOx_SDA, IIC_Type_t->GPIO_SDA);
0000ac  89a0              LDRH     r0,[r4,#0xc]
0000ae  b281              UXTH     r1,r0
0000b0  6860              LDR      r0,[r4,#4]
0000b2  f7fffffe          BL       GPIO_SetBits
;;;240        // log(INFO,"IIC init");
;;;241        //  IIC_SCL(IIC_Type_t, 1);
;;;242        //  IIC_SDA(IIC_Type_t, 1);
;;;243        /* 野火 */
;;;244        /* 给一个停止信号, 复位I2C总线上的所有设备到待机模式 */
;;;245        // IIC_Type_t->IIC_Stop(IIC_Type_t);
;;;246    }
0000b6  bdf8              POP      {r3-r7,pc}
;;;247    
                          ENDP

                  IIC_Start_t PROC
;;;286    // IIC Start
;;;287    static void IIC_Start_t(const struct IIC_Type *IIC_Type_t)
0000b8  b510              PUSH     {r4,lr}
;;;288    {
0000ba  4604              MOV      r4,r0
;;;289    #if 0
;;;290        SDA_OUT(IIC_Type_t); // sda线输出
;;;291        IIC_SDA(IIC_Type_t, 1);
;;;292        IIC_SCL(IIC_Type_t, 1);
;;;293        IIC_Type_t->delay_us(4);
;;;294        IIC_SDA(IIC_Type_t, 0); // START:when CLK is high,DATA change form high to low
;;;295        IIC_Type_t->delay_us(4);
;;;296        IIC_SCL(IIC_Type_t, 0); // 钳住I2C总线，准备发送或接收数据
;;;297    #endif
;;;298        /* 野火 */
;;;299        SDA_OUT(IIC_Type_t);
0000bc  f7fffffe          BL       SDA_OUT
;;;300        IIC_SDA(IIC_Type_t, 1);
0000c0  2101              MOVS     r1,#1
0000c2  4620              MOV      r0,r4
0000c4  f7fffffe          BL       IIC_SDA
;;;301        IIC_SCL(IIC_Type_t, 1);
0000c8  2101              MOVS     r1,#1
0000ca  4620              MOV      r0,r4
0000cc  f7fffffe          BL       IIC_SCL
;;;302        IIC_Type_t->delay_us(1);
0000d0  6b21              LDR      r1,[r4,#0x30]
0000d2  2001              MOVS     r0,#1
0000d4  4788              BLX      r1
;;;303        IIC_SDA(IIC_Type_t, 0); // START:when CLK is high,DATA change form high to low
0000d6  2100              MOVS     r1,#0
0000d8  4620              MOV      r0,r4
0000da  f7fffffe          BL       IIC_SDA
;;;304        IIC_Type_t->delay_us(1);
0000de  6b21              LDR      r1,[r4,#0x30]
0000e0  2001              MOVS     r0,#1
0000e2  4788              BLX      r1
;;;305        IIC_SCL(IIC_Type_t, 0); // 钳住I2C总线，准备发送或接收数据
0000e4  2100              MOVS     r1,#0
0000e6  4620              MOV      r0,r4
0000e8  f7fffffe          BL       IIC_SCL
;;;306        IIC_Type_t->delay_us(1);
0000ec  6b21              LDR      r1,[r4,#0x30]
0000ee  e8bd4010          POP      {r4,lr}
0000f2  2001              MOVS     r0,#1
0000f4  4708              BX       r1
;;;307    }
;;;308    
                          ENDP

                  IIC_Stop_t PROC
;;;309    // IIC Stop
;;;310    static void IIC_Stop_t(const struct IIC_Type *IIC_Type_t)
0000f6  b510              PUSH     {r4,lr}
;;;311    {
0000f8  4604              MOV      r4,r0
;;;312    #if 0
;;;313        SDA_OUT(IIC_Type_t); // sda线输出
;;;314        IIC_SCL(IIC_Type_t, 0);
;;;315        IIC_SDA(IIC_Type_t, 0); // STOP:when CLK is high DATA change form low to high
;;;316        IIC_Type_t->delay_us(4);
;;;317        IIC_SCL(IIC_Type_t, 1);
;;;318        IIC_SDA(IIC_Type_t, 1); // 发送I2C总线结束信号
;;;319        IIC_Type_t->delay_us(4);
;;;320    #else /* 野火的 */
;;;321        SDA_OUT(IIC_Type_t);
0000fa  f7fffffe          BL       SDA_OUT
;;;322        IIC_SDA(IIC_Type_t, 0);
0000fe  2100              MOVS     r1,#0
000100  4620              MOV      r0,r4
000102  f7fffffe          BL       IIC_SDA
;;;323        IIC_SCL(IIC_Type_t, 1);
000106  2101              MOVS     r1,#1
000108  4620              MOV      r0,r4
00010a  f7fffffe          BL       IIC_SCL
;;;324        IIC_Type_t->delay_us(2);
00010e  6b21              LDR      r1,[r4,#0x30]
000110  2002              MOVS     r0,#2
000112  4788              BLX      r1
;;;325        IIC_SDA(IIC_Type_t, 1);
000114  4620              MOV      r0,r4
000116  e8bd4010          POP      {r4,lr}
00011a  2101              MOVS     r1,#1
00011c  f7ffbffe          B.W      IIC_SDA
;;;326    #endif
;;;327    }
;;;328    
                          ENDP

                  IIC_Wait_Ack_t PROC
;;;329    // IIC_Wait_ack 返回0表示wait成功，返回1表示wait失败
;;;330    static uint8_t IIC_Wait_Ack_t(const struct IIC_Type *IIC_Type_t) // IIC_Wait_ack,返回wait失败或是成功
000120  b570              PUSH     {r4-r6,lr}
;;;331    {
000122  4604              MOV      r4,r0
;;;332    #if 0
;;;333        uint8_t ucErrTime = 0;
;;;334        //SDA_IN(IIC_Type_t);      //SDA设置为输入
;;;335        IIC_SDA(IIC_Type_t, 1);
;;;336        IIC_Type_t->delay_us(1);
;;;337        IIC_SCL(IIC_Type_t, 1);
;;;338        IIC_Type_t->delay_us(1);
;;;339        while (READ_SDA(IIC_Type_t))
;;;340        {
;;;341            ucErrTime++;
;;;342            if (ucErrTime > 250)
;;;343            {
;;;344                IIC_Type_t->IIC_Stop(IIC_Type_t);
;;;345                return 1;
;;;346            }
;;;347        }
;;;348        IIC_SCL(IIC_Type_t, 0); // 时钟输出0
;;;349        return 0;
;;;350    #endif
;;;351    #if 1
;;;352        /* 野火 */
;;;353        uint8_t re;
;;;354        SDA_IN(IIC_Type_t);
000124  f7fffffe          BL       SDA_IN
;;;355        IIC_SDA(IIC_Type_t, 1);
000128  2101              MOVS     r1,#1
00012a  4620              MOV      r0,r4
00012c  f7fffffe          BL       IIC_SDA
;;;356        IIC_Type_t->delay_us(1);
000130  6b21              LDR      r1,[r4,#0x30]
000132  2001              MOVS     r0,#1
000134  4788              BLX      r1
;;;357        IIC_SCL(IIC_Type_t, 1);
000136  2101              MOVS     r1,#1
000138  4620              MOV      r0,r4
00013a  f7fffffe          BL       IIC_SCL
;;;358        IIC_Type_t->delay_us(1);
00013e  6b21              LDR      r1,[r4,#0x30]
000140  2001              MOVS     r0,#1
000142  4788              BLX      r1
;;;359        if (READ_SDA(IIC_Type_t))
000144  4620              MOV      r0,r4
000146  f7fffffe          BL       READ_SDA
00014a  b108              CBZ      r0,|L1.336|
;;;360        {
;;;361            re = 1;
00014c  2501              MOVS     r5,#1
00014e  e000              B        |L1.338|
                  |L1.336|
;;;362        }
;;;363        else
;;;364        {
;;;365            re = 0;
000150  2500              MOVS     r5,#0
                  |L1.338|
;;;366        }
;;;367        IIC_SCL(IIC_Type_t, 0);
000152  2100              MOVS     r1,#0
000154  4620              MOV      r0,r4
000156  f7fffffe          BL       IIC_SCL
;;;368        IIC_Type_t->delay_us(1);
00015a  6b21              LDR      r1,[r4,#0x30]
00015c  2001              MOVS     r0,#1
00015e  4788              BLX      r1
;;;369        return re;
000160  4628              MOV      r0,r5
;;;370    #endif
;;;371    #if 0
;;;372        /* 原子 */
;;;373        u8 ucErrTime = 0;
;;;374        MPU_SDA_IN(); // SDA设置为输入
;;;375        MPU_IIC_SDA = 1;
;;;376        MPU_IIC_Delay();
;;;377        MPU_IIC_SCL = 1;
;;;378        MPU_IIC_Delay();
;;;379        while (MPU_READ_SDA)
;;;380        {
;;;381            ucErrTime++;
;;;382            if (ucErrTime > 250)
;;;383            {
;;;384                MPU_IIC_Stop();
;;;385                return 1;
;;;386            }
;;;387        }
;;;388        MPU_IIC_SCL = 0; // 时钟输出0
;;;389        return 0;
;;;390    #endif
;;;391    
;;;392        // uint8_t re;
;;;393        // u8 ucErrTime = 0;
;;;394        // // SDA_IN(IIC_Type_t);
;;;395        // GPIOA->CRL &= 0X0FFFFFFF;
;;;396        // GPIOA->CRL |= 8 << 28;
;;;397        // IIC_SDA(IIC_Type_t, 1);
;;;398        // IIC_Type_t->delay_us(2);
;;;399        // IIC_SCL(IIC_Type_t, 1);
;;;400        // IIC_Type_t->delay_us(2);
;;;401        // while (READ_SDA(IIC_Type_t))
;;;402        // {
;;;403        //     ucErrTime++;
;;;404        //     if (ucErrTime > 250)
;;;405        //     {
;;;406        //         IIC_Type_t->IIC_Stop(IIC_Type_t);
;;;407        //         return 1;
;;;408        //     }
;;;409        // }
;;;410        // IIC_SCL(IIC_Type_t, 0);
;;;411        // return 0;
;;;412        // IIC_Type_t->delay_us(2);
;;;413        //  if (READ_SDA(IIC_Type_t))
;;;414        //  {
;;;415        //      re = 1;
;;;416        //  }
;;;417        //  else
;;;418        //  {
;;;419        //      re = 0;
;;;420        //  }
;;;421    }
000162  bd70              POP      {r4-r6,pc}
;;;422    
                          ENDP

                  IIC_Ack_t PROC
;;;423    // 产生ACK应答
;;;424    static void IIC_Ack_t(const struct IIC_Type *IIC_Type_t)
000164  b510              PUSH     {r4,lr}
;;;425    {
000166  4604              MOV      r4,r0
;;;426    #if 0
;;;427        IIC_SCL(IIC_Type_t, 0);
;;;428        SDA_OUT(IIC_Type_t);
;;;429        IIC_SDA(IIC_Type_t, 0);
;;;430        IIC_Type_t->delay_us(2);
;;;431        IIC_SCL(IIC_Type_t, 1);
;;;432        IIC_Type_t->delay_us(2);
;;;433        IIC_SCL(IIC_Type_t, 0);
;;;434    #endif
;;;435        /* 野火 */
;;;436        SDA_OUT(IIC_Type_t);
000168  f7fffffe          BL       SDA_OUT
;;;437        IIC_SDA(IIC_Type_t, 0);
00016c  2100              MOVS     r1,#0
00016e  4620              MOV      r0,r4
000170  f7fffffe          BL       IIC_SDA
;;;438        IIC_Type_t->delay_us(2);
000174  6b21              LDR      r1,[r4,#0x30]
000176  2002              MOVS     r0,#2
000178  4788              BLX      r1
;;;439        IIC_SCL(IIC_Type_t, 1);
00017a  2101              MOVS     r1,#1
00017c  4620              MOV      r0,r4
00017e  f7fffffe          BL       IIC_SCL
;;;440        IIC_Type_t->delay_us(2);
000182  6b21              LDR      r1,[r4,#0x30]
000184  2002              MOVS     r0,#2
000186  4788              BLX      r1
;;;441        IIC_SCL(IIC_Type_t, 0);
000188  2100              MOVS     r1,#0
00018a  4620              MOV      r0,r4
00018c  f7fffffe          BL       IIC_SCL
;;;442        IIC_Type_t->delay_us(2);
000190  6b21              LDR      r1,[r4,#0x30]
000192  2002              MOVS     r0,#2
000194  4788              BLX      r1
;;;443        IIC_SDA(IIC_Type_t, 1);
000196  4620              MOV      r0,r4
000198  e8bd4010          POP      {r4,lr}
00019c  2101              MOVS     r1,#1
00019e  f7ffbffe          B.W      IIC_SDA
;;;444    }
;;;445    
                          ENDP

                  IIC_NAck_t PROC
;;;446    // 产生NACK应答
;;;447    static void IIC_NAck_t(const struct IIC_Type *IIC_Type_t)
0001a2  b510              PUSH     {r4,lr}
;;;448    {
0001a4  4604              MOV      r4,r0
;;;449    #if 0
;;;450        IIC_SCL(IIC_Type_t, 0);
;;;451        SDA_OUT(IIC_Type_t);
;;;452        IIC_SDA(IIC_Type_t, 1);
;;;453        IIC_Type_t->delay_us(2);
;;;454        IIC_SCL(IIC_Type_t, 1);
;;;455        IIC_Type_t->delay_us(2);
;;;456        IIC_SCL(IIC_Type_t, 0);
;;;457    #endif
;;;458        /* 野火 */
;;;459        IIC_SDA(IIC_Type_t, 1);
0001a6  2101              MOVS     r1,#1
0001a8  f7fffffe          BL       IIC_SDA
;;;460        IIC_Type_t->delay_us(1);
0001ac  6b21              LDR      r1,[r4,#0x30]
0001ae  2001              MOVS     r0,#1
0001b0  4788              BLX      r1
;;;461        IIC_SCL(IIC_Type_t, 1);
0001b2  2101              MOVS     r1,#1
0001b4  4620              MOV      r0,r4
0001b6  f7fffffe          BL       IIC_SCL
;;;462        IIC_Type_t->delay_us(1);
0001ba  6b21              LDR      r1,[r4,#0x30]
0001bc  2001              MOVS     r0,#1
0001be  4788              BLX      r1
;;;463        IIC_SCL(IIC_Type_t, 0);
0001c0  2100              MOVS     r1,#0
0001c2  4620              MOV      r0,r4
0001c4  f7fffffe          BL       IIC_SCL
;;;464        IIC_Type_t->delay_us(1);
0001c8  6b21              LDR      r1,[r4,#0x30]
0001ca  e8bd4010          POP      {r4,lr}
0001ce  2001              MOVS     r0,#1
0001d0  4708              BX       r1
;;;465    }
;;;466    
                          ENDP

                  IIC_Send_Byte_t PROC
;;;467    // IIC_Send_Byte，入口参数为要发送的字节
;;;468    static void IIC_Send_Byte_t(const struct IIC_Type *IIC_Type_t, uint8_t txd)
0001d2  b570              PUSH     {r4-r6,lr}
;;;469    {
0001d4  460d              MOV      r5,r1
0001d6  4606              MOV      r6,r0
;;;470    #if 0
;;;471        uint8_t t = 0;
;;;472        SDA_OUT(IIC_Type_t);
;;;473        IIC_SCL(IIC_Type_t, 0); // 拉低时钟开始数据传输
;;;474        for (t = 0; t < 8; t++)
;;;475        {
;;;476            IIC_SDA(IIC_Type_t, (txd & 0x80) >> 7);
;;;477            txd <<= 1;
;;;478            IIC_Type_t->delay_us(2); // 对TEA5767这三个延时都是必须的
;;;479            IIC_SCL(IIC_Type_t, 1);
;;;480            IIC_Type_t->delay_us(2);
;;;481            IIC_SCL(IIC_Type_t, 0);
;;;482            IIC_Type_t->delay_us(2);
;;;483        }
;;;484    #endif
;;;485        /* 野火 */
;;;486        uint8_t i;
;;;487        SDA_OUT(IIC_Type_t);
0001d8  f7fffffe          BL       SDA_OUT
;;;488        /* 先发送字节的高位bit7 */
;;;489        for (i = 0; i < 8; i++)
0001dc  2400              MOVS     r4,#0
                  |L1.478|
;;;490        {
;;;491            if (txd & 0x80)
0001de  0628              LSLS     r0,r5,#24
0001e0  d501              BPL      |L1.486|
;;;492            {
;;;493                IIC_SDA(IIC_Type_t, 1);
0001e2  2101              MOVS     r1,#1
0001e4  e000              B        |L1.488|
                  |L1.486|
;;;494                // EEPROM_I2C_SDA_1();
;;;495            }
;;;496            else
;;;497            {
;;;498                IIC_SDA(IIC_Type_t, 0);
0001e6  2100              MOVS     r1,#0
                  |L1.488|
0001e8  4630              MOV      r0,r6
0001ea  f7fffffe          BL       IIC_SDA
;;;499                // EEPROM_I2C_SDA_0();
;;;500            }
;;;501            IIC_Type_t->delay_us(2);
0001ee  6b31              LDR      r1,[r6,#0x30]
0001f0  2002              MOVS     r0,#2
0001f2  4788              BLX      r1
;;;502            IIC_SCL(IIC_Type_t, 1);
0001f4  2101              MOVS     r1,#1
0001f6  4630              MOV      r0,r6
0001f8  f7fffffe          BL       IIC_SCL
;;;503            // EEPROM_I2C_SCL_1();
;;;504            IIC_Type_t->delay_us(2);
0001fc  6b31              LDR      r1,[r6,#0x30]
0001fe  2002              MOVS     r0,#2
000200  4788              BLX      r1
;;;505            IIC_SCL(IIC_Type_t, 0);
000202  2100              MOVS     r1,#0
000204  4630              MOV      r0,r6
000206  f7fffffe          BL       IIC_SCL
;;;506            // EEPROM_I2C_SCL_0();
;;;507            if (i == 7)
00020a  2c07              CMP      r4,#7
00020c  d103              BNE      |L1.534|
;;;508            {
;;;509                IIC_SDA(IIC_Type_t, 1);
00020e  2101              MOVS     r1,#1
000210  4630              MOV      r0,r6
000212  f7fffffe          BL       IIC_SDA
                  |L1.534|
;;;510                // EEPROM_I2C_SDA_1(); // 释放总线
;;;511            }
;;;512            txd <<= 1; /* 左移一个bit */
000216  0668              LSLS     r0,r5,#25
000218  0e05              LSRS     r5,r0,#24
;;;513            IIC_Type_t->delay_us(2);
00021a  6b31              LDR      r1,[r6,#0x30]
00021c  2002              MOVS     r0,#2
00021e  4788              BLX      r1
000220  1c64              ADDS     r4,r4,#1
000222  b2e4              UXTB     r4,r4                 ;489
000224  2c08              CMP      r4,#8                 ;489
000226  d3da              BCC      |L1.478|
;;;514        }
;;;515    }
000228  bd70              POP      {r4-r6,pc}
;;;516    
                          ENDP

                  IIC_Read_Byte_t PROC
;;;517    // IIC_Send_Byte，入口参数为是否要发送ACK信号
;;;518    static uint8_t IIC_Read_Byte_t(const struct IIC_Type *IIC_Type_t, uint8_t ack)
00022a  b570              PUSH     {r4-r6,lr}
;;;519    {
00022c  4606              MOV      r6,r0
;;;520    #if 0
;;;521        uint8_t i, receive = 0;
;;;522        SDA_IN(IIC_Type_t); // SDA设置为输入
;;;523        for (i = 0; i < 8; i++)
;;;524        {
;;;525            IIC_SCL(IIC_Type_t, 0);
;;;526            IIC_Type_t->delay_us(2);
;;;527            IIC_SCL(IIC_Type_t, 1);
;;;528            receive <<= 1;
;;;529            if (READ_SDA(IIC_Type_t))
;;;530                receive++;
;;;531            IIC_Type_t->delay_us(1);
;;;532        }
;;;533        if (!ack)
;;;534            IIC_Type_t->IIC_NAck(IIC_Type_t); // 发送nACK
;;;535        else
;;;536            IIC_Type_t->IIC_Ack(IIC_Type_t); // 发送ACK
;;;537        return receive;
;;;538    #endif
;;;539    #if 1
;;;540        /* 野火 */
;;;541        uint8_t i;
;;;542        uint8_t value;
;;;543        SDA_IN(IIC_Type_t); // SDA设置为输入
00022e  f7fffffe          BL       SDA_IN
;;;544        /* 读到第1个bit为数据的bit7 */
;;;545        value = 0;
000232  2400              MOVS     r4,#0
;;;546        for (i = 0; i < 8; i++)
000234  4625              MOV      r5,r4
                  |L1.566|
;;;547        {
;;;548            value <<= 1;
000236  0660              LSLS     r0,r4,#25
000238  0e04              LSRS     r4,r0,#24
;;;549            IIC_SCL(IIC_Type_t, 1);
00023a  2101              MOVS     r1,#1
00023c  4630              MOV      r0,r6
00023e  f7fffffe          BL       IIC_SCL
;;;550            IIC_Type_t->delay_us(1);
000242  6b31              LDR      r1,[r6,#0x30]
000244  2001              MOVS     r0,#1
000246  4788              BLX      r1
;;;551            if (READ_SDA(IIC_Type_t))
000248  4630              MOV      r0,r6
00024a  f7fffffe          BL       READ_SDA
00024e  b108              CBZ      r0,|L1.596|
000250  1c64              ADDS     r4,r4,#1
;;;552            {
;;;553                value++;
000252  b2e4              UXTB     r4,r4
                  |L1.596|
;;;554            }
;;;555            IIC_SCL(IIC_Type_t, 0);
000254  2100              MOVS     r1,#0
000256  4630              MOV      r0,r6
000258  f7fffffe          BL       IIC_SCL
;;;556            IIC_Type_t->delay_us(1);
00025c  6b31              LDR      r1,[r6,#0x30]
00025e  2001              MOVS     r0,#1
000260  4788              BLX      r1
000262  1c6d              ADDS     r5,r5,#1
000264  b2ed              UXTB     r5,r5                 ;546
000266  2d08              CMP      r5,#8                 ;546
000268  d3e5              BCC      |L1.566|
;;;557        }
;;;558        return value;
00026a  4620              MOV      r0,r4
;;;559    #endif
;;;560    #if 0
;;;561        uint8_t i;
;;;562        uint8_t value;
;;;563    
;;;564        value = 0;
;;;565        for (i = 0; i < 8; i++)
;;;566        {
;;;567            value <<= 1;
;;;568            IIC_SCL(IIC_Type_t, 1);
;;;569            IIC_Type_t->delay_us(1);
;;;570            //if (EEPROM_I2C_SDA_READ())
;;;571            if (READ_SDA(IIC_Type_t))     
;;;572            {
;;;573                value++;
;;;574            }
;;;575            IIC_SCL(IIC_Type_t, 0);
;;;576            //EEPROM_I2C_SCL_0();
;;;577            IIC_Type_t->delay_us(1);
;;;578            // i2c_Delay();
;;;579        }
;;;580        return value;
;;;581    #endif
;;;582    }
00026c  bd70              POP      {r4-r6,pc}
;;;583    
                          ENDP

                  create_iic PROC
;;;584    void create_iic(struct IIC_Type *IIC_Type_t)
00026e  4928              LDR      r1,|L1.784|
;;;585    {
;;;586        IIC_Type_t->IIC_Init = IIC_Init_t;
;;;587        IIC_Type_t->IIC_Start = IIC_Start_t;
000270  6101              STR      r1,[r0,#0x10]
000272  4928              LDR      r1,|L1.788|
;;;588        IIC_Type_t->IIC_Stop = IIC_Stop_t;
000274  6141              STR      r1,[r0,#0x14]
000276  4928              LDR      r1,|L1.792|
;;;589        IIC_Type_t->IIC_Wait_Ack = IIC_Wait_Ack_t;
000278  6181              STR      r1,[r0,#0x18]
00027a  4928              LDR      r1,|L1.796|
;;;590        IIC_Type_t->IIC_Ack = IIC_Ack_t;
00027c  61c1              STR      r1,[r0,#0x1c]
00027e  4928              LDR      r1,|L1.800|
;;;591        IIC_Type_t->IIC_NAck = IIC_NAck_t;
000280  6201              STR      r1,[r0,#0x20]
000282  4928              LDR      r1,|L1.804|
;;;592        IIC_Type_t->IIC_Send_Byte = IIC_Send_Byte_t;
000284  6241              STR      r1,[r0,#0x24]
000286  4928              LDR      r1,|L1.808|
;;;593        IIC_Type_t->IIC_Read_Byte = IIC_Read_Byte_t;
000288  6281              STR      r1,[r0,#0x28]
00028a  4928              LDR      r1,|L1.812|
;;;594        IIC_Type_t->IIC_Init(IIC_Type_t);
00028c  62c1              STR      r1,[r0,#0x2c]
00028e  e7fe              B        IIC_Init_t
;;;595    }
                          ENDP

                  SDA_IN PROC
;;;16     
;;;17     static void SDA_IN(const struct IIC_Type *IIC_Type_t)
000290  68c0              LDR      r0,[r0,#0xc]
;;;18     {
;;;19     #if 0
;;;20         // uint8_t io_num = 0;
;;;21         // switch (IIC_Type_t->GPIO_SDA)
;;;22         // {
;;;23         // case GPIO_Pin_0:
;;;24         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFFFF0;
;;;25         //     io_num = 0;
;;;26         //     break;
;;;27         // case GPIO_Pin_1:
;;;28         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFFF0F;
;;;29         //     io_num = 1;
;;;30         //     break;
;;;31         // case GPIO_Pin_2:
;;;32         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFF0FF;
;;;33         //     io_num = 2;
;;;34         //     break;
;;;35         // case GPIO_Pin_3:
;;;36         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFF0FFF;
;;;37         //     io_num = 3;
;;;38         //     break;
;;;39         // case GPIO_Pin_4:
;;;40         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFFF0FFFF;
;;;41         //     io_num = 4;
;;;42         //     break;
;;;43         // case GPIO_Pin_5:
;;;44         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XFF0FFFFF;
;;;45         //     io_num = 5;
;;;46         //     break;
;;;47         // case GPIO_Pin_6:
;;;48         //     IIC_Type_t->GPIOx_SDA->CRL &= 0XF0FFFFFF;
;;;49         //     io_num = 6;
;;;50         //     break;
;;;51         // case GPIO_Pin_7:
;;;52         //     IIC_Type_t->GPIOx_SDA->CRL &= 0X0FFFFFFF;
;;;53         //     io_num = 7;
;;;54         //     break;
;;;55         // case GPIO_Pin_8:
;;;56         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFFFF0;
;;;57         //     io_num = 8;
;;;58         //     break;
;;;59         // case GPIO_Pin_9:
;;;60         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFFF0F;
;;;61         //     io_num = 9;
;;;62         //     break;
;;;63         // case GPIO_Pin_10:
;;;64         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFF0FF;
;;;65         //     io_num = 10;
;;;66         //     break;
;;;67         // case GPIO_Pin_11:
;;;68         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFF0FFF;
;;;69         //     io_num = 11;
;;;70         //     break;
;;;71         // case GPIO_Pin_12:
;;;72         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFFF0FFFF;
;;;73         //     io_num = 12;
;;;74         //     break;
;;;75         // case GPIO_Pin_13:
;;;76         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XFF0FFFFF;
;;;77         //     io_num = 13;
;;;78         //     break;
;;;79         // case GPIO_Pin_14:
;;;80         //     IIC_Type_t->GPIOx_SDA->CRH &= 0XF0FFFFFF;
;;;81         //     io_num = 14;
;;;82         //     break;
;;;83         // case GPIO_Pin_15:
;;;84         //     IIC_Type_t->GPIOx_SDA->CRH &= 0X0FFFFFFF;
;;;85         //     io_num = 15;
;;;86         //     break;
;;;87         // }
;;;88         // if (io_num < 8)
;;;89         // {
;;;90         //     IIC_Type_t->GPIOx_SDA->CRL |= (8 << (io_num * 4));
;;;91         // }
;;;92         // else
;;;93         // {
;;;94         //     io_num = io_num - 7;
;;;95         //     IIC_Type_t->GPIOx_SDA->CRH |= 8 << (io_num * 4);
;;;96         // }
;;;97     #endif
;;;98     
;;;99         switch (IIC_Type_t->GPIO_SDA)
000292  2880              CMP      r0,#0x80
000294  d108              BNE      |L1.680|
;;;100        {
;;;101        case GPIO_Pin_7:
;;;102            {GPIOA->CRL&=0X0FFFFFFF;GPIOA->CRL|=(u32)(8<<28);} 
000296  4819              LDR      r0,|L1.764|
000298  6801              LDR      r1,[r0,#0]
00029a  f0214170          BIC      r1,r1,#0xf0000000
00029e  6001              STR      r1,[r0,#0]
0002a0  6801              LDR      r1,[r0,#0]
0002a2  f0414100          ORR      r1,r1,#0x80000000
0002a6  6001              STR      r1,[r0,#0]
                  |L1.680|
;;;103            break;
;;;104        }
;;;105    }
0002a8  4770              BX       lr
;;;106    
                          ENDP

                  SDA_OUT PROC
;;;107    static void SDA_OUT(const struct IIC_Type *IIC_Type_t)
0002aa  68c0              LDR      r0,[r0,#0xc]
;;;108    {
;;;109        #if 0
;;;110        uint8_t io_num = 0;
;;;111        switch (IIC_Type_t->GPIO_SDA)
;;;112        {
;;;113        case GPIO_Pin_0:
;;;114            IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFFFF0;
;;;115            io_num = 0;
;;;116            break;
;;;117        case GPIO_Pin_1:
;;;118            IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFFF0F;
;;;119            io_num = 1;
;;;120            break;
;;;121        case GPIO_Pin_2:
;;;122            IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFFF0FF;
;;;123            io_num = 2;
;;;124            break;
;;;125        case GPIO_Pin_3:
;;;126            IIC_Type_t->GPIOx_SDA->CRL &= 0XFFFF0FFF;
;;;127            io_num = 3;
;;;128            break;
;;;129        case GPIO_Pin_4:
;;;130            IIC_Type_t->GPIOx_SDA->CRL &= 0XFFF0FFFF;
;;;131            io_num = 4;
;;;132            break;
;;;133        case GPIO_Pin_5:
;;;134            IIC_Type_t->GPIOx_SDA->CRL &= 0XFF0FFFFF;
;;;135            io_num = 5;
;;;136            break;
;;;137        case GPIO_Pin_6:
;;;138            IIC_Type_t->GPIOx_SDA->CRL &= 0XF0FFFFFF;
;;;139            io_num = 6;
;;;140            break;
;;;141        case GPIO_Pin_7:
;;;142            IIC_Type_t->GPIOx_SDA->CRL &= 0X0FFFFFFF;
;;;143            io_num = 7;
;;;144            break;
;;;145        case GPIO_Pin_8:
;;;146            IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFFFF0;
;;;147            io_num = 8;
;;;148            break;
;;;149        case GPIO_Pin_9:
;;;150            IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFFF0F;
;;;151            io_num = 9;
;;;152            break;
;;;153        case GPIO_Pin_10:
;;;154            IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFFF0FF;
;;;155            io_num = 10;
;;;156            break;
;;;157        case GPIO_Pin_11:
;;;158            IIC_Type_t->GPIOx_SDA->CRH &= 0XFFFF0FFF;
;;;159            io_num = 11;
;;;160            break;
;;;161        case GPIO_Pin_12:
;;;162            IIC_Type_t->GPIOx_SDA->CRH &= 0XFFF0FFFF;
;;;163            io_num = 12;
;;;164            break;
;;;165        case GPIO_Pin_13:
;;;166            IIC_Type_t->GPIOx_SDA->CRH &= 0XFF0FFFFF;
;;;167            io_num = 13;
;;;168            break;
;;;169        case GPIO_Pin_14:
;;;170            IIC_Type_t->GPIOx_SDA->CRH &= 0XF0FFFFFF;
;;;171            io_num = 14;
;;;172            break;
;;;173        case GPIO_Pin_15:
;;;174            IIC_Type_t->GPIOx_SDA->CRH &= 0X0FFFFFFF;
;;;175            io_num = 15;
;;;176            break;
;;;177        }
;;;178        if (io_num < 8)
;;;179        {
;;;180            IIC_Type_t->GPIOx_SDA->CRL |= (3 << (io_num * 4));
;;;181        }
;;;182        else
;;;183        {
;;;184            io_num = io_num - 7;
;;;185            IIC_Type_t->GPIOx_SDA->CRH |= 3 << (io_num * 4);
;;;186        }
;;;187        #endif
;;;188        switch (IIC_Type_t->GPIO_SDA)
0002ac  2880              CMP      r0,#0x80
0002ae  d108              BNE      |L1.706|
;;;189        {
;;;190        case GPIO_Pin_7:
;;;191            GPIOA->CRL&=0X0FFFFFFF;GPIOA->CRL|=3<<28;
0002b0  4812              LDR      r0,|L1.764|
0002b2  6801              LDR      r1,[r0,#0]
0002b4  f0214170          BIC      r1,r1,#0xf0000000
0002b8  6001              STR      r1,[r0,#0]
0002ba  6801              LDR      r1,[r0,#0]
0002bc  f0415140          ORR      r1,r1,#0x30000000
0002c0  6001              STR      r1,[r0,#0]
                  |L1.706|
;;;192            break;
;;;193        }
;;;194    }
0002c2  4770              BX       lr
;;;195    
                          ENDP

                  IIC_SCL PROC
;;;248    // 设置SCL电平
;;;249    static void IIC_SCL(const struct IIC_Type *IIC_Type_t, int n)
0002c4  6882              LDR      r2,[r0,#8]
;;;250    {
;;;251        if (n == 1)
;;;252        {
;;;253            // 设置SCL为高电平
;;;254            GPIO_SetBits(IIC_Type_t->GPIOx_SCL, IIC_Type_t->GPIO_SCL);
0002c6  6800              LDR      r0,[r0,#0]
0002c8  2901              CMP      r1,#1                 ;251
;;;255        }
;;;256        else
;;;257        {
;;;258            // 设置SCL为低电平
;;;259            GPIO_ResetBits(IIC_Type_t->GPIOx_SCL, IIC_Type_t->GPIO_SCL);
0002ca  b291              UXTH     r1,r2
0002cc  d001              BEQ      |L1.722|
0002ce  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.722|
0002d2  f7ffbffe          B.W      GPIO_SetBits
;;;260        }
;;;261    }
;;;262    
                          ENDP

                  IIC_SDA PROC
;;;263    // 设置SDA电平
;;;264    static void IIC_SDA(const struct IIC_Type *IIC_Type_t, int n)
0002d6  68c2              LDR      r2,[r0,#0xc]
;;;265    {
;;;266        if (n == 1)
;;;267        {
;;;268            // 设置SDA为高电平
;;;269            GPIO_SetBits(IIC_Type_t->GPIOx_SDA, IIC_Type_t->GPIO_SDA);
0002d8  6840              LDR      r0,[r0,#4]
0002da  2901              CMP      r1,#1                 ;266
;;;270        }
;;;271        else
;;;272        {
;;;273            // 设置SDA为低电平
;;;274            GPIO_ResetBits(IIC_Type_t->GPIOx_SDA, IIC_Type_t->GPIO_SDA);
0002dc  b291              UXTH     r1,r2
0002de  d001              BEQ      |L1.740|
0002e0  f7ffbffe          B.W      GPIO_ResetBits
                  |L1.740|
0002e4  f7ffbffe          B.W      GPIO_SetBits
;;;275        }
;;;276    }
;;;277    
                          ENDP

                  READ_SDA PROC
;;;278    // 读取SDA电平
;;;279    static uint8_t READ_SDA(const struct IIC_Type *IIC_Type_t)
0002e8  6841              LDR      r1,[r0,#4]
;;;280    {
;;;281        // return GPIO_ReadInputDataBit(IIC_Type_t->GPIOx_SDA, IIC_Type_t->GPIO_SDA); // 读取SDA电平
;;;282        /* 野火 */
;;;283        return ((IIC_Type_t->GPIOx_SDA->IDR & IIC_Type_t->GPIO_SDA) != 0);
0002ea  6889              LDR      r1,[r1,#8]
0002ec  68c0              LDR      r0,[r0,#0xc]
0002ee  4201              TST      r1,r0
0002f0  d001              BEQ      |L1.758|
0002f2  2001              MOVS     r0,#1
;;;284    }
0002f4  4770              BX       lr
                  |L1.758|
0002f6  2000              MOVS     r0,#0                 ;283
0002f8  4770              BX       lr
;;;285    
                          ENDP

0002fa  0000              DCW      0x0000
                  |L1.764|
                          DCD      0x40010800
                  |L1.768|
                          DCD      0x40010c00
                  |L1.772|
                          DCD      0x40011000
                  |L1.776|
                          DCD      0x40011400
                  |L1.780|
                          DCD      0x40011800
                  |L1.784|
                          DCD      IIC_Init_t
                  |L1.788|
                          DCD      IIC_Start_t
                  |L1.792|
                          DCD      IIC_Stop_t
                  |L1.796|
                          DCD      IIC_Wait_Ack_t
                  |L1.800|
                          DCD      IIC_Ack_t
                  |L1.804|
                          DCD      IIC_NAck_t
                  |L1.808|
                          DCD      IIC_Send_Byte_t
                  |L1.812|
                          DCD      IIC_Read_Byte_t
