; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_delay.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_delay.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_delay.crf ..\..\BSP\bsp_delay.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  delay_init PROC
;;;9      // SYSCLK:系统时钟频率
;;;10     void delay_init()
000000  4824              LDR      r0,|L1.148|
;;;11     {
;;;12     	//	u32 reload;
;;;13     	//	HAL_SYSTICK_CLKSourceConfig(SYSTICK_CLKSOURCE_HCLK);//选择外部时钟  HCLK
;;;14     	//	fac_us=SystemCoreClock/1000000;				//不论是否使用OS,fac_us都需要使用
;;;15     	//	reload=SystemCoreClock/1000000;				//每秒钟的计数次数 单位为M
;;;16     	//	reload*=1000000/configTICK_RATE_HZ;			//根据configTICK_RATE_HZ设定溢出时间
;;;17     	//												//reload为24位寄存器,最大值:16777216,在72M下,约合0.233s左右
;;;18     	//	fac_ms=1000/configTICK_RATE_HZ;				//代表OS可以延时的最少单位
;;;19     	//	SysTick->CTRL|=SysTick_CTRL_TICKINT_Msk;   	//开启SYSTICK中断
;;;20     	//	SysTick->LOAD=reload; 						//每1/configTICK_RATE_HZ秒中断一次
;;;21     	//	SysTick->CTRL|=SysTick_CTRL_ENABLE_Msk;   	//开启SYSTICK
;;;22     
;;;23     	fac_us = SystemCoreClock / 1000000;
000002  4925              LDR      r1,|L1.152|
000004  6800              LDR      r0,[r0,#0]  ; SystemCoreClock
000006  fbb0f2f1          UDIV     r2,r0,r1
00000a  4924              LDR      r1,|L1.156|
00000c  700a              STRB     r2,[r1,#0]
;;;24     	fac_ms = SystemCoreClock / 1000;
00000e  f44f727a          MOV      r2,#0x3e8
000012  fbb0f0f2          UDIV     r0,r0,r2
000016  8048              STRH     r0,[r1,#2]
;;;25     
;;;26     	// LOG_I("DELAY Init Success\r\n");
;;;27     }
000018  4770              BX       lr
;;;28     
                          ENDP

                  delay_us PROC
;;;31     // nus:0~204522252(最大值即2^32/fac_us@fac_us=168)
;;;32     void delay_us(u32 nus)
00001a  b570              PUSH     {r4-r6,lr}
;;;33     {
;;;34     	uint32_t ticks = 0;
;;;35     	uint32_t told = 0;
;;;36     	uint32_t tnow = 0;
;;;37     	uint32_t tcnt = 0;
;;;38     	uint32_t reload = 0;
;;;39     	reload = SysTick->LOAD; // LOAD的值
00001c  f04f25e0          MOV      r5,#0xe000e000
000020  2100              MOVS     r1,#0                 ;37
000022  696c              LDR      r4,[r5,#0x14]
;;;40     	ticks = nus * fac_us;	// 需要的节拍数
000024  4a1d              LDR      r2,|L1.156|
;;;41     	told = SysTick->VAL;	// 刚进入时的计数器值
000026  69ab              LDR      r3,[r5,#0x18]
000028  7812              LDRB     r2,[r2,#0]            ;40  ; fac_us
00002a  4350              MULS     r0,r2,r0              ;40
                  |L1.44|
;;;42     	while (1)
;;;43     	{
;;;44     		tnow = SysTick->VAL;
00002c  69aa              LDR      r2,[r5,#0x18]
;;;45     		if (tnow != told)
00002e  429a              CMP      r2,r3
000030  d0fc              BEQ      |L1.44|
;;;46     		{
;;;47     			if (tnow < told) // 这里注意一下SYSTICK是一个递减的计数器就可以了.
000032  d202              BCS      |L1.58|
;;;48     			{
;;;49     				tcnt += told - tnow;
000034  eba30302          SUB      r3,r3,r2
000038  e002              B        |L1.64|
                  |L1.58|
;;;50     			}
;;;51     			else
;;;52     			{
;;;53     				tcnt += reload - tnow + told;
00003a  eba40602          SUB      r6,r4,r2
00003e  4433              ADD      r3,r3,r6
                  |L1.64|
000040  4419              ADD      r1,r1,r3
;;;54     			}
;;;55     			told = tnow;
000042  4613              MOV      r3,r2
;;;56     			if (tcnt >= ticks) // 时间超过/等于要延迟的时间,则退出.
000044  4281              CMP      r1,r0
000046  d3f1              BCC      |L1.44|
;;;57     			{
;;;58     				break;
;;;59     			}
;;;60     		}
;;;61     	}
;;;62     }
000048  bd70              POP      {r4-r6,pc}
;;;63     
                          ENDP

                  delay_ms PROC
;;;64     void delay_ms(u32 nms)
00004a  b570              PUSH     {r4-r6,lr}
;;;65     {
;;;66     	uint32_t ticks = 0;
;;;67     	uint32_t told = 0;
;;;68     	uint32_t tnow = 0;
;;;69     	uint32_t tcnt = 0;
;;;70     	uint32_t reload = 0;
;;;71     	reload = SysTick->LOAD;
00004c  f04f25e0          MOV      r5,#0xe000e000
000050  2100              MOVS     r1,#0                 ;69
000052  696c              LDR      r4,[r5,#0x14]
;;;72     	ticks = nms * fac_ms;
000054  4a11              LDR      r2,|L1.156|
;;;73     	told = SysTick->VAL;
000056  69ab              LDR      r3,[r5,#0x18]
000058  8852              LDRH     r2,[r2,#2]            ;72  ; fac_ms
00005a  4350              MULS     r0,r2,r0              ;72
                  |L1.92|
;;;74     	while (1)
;;;75     	{
;;;76     		tnow = SysTick->VAL;
00005c  69aa              LDR      r2,[r5,#0x18]
;;;77     		if (tnow != told)
00005e  429a              CMP      r2,r3
000060  d0fc              BEQ      |L1.92|
;;;78     		{
;;;79     			if (tnow < told)
000062  d202              BCS      |L1.106|
;;;80     			{
;;;81     				tcnt += told - tnow;
000064  eba30302          SUB      r3,r3,r2
000068  e002              B        |L1.112|
                  |L1.106|
;;;82     			}
;;;83     			else
;;;84     			{
;;;85     				tcnt += reload - tnow + told;
00006a  eba40602          SUB      r6,r4,r2
00006e  4433              ADD      r3,r3,r6
                  |L1.112|
000070  4419              ADD      r1,r1,r3
;;;86     			}
;;;87     			told = tnow;
000072  4613              MOV      r3,r2
;;;88     			if (tcnt >= ticks)
000074  4281              CMP      r1,r0
000076  d3f1              BCC      |L1.92|
;;;89     			{
;;;90     				break;
;;;91     			}
;;;92     		}
;;;93     	}
;;;94     }
000078  bd70              POP      {r4-r6,pc}
;;;95     
                          ENDP

                  delay_xms PROC
;;;113    // nms:要延时的ms数
;;;114    void delay_xms(u32 nms)
00007a  b570              PUSH     {r4-r6,lr}
;;;115    {
00007c  4605              MOV      r5,r0
;;;116    	u32 i;
;;;117    	for (i = 0; i < nms; i++)
00007e  2400              MOVS     r4,#0
;;;118    		delay_us(1000);
000080  f44f767a          MOV      r6,#0x3e8
000084  e003              B        |L1.142|
                  |L1.134|
000086  4630              MOV      r0,r6
000088  f7fffffe          BL       delay_us
00008c  1c64              ADDS     r4,r4,#1
                  |L1.142|
00008e  42ac              CMP      r4,r5                 ;117
000090  d3f9              BCC      |L1.134|
;;;119    }
000092  bd70              POP      {r4-r6,pc}
                          ENDP

                  |L1.148|
                          DCD      SystemCoreClock
                  |L1.152|
                          DCD      0x000f4240
                  |L1.156|
                          DCD      ||.data||

                          AREA ||.data||, DATA, ALIGN=1

                  fac_us
000000  0000              DCB      0x00,0x00
                  fac_ms
000002  0000              DCW      0x0000
