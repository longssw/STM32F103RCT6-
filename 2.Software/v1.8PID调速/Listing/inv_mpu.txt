; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\inv_mpu.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\inv_mpu.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\inv_mpu.crf ..\..\BSP\eMPL\inv_mpu.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_pre_padding
                          REQUIRE _printf_percent
                          REQUIRE _printf_flags
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_x
                          REQUIRE _printf_longlong_hex
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  set_int_enable PROC
;;;711     */
;;;712    static int set_int_enable(unsigned char enable)
000000  b5f8              PUSH     {r3-r7,lr}
;;;713    {
;;;714        unsigned char tmp;
;;;715    
;;;716        if (st.chip_cfg.dmp_on) {
000002  4cfe              LDR      r4,|L1.1020|
000004  2300              MOVS     r3,#0
000006  4622              MOV      r2,r4
000008  f8946024          LDRB     r6,[r4,#0x24]  ; st
00000c  e9d21200          LDRD     r1,r2,[r2,#0]
;;;717            if (enable)
;;;718                tmp = BIT_DMP_INT_EN;
;;;719            else
;;;720                tmp = 0x00;
;;;721            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;722                return -1;
000010  1e5d              SUBS     r5,r3,#1
000012  b156              CBZ      r6,|L1.42|
000014  b190              CBZ      r0,|L1.60|
000016  2002              MOVS     r0,#2                 ;718
000018  e00d              B        |L1.54|
                  |L1.26|
00001a  7810              LDRB     r0,[r2,#0]            ;721
00001c  7bc9              LDRB     r1,[r1,#0xf]          ;721
00001e  466b              MOV      r3,sp                 ;721
000020  2201              MOVS     r2,#1                 ;721
000022  f7fffffe          BL       dmp_iic_write
000026  b960              CBNZ     r0,|L1.66|
000028  e00d              B        |L1.70|
                  |L1.42|
;;;723            st.chip_cfg.int_enable = tmp;
;;;724        } else {
;;;725            if (!st.chip_cfg.sensors)
00002a  7aa6              LDRB     r6,[r4,#0xa]  ; st
00002c  b14e              CBZ      r6,|L1.66|
;;;726                return -1;
;;;727            if (enable && st.chip_cfg.int_enable)
00002e  b128              CBZ      r0,|L1.60|
000030  7c60              LDRB     r0,[r4,#0x11]  ; st
000032  b958              CBNZ     r0,|L1.76|
;;;728                return 0;
;;;729            if (enable)
;;;730                tmp = BIT_DATA_RDY_EN;
000034  2001              MOVS     r0,#1
                  |L1.54|
000036  f88d0000          STRB     r0,[sp,#0]
00003a  e7ee              B        |L1.26|
                  |L1.60|
;;;731            else
;;;732                tmp = 0x00;
00003c  f88d3000          STRB     r3,[sp,#0]
000040  e7eb              B        |L1.26|
                  |L1.66|
;;;733            if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &tmp))
;;;734                return -1;
000042  4628              MOV      r0,r5
;;;735            st.chip_cfg.int_enable = tmp;
;;;736        }
;;;737        return 0;
;;;738    }
000044  bdf8              POP      {r3-r7,pc}
                  |L1.70|
000046  f89d0000          LDRB     r0,[sp,#0]            ;735
00004a  7460              STRB     r0,[r4,#0x11]         ;735
                  |L1.76|
00004c  2000              MOVS     r0,#0                 ;737
00004e  bdf8              POP      {r3-r7,pc}
;;;739    
                          ENDP

                  mpu_reg_dump PROC
;;;743     */
;;;744    int mpu_reg_dump(void)
000050  b538              PUSH     {r3-r5,lr}
;;;745    {
;;;746        unsigned char ii;
;;;747        unsigned char data;
;;;748    
;;;749        for (ii = 0; ii < st.hw->num_reg; ii++) {
000052  2400              MOVS     r4,#0
;;;750            if (ii == st.reg->fifo_r_w || ii == st.reg->mem_r_w)
000054  4de9              LDR      r5,|L1.1020|
000056  e018              B        |L1.138|
                  |L1.88|
000058  6828              LDR      r0,[r5,#0]  ; st
00005a  7ac2              LDRB     r2,[r0,#0xb]
00005c  42a2              CMP      r2,r4
00005e  d012              BEQ      |L1.134|
000060  7d40              LDRB     r0,[r0,#0x15]
000062  42a0              CMP      r0,r4
000064  d00f              BEQ      |L1.134|
;;;751                continue;
;;;752            if (i2c_read(st.hw->addr, ii, 1, &data))
000066  7808              LDRB     r0,[r1,#0]
000068  466b              MOV      r3,sp
00006a  2201              MOVS     r2,#1
00006c  4621              MOV      r1,r4
00006e  f7fffffe          BL       dmp_iic_read
000072  b110              CBZ      r0,|L1.122|
;;;753                return -1;
000074  f04f30ff          MOV      r0,#0xffffffff
;;;754            log_i("%#5x: %#5x\r\n", ii, data);
;;;755        }
;;;756        return 0;
;;;757    }
000078  bd38              POP      {r3-r5,pc}
                  |L1.122|
00007a  f89d2000          LDRB     r2,[sp,#0]            ;754
00007e  4621              MOV      r1,r4                 ;754
000080  a0df              ADR      r0,|L1.1024|
000082  f7fffffe          BL       __2printf
                  |L1.134|
000086  1c64              ADDS     r4,r4,#1              ;754
000088  b2e4              UXTB     r4,r4                 ;749
                  |L1.138|
00008a  6869              LDR      r1,[r5,#4]            ;749  ; st
00008c  7908              LDRB     r0,[r1,#4]            ;749
00008e  42a0              CMP      r0,r4                 ;749
000090  d8e2              BHI      |L1.88|
000092  2000              MOVS     r0,#0                 ;756
000094  bd38              POP      {r3-r5,pc}
;;;758    
                          ENDP

                  mpu_read_reg PROC
;;;765     */
;;;766    int mpu_read_reg(unsigned char reg, unsigned char *data)
000096  4ad9              LDR      r2,|L1.1020|
;;;767    {
000098  b430              PUSH     {r4,r5}
00009a  460b              MOV      r3,r1
;;;768        if (reg == st.reg->fifo_r_w || reg == st.reg->mem_r_w)
00009c  6811              LDR      r1,[r2,#0]  ; st
;;;769            return -1;
00009e  f04f34ff          MOV      r4,#0xffffffff
0000a2  7acd              LDRB     r5,[r1,#0xb]          ;768
0000a4  4285              CMP      r5,r0                 ;768
0000a6  d006              BEQ      |L1.182|
0000a8  7d49              LDRB     r1,[r1,#0x15]         ;768
0000aa  4281              CMP      r1,r0                 ;768
0000ac  d003              BEQ      |L1.182|
;;;770        if (reg >= st.hw->num_reg)
0000ae  6851              LDR      r1,[r2,#4]  ; st
0000b0  790a              LDRB     r2,[r1,#4]
0000b2  4282              CMP      r2,r0
0000b4  d802              BHI      |L1.188|
                  |L1.182|
;;;771            return -1;
0000b6  4620              MOV      r0,r4
;;;772        return i2c_read(st.hw->addr, reg, 1, data);
;;;773    }
0000b8  bc30              POP      {r4,r5}
0000ba  4770              BX       lr
                  |L1.188|
0000bc  780c              LDRB     r4,[r1,#0]            ;772
0000be  4601              MOV      r1,r0                 ;772
0000c0  4620              MOV      r0,r4                 ;772
0000c2  bc30              POP      {r4,r5}               ;772
0000c4  2201              MOVS     r2,#1                 ;772
0000c6  f7ffbffe          B.W      dmp_iic_read
;;;774    
                          ENDP

                  mpu_set_int_latched PROC
;;;1909    */
;;;1910   int mpu_set_int_latched(unsigned char enable)
0000ca  b538              PUSH     {r3-r5,lr}
;;;1911   {
;;;1912       unsigned char tmp;
;;;1913       if (st.chip_cfg.latched_int == enable)
0000cc  4dcb              LDR      r5,|L1.1020|
0000ce  4604              MOV      r4,r0                 ;1911
0000d0  f8950023          LDRB     r0,[r5,#0x23]  ; st
0000d4  42a0              CMP      r0,r4
0000d6  d101              BNE      |L1.220|
                  |L1.216|
;;;1914           return 0;
0000d8  2000              MOVS     r0,#0
;;;1915   
;;;1916       if (enable)
;;;1917           tmp = BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1918       else
;;;1919           tmp = 0;
;;;1920       if (st.chip_cfg.bypass_mode)
;;;1921           tmp |= BIT_BYPASS_EN;
;;;1922       if (st.chip_cfg.active_low_int)
;;;1923           tmp |= BIT_ACTL;
;;;1924       if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1925           return -1;
;;;1926       st.chip_cfg.latched_int = enable;
;;;1927       return 0;
;;;1928   }
0000da  bd38              POP      {r3-r5,pc}
                  |L1.220|
0000dc  b10c              CBZ      r4,|L1.226|
0000de  2030              MOVS     r0,#0x30              ;1917
0000e0  e000              B        |L1.228|
                  |L1.226|
0000e2  2000              MOVS     r0,#0                 ;1919
                  |L1.228|
0000e4  f88d0000          STRB     r0,[sp,#0]            ;1919
0000e8  7ca8              LDRB     r0,[r5,#0x12]         ;1920  ; st
0000ea  b128              CBZ      r0,|L1.248|
0000ec  f89d0000          LDRB     r0,[sp,#0]            ;1921
0000f0  f0400002          ORR      r0,r0,#2              ;1921
0000f4  f88d0000          STRB     r0,[sp,#0]            ;1921
                  |L1.248|
0000f8  f8950022          LDRB     r0,[r5,#0x22]         ;1922  ; st
0000fc  b128              CBZ      r0,|L1.266|
0000fe  f89d0000          LDRB     r0,[sp,#0]            ;1923
000102  f0400080          ORR      r0,r0,#0x80           ;1923
000106  f88d0000          STRB     r0,[sp,#0]            ;1923
                  |L1.266|
00010a  6828              LDR      r0,[r5,#0]            ;1924  ; st
00010c  466b              MOV      r3,sp                 ;1924
00010e  2201              MOVS     r2,#1                 ;1924
000110  7d01              LDRB     r1,[r0,#0x14]         ;1924
000112  6868              LDR      r0,[r5,#4]            ;1924  ; st
000114  7800              LDRB     r0,[r0,#0]            ;1924
000116  f7fffffe          BL       dmp_iic_write
00011a  b110              CBZ      r0,|L1.290|
00011c  f04f30ff          MOV      r0,#0xffffffff        ;1925
000120  bd38              POP      {r3-r5,pc}
                  |L1.290|
000122  f8854023          STRB     r4,[r5,#0x23]         ;1926
000126  e7d7              B        |L1.216|
;;;1929   
                          ENDP

                  mpu_set_sensors PROC
;;;1622    */
;;;1623   int mpu_set_sensors(unsigned char sensors)
000128  b5f8              PUSH     {r3-r7,lr}
;;;1624   {
00012a  4604              MOV      r4,r0
;;;1625       unsigned char data;
;;;1626   #ifdef AK89xx_SECONDARY
;;;1627       unsigned char user_ctrl;
;;;1628   #endif
;;;1629   
;;;1630       if (sensors & INV_XYZ_GYRO)
00012c  f0100f70          TST      r0,#0x70
000130  f04f0600          MOV      r6,#0
000134  d001              BEQ      |L1.314|
;;;1631           data = INV_CLK_PLL;
000136  2001              MOVS     r0,#1
000138  e004              B        |L1.324|
                  |L1.314|
;;;1632       else if (sensors)
00013a  b114              CBZ      r4,|L1.322|
;;;1633           data = 0;
00013c  f88d6000          STRB     r6,[sp,#0]
000140  e002              B        |L1.328|
                  |L1.322|
;;;1634       else
;;;1635           data = BIT_SLEEP;
000142  2040              MOVS     r0,#0x40
                  |L1.324|
000144  f88d0000          STRB     r0,[sp,#0]
                  |L1.328|
;;;1636       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, &data)) {
000148  4dac              LDR      r5,|L1.1020|
00014a  466b              MOV      r3,sp
00014c  2201              MOVS     r2,#1
00014e  6828              LDR      r0,[r5,#0]  ; st
000150  7c81              LDRB     r1,[r0,#0x12]
000152  6868              LDR      r0,[r5,#4]  ; st
000154  7800              LDRB     r0,[r0,#0]
000156  f7fffffe          BL       dmp_iic_write
;;;1637           st.chip_cfg.sensors = 0;
;;;1638           return -1;
00015a  f04f37ff          MOV      r7,#0xffffffff
00015e  bb60              CBNZ     r0,|L1.442|
;;;1639       }
;;;1640       st.chip_cfg.clk_src = data & ~BIT_SLEEP;
000160  f89d0000          LDRB     r0,[sp,#0]
000164  f0200040          BIC      r0,r0,#0x40
000168  7328              STRB     r0,[r5,#0xc]
;;;1641   
;;;1642       data = 0;
00016a  f88d6000          STRB     r6,[sp,#0]
;;;1643       if (!(sensors & INV_X_GYRO))
00016e  0660              LSLS     r0,r4,#25
000170  d402              BMI      |L1.376|
;;;1644           data |= BIT_STBY_XG;
000172  2004              MOVS     r0,#4
000174  f88d0000          STRB     r0,[sp,#0]
                  |L1.376|
;;;1645       if (!(sensors & INV_Y_GYRO))
000178  06a0              LSLS     r0,r4,#26
00017a  d405              BMI      |L1.392|
;;;1646           data |= BIT_STBY_YG;
00017c  f89d0000          LDRB     r0,[sp,#0]
000180  f0400002          ORR      r0,r0,#2
000184  f88d0000          STRB     r0,[sp,#0]
                  |L1.392|
;;;1647       if (!(sensors & INV_Z_GYRO))
000188  06e0              LSLS     r0,r4,#27
00018a  d405              BMI      |L1.408|
;;;1648           data |= BIT_STBY_ZG;
00018c  f89d0000          LDRB     r0,[sp,#0]
000190  f0400001          ORR      r0,r0,#1
000194  f88d0000          STRB     r0,[sp,#0]
                  |L1.408|
;;;1649       if (!(sensors & INV_XYZ_ACCEL))
000198  0720              LSLS     r0,r4,#28
00019a  d405              BMI      |L1.424|
;;;1650           data |= BIT_STBY_XYZA;
00019c  f89d0000          LDRB     r0,[sp,#0]
0001a0  f0400038          ORR      r0,r0,#0x38
0001a4  f88d0000          STRB     r0,[sp,#0]
                  |L1.424|
;;;1651       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_2, 1, &data)) {
0001a8  6828              LDR      r0,[r5,#0]  ; st
0001aa  466b              MOV      r3,sp
0001ac  2201              MOVS     r2,#1
0001ae  7cc1              LDRB     r1,[r0,#0x13]
0001b0  6868              LDR      r0,[r5,#4]  ; st
0001b2  7800              LDRB     r0,[r0,#0]
0001b4  f7fffffe          BL       dmp_iic_write
0001b8  b110              CBZ      r0,|L1.448|
                  |L1.442|
;;;1652           st.chip_cfg.sensors = 0;
0001ba  72ae              STRB     r6,[r5,#0xa]
;;;1653           return -1;
0001bc  4638              MOV      r0,r7
;;;1654       }
;;;1655   
;;;1656       if (sensors && (sensors != INV_XYZ_ACCEL))
;;;1657           /* Latched interrupts only used in LP accel mode. */
;;;1658           mpu_set_int_latched(0);
;;;1659   
;;;1660   #ifdef AK89xx_SECONDARY
;;;1661   #ifdef AK89xx_BYPASS
;;;1662       if (sensors & INV_XYZ_COMPASS)
;;;1663           mpu_set_bypass(1);
;;;1664       else
;;;1665           mpu_set_bypass(0);
;;;1666   #else
;;;1667       if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1668           return -1;
;;;1669       /* Handle AKM power management. */
;;;1670       if (sensors & INV_XYZ_COMPASS) {
;;;1671           data = AKM_SINGLE_MEASUREMENT;
;;;1672           user_ctrl |= BIT_AUX_IF_EN;
;;;1673       } else {
;;;1674           data = AKM_POWER_DOWN;
;;;1675           user_ctrl &= ~BIT_AUX_IF_EN;
;;;1676       }
;;;1677       if (st.chip_cfg.dmp_on)
;;;1678           user_ctrl |= BIT_DMP_EN;
;;;1679       else
;;;1680           user_ctrl &= ~BIT_DMP_EN;
;;;1681       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, &data))
;;;1682           return -1;
;;;1683       /* Enable/disable I2C master mode. */
;;;1684       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &user_ctrl))
;;;1685           return -1;
;;;1686   #endif
;;;1687   #endif
;;;1688   
;;;1689       st.chip_cfg.sensors = sensors;
;;;1690       st.chip_cfg.lp_accel_mode = 0;
;;;1691       delay_ms(50);
;;;1692       return 0;
;;;1693   }
0001be  bdf8              POP      {r3-r7,pc}
                  |L1.448|
0001c0  b124              CBZ      r4,|L1.460|
0001c2  2c08              CMP      r4,#8                 ;1656
0001c4  d002              BEQ      |L1.460|
0001c6  2000              MOVS     r0,#0                 ;1658
0001c8  f7fffffe          BL       mpu_set_int_latched
                  |L1.460|
0001cc  72ac              STRB     r4,[r5,#0xa]          ;1689
0001ce  752e              STRB     r6,[r5,#0x14]         ;1690
0001d0  2032              MOVS     r0,#0x32              ;1691
0001d2  f7fffffe          BL       vTaskDelay
0001d6  2000              MOVS     r0,#0                 ;1692
0001d8  bdf8              POP      {r3-r7,pc}
;;;1694   
                          ENDP

                  mpu_set_bypass PROC
;;;1847    */
;;;1848   int mpu_set_bypass(unsigned char bypass_on)
0001da  b5f8              PUSH     {r3-r7,lr}
;;;1849   {
;;;1850       unsigned char tmp;
;;;1851   
;;;1852       if (st.chip_cfg.bypass_mode == bypass_on)
0001dc  4d87              LDR      r5,|L1.1020|
0001de  4604              MOV      r4,r0                 ;1849
0001e0  7ca8              LDRB     r0,[r5,#0x12]  ; st
0001e2  42a0              CMP      r0,r4
0001e4  d101              BNE      |L1.490|
                  |L1.486|
;;;1853           return 0;
0001e6  2000              MOVS     r0,#0
;;;1854   
;;;1855       if (bypass_on) {
;;;1856           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1857               return -1;
;;;1858           tmp &= ~BIT_AUX_IF_EN;
;;;1859           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1860               return -1;
;;;1861           delay_ms(3);
;;;1862           tmp = BIT_BYPASS_EN;
;;;1863           if (st.chip_cfg.active_low_int)
;;;1864               tmp |= BIT_ACTL;
;;;1865           if (st.chip_cfg.latched_int)
;;;1866               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1867           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1868               return -1;
;;;1869       } else {
;;;1870           /* Enable I2C master mode if compass is being used. */
;;;1871           if (i2c_read(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1872               return -1;
;;;1873           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
;;;1874               tmp |= BIT_AUX_IF_EN;
;;;1875           else
;;;1876               tmp &= ~BIT_AUX_IF_EN;
;;;1877           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &tmp))
;;;1878               return -1;
;;;1879           delay_ms(3);
;;;1880           if (st.chip_cfg.active_low_int)
;;;1881               tmp = BIT_ACTL;
;;;1882           else
;;;1883               tmp = 0;
;;;1884           if (st.chip_cfg.latched_int)
;;;1885               tmp |= BIT_LATCH_EN | BIT_ANY_RD_CLR;
;;;1886           if (i2c_write(st.hw->addr, st.reg->int_pin_cfg, 1, &tmp))
;;;1887               return -1;
;;;1888       }
;;;1889       st.chip_cfg.bypass_mode = bypass_on;
;;;1890       return 0;
;;;1891   }
0001e8  bdf8              POP      {r3-r7,pc}
                  |L1.490|
0001ea  4884              LDR      r0,|L1.1020|
0001ec  f04f36ff          MOV      r6,#0xffffffff        ;1857
0001f0  466b              MOV      r3,sp                 ;1871
0001f2  e9d01000          LDRD     r1,r0,[r0,#0]         ;1852
0001f6  f04f0201          MOV      r2,#1                 ;1871
0001fa  7909              LDRB     r1,[r1,#4]            ;1871
0001fc  7800              LDRB     r0,[r0,#0]            ;1871
0001fe  b334              CBZ      r4,|L1.590|
000200  f7fffffe          BL       dmp_iic_read
000204  bbd8              CBNZ     r0,|L1.638|
000206  f89d0000          LDRB     r0,[sp,#0]            ;1858
00020a  466b              MOV      r3,sp                 ;1859
00020c  f0200020          BIC      r0,r0,#0x20           ;1858
000210  f88d0000          STRB     r0,[sp,#0]            ;1858
000214  6828              LDR      r0,[r5,#0]            ;1859  ; st
000216  2201              MOVS     r2,#1                 ;1859
000218  7901              LDRB     r1,[r0,#4]            ;1859
00021a  6868              LDR      r0,[r5,#4]            ;1859  ; st
00021c  7800              LDRB     r0,[r0,#0]            ;1859
00021e  f7fffffe          BL       dmp_iic_write
000222  bb60              CBNZ     r0,|L1.638|
000224  2003              MOVS     r0,#3                 ;1861
000226  f7fffffe          BL       vTaskDelay
00022a  2002              MOVS     r0,#2                 ;1862
00022c  f88d0000          STRB     r0,[sp,#0]            ;1862
000230  f8950022          LDRB     r0,[r5,#0x22]         ;1863  ; st
000234  b370              CBZ      r0,|L1.660|
000236  2082              MOVS     r0,#0x82              ;1864
000238  e02a              B        |L1.656|
                  |L1.570|
00023a  6828              LDR      r0,[r5,#0]            ;1867  ; st
00023c  466b              MOV      r3,sp                 ;1867
00023e  2201              MOVS     r2,#1                 ;1867
000240  7d01              LDRB     r1,[r0,#0x14]         ;1867
000242  6868              LDR      r0,[r5,#4]            ;1867  ; st
000244  7800              LDRB     r0,[r0,#0]            ;1867
000246  f7fffffe          BL       dmp_iic_write
00024a  b9c0              CBNZ     r0,|L1.638|
00024c  e02d              B        |L1.682|
                  |L1.590|
00024e  f7fffffe          BL       dmp_iic_read
000252  b9a0              CBNZ     r0,|L1.638|
000254  7aa8              LDRB     r0,[r5,#0xa]          ;1873  ; st
000256  07c0              LSLS     r0,r0,#31             ;1873
000258  f89d0000          LDRB     r0,[sp,#0]            ;1876
00025c  d002              BEQ      |L1.612|
00025e  f0400020          ORR      r0,r0,#0x20           ;1874
000262  e001              B        |L1.616|
                  |L1.612|
000264  f0200020          BIC      r0,r0,#0x20           ;1876
                  |L1.616|
000268  f88d0000          STRB     r0,[sp,#0]            ;1876
00026c  6828              LDR      r0,[r5,#0]            ;1877  ; st
00026e  466b              MOV      r3,sp                 ;1877
000270  2201              MOVS     r2,#1                 ;1877
000272  7901              LDRB     r1,[r0,#4]            ;1877
000274  6868              LDR      r0,[r5,#4]            ;1877  ; st
000276  7800              LDRB     r0,[r0,#0]            ;1877
000278  f7fffffe          BL       dmp_iic_write
00027c  b108              CBZ      r0,|L1.642|
                  |L1.638|
00027e  4630              MOV      r0,r6                 ;1887
000280  bdf8              POP      {r3-r7,pc}
                  |L1.642|
000282  2003              MOVS     r0,#3                 ;1879
000284  f7fffffe          BL       vTaskDelay
000288  f8950022          LDRB     r0,[r5,#0x22]         ;1880  ; st
00028c  b100              CBZ      r0,|L1.656|
00028e  2080              MOVS     r0,#0x80              ;1881
                  |L1.656|
000290  f88d0000          STRB     r0,[sp,#0]            ;1883
                  |L1.660|
000294  f8950023          LDRB     r0,[r5,#0x23]         ;1884  ; st
000298  2800              CMP      r0,#0                 ;1884
00029a  d0ce              BEQ      |L1.570|
00029c  f89d0000          LDRB     r0,[sp,#0]            ;1885
0002a0  f0400030          ORR      r0,r0,#0x30           ;1885
0002a4  f88d0000          STRB     r0,[sp,#0]            ;1885
0002a8  e7c7              B        |L1.570|
                  |L1.682|
0002aa  74ac              STRB     r4,[r5,#0x12]         ;1889
0002ac  e79b              B        |L1.486|
;;;1892   
                          ENDP

                  mpu_reset_fifo PROC
;;;1122    */
;;;1123   int mpu_reset_fifo(void)
0002ae  b5f8              PUSH     {r3-r7,lr}
;;;1124   {
;;;1125       unsigned char data;
;;;1126   
;;;1127       if (!(st.chip_cfg.sensors))
0002b0  4d52              LDR      r5,|L1.1020|
;;;1128           return -1;
0002b2  f04f36ff          MOV      r6,#0xffffffff
0002b6  7aa8              LDRB     r0,[r5,#0xa]          ;1127  ; st
0002b8  2800              CMP      r0,#0                 ;1127
0002ba  d07c              BEQ      |L1.950|
;;;1129   
;;;1130       data = 0;
0002bc  2400              MOVS     r4,#0
0002be  f88d4000          STRB     r4,[sp,#0]
;;;1131       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
0002c2  6828              LDR      r0,[r5,#0]  ; st
0002c4  466b              MOV      r3,sp
0002c6  2201              MOVS     r2,#1
0002c8  7bc1              LDRB     r1,[r0,#0xf]
0002ca  6868              LDR      r0,[r5,#4]  ; st
0002cc  7800              LDRB     r0,[r0,#0]
0002ce  f7fffffe          BL       dmp_iic_write
0002d2  2800              CMP      r0,#0
0002d4  d16f              BNE      |L1.950|
;;;1132           return -1;
;;;1133       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
0002d6  6828              LDR      r0,[r5,#0]  ; st
0002d8  466b              MOV      r3,sp
0002da  2201              MOVS     r2,#1
0002dc  7941              LDRB     r1,[r0,#5]
0002de  6868              LDR      r0,[r5,#4]  ; st
0002e0  7800              LDRB     r0,[r0,#0]
0002e2  f7fffffe          BL       dmp_iic_write
0002e6  2800              CMP      r0,#0
0002e8  d165              BNE      |L1.950|
;;;1134           return -1;
;;;1135       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
0002ea  6828              LDR      r0,[r5,#0]  ; st
0002ec  466b              MOV      r3,sp
0002ee  2201              MOVS     r2,#1
0002f0  7901              LDRB     r1,[r0,#4]
0002f2  6868              LDR      r0,[r5,#4]  ; st
0002f4  7800              LDRB     r0,[r0,#0]
0002f6  f7fffffe          BL       dmp_iic_write
0002fa  2800              CMP      r0,#0
0002fc  d15b              BNE      |L1.950|
;;;1136           return -1;
;;;1137   
;;;1138       if (st.chip_cfg.dmp_on) {
0002fe  f8950024          LDRB     r0,[r5,#0x24]  ; st
000302  b3e0              CBZ      r0,|L1.894|
;;;1139           data = BIT_FIFO_RST | BIT_DMP_RST;
000304  200c              MOVS     r0,#0xc
000306  f88d0000          STRB     r0,[sp,#0]
;;;1140           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
00030a  6828              LDR      r0,[r5,#0]  ; st
00030c  466b              MOV      r3,sp
00030e  2201              MOVS     r2,#1
000310  7901              LDRB     r1,[r0,#4]
000312  6868              LDR      r0,[r5,#4]  ; st
000314  7800              LDRB     r0,[r0,#0]
000316  f7fffffe          BL       dmp_iic_write
00031a  2800              CMP      r0,#0
00031c  d17d              BNE      |L1.1050|
;;;1141               return -1;
;;;1142           delay_ms(50);
00031e  2032              MOVS     r0,#0x32
000320  f7fffffe          BL       vTaskDelay
;;;1143           data = BIT_DMP_EN | BIT_FIFO_EN;
000324  20c0              MOVS     r0,#0xc0
000326  f88d0000          STRB     r0,[sp,#0]
;;;1144           if (st.chip_cfg.sensors & INV_XYZ_COMPASS)
00032a  7aa8              LDRB     r0,[r5,#0xa]  ; st
00032c  07c0              LSLS     r0,r0,#31
00032e  d002              BEQ      |L1.822|
;;;1145               data |= BIT_AUX_IF_EN;
000330  20e0              MOVS     r0,#0xe0
000332  f88d0000          STRB     r0,[sp,#0]
                  |L1.822|
;;;1146           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
000336  6828              LDR      r0,[r5,#0]  ; st
000338  466b              MOV      r3,sp
00033a  2201              MOVS     r2,#1
00033c  7901              LDRB     r1,[r0,#4]
00033e  6868              LDR      r0,[r5,#4]  ; st
000340  7800              LDRB     r0,[r0,#0]
000342  f7fffffe          BL       dmp_iic_write
000346  2800              CMP      r0,#0
000348  d167              BNE      |L1.1050|
;;;1147               return -1;
;;;1148           if (st.chip_cfg.int_enable)
00034a  7c68              LDRB     r0,[r5,#0x11]  ; st
00034c  b118              CBZ      r0,|L1.854|
;;;1149               data = BIT_DMP_INT_EN;
00034e  2002              MOVS     r0,#2
000350  f88d0000          STRB     r0,[sp,#0]
000354  e001              B        |L1.858|
                  |L1.854|
;;;1150           else
;;;1151               data = 0;
000356  f88d4000          STRB     r4,[sp,#0]
                  |L1.858|
;;;1152           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
00035a  6828              LDR      r0,[r5,#0]  ; st
00035c  466b              MOV      r3,sp
00035e  2201              MOVS     r2,#1
000360  7bc1              LDRB     r1,[r0,#0xf]
000362  6868              LDR      r0,[r5,#4]  ; st
000364  7800              LDRB     r0,[r0,#0]
000366  f7fffffe          BL       dmp_iic_write
00036a  bb20              CBNZ     r0,|L1.950|
;;;1153               return -1;
;;;1154           data = 0;
00036c  f88d4000          STRB     r4,[sp,#0]
;;;1155           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &data))
000370  6828              LDR      r0,[r5,#0]  ; st
000372  466b              MOV      r3,sp
000374  2201              MOVS     r2,#1
000376  7941              LDRB     r1,[r0,#5]
000378  6868              LDR      r0,[r5,#4]  ; st
00037a  7800              LDRB     r0,[r0,#0]
00037c  e03d              B        |L1.1018|
                  |L1.894|
00037e  e7ff              B        |L1.896|
                  |L1.896|
;;;1156               return -1;
;;;1157       } else {
;;;1158           data = BIT_FIFO_RST;
000380  2004              MOVS     r0,#4
000382  f88d0000          STRB     r0,[sp,#0]
;;;1159           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
000386  6828              LDR      r0,[r5,#0]  ; st
000388  466b              MOV      r3,sp
00038a  2201              MOVS     r2,#1
00038c  7901              LDRB     r1,[r0,#4]
00038e  6868              LDR      r0,[r5,#4]  ; st
000390  7800              LDRB     r0,[r0,#0]
000392  f7fffffe          BL       dmp_iic_write
000396  b970              CBNZ     r0,|L1.950|
;;;1160               return -1;
;;;1161           if (st.chip_cfg.bypass_mode || !(st.chip_cfg.sensors & INV_XYZ_COMPASS))
000398  7ca8              LDRB     r0,[r5,#0x12]  ; st
00039a  b988              CBNZ     r0,|L1.960|
00039c  7aa8              LDRB     r0,[r5,#0xa]  ; st
00039e  07c0              LSLS     r0,r0,#31
0003a0  d00e              BEQ      |L1.960|
;;;1162               data = BIT_FIFO_EN;
;;;1163           else
;;;1164               data = BIT_FIFO_EN | BIT_AUX_IF_EN;
0003a2  2060              MOVS     r0,#0x60
                  |L1.932|
0003a4  f88d0000          STRB     r0,[sp,#0]
;;;1165           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, &data))
0003a8  6828              LDR      r0,[r5,#0]  ; st
0003aa  466b              MOV      r3,sp
0003ac  2201              MOVS     r2,#1
0003ae  7901              LDRB     r1,[r0,#4]
0003b0  6868              LDR      r0,[r5,#4]  ; st
0003b2  7800              LDRB     r0,[r0,#0]
0003b4  e000              B        |L1.952|
                  |L1.950|
0003b6  e02b              B        |L1.1040|
                  |L1.952|
0003b8  f7fffffe          BL       dmp_iic_write
0003bc  bb40              CBNZ     r0,|L1.1040|
0003be  e001              B        |L1.964|
                  |L1.960|
0003c0  2040              MOVS     r0,#0x40              ;1162
0003c2  e7ef              B        |L1.932|
                  |L1.964|
;;;1166               return -1;
;;;1167           delay_ms(50);
0003c4  2032              MOVS     r0,#0x32
0003c6  f7fffffe          BL       vTaskDelay
;;;1168           if (st.chip_cfg.int_enable)
0003ca  7c68              LDRB     r0,[r5,#0x11]  ; st
0003cc  b118              CBZ      r0,|L1.982|
;;;1169               data = BIT_DATA_RDY_EN;
0003ce  2001              MOVS     r0,#1
0003d0  f88d0000          STRB     r0,[sp,#0]
0003d4  e001              B        |L1.986|
                  |L1.982|
;;;1170           else
;;;1171               data = 0;
0003d6  f88d4000          STRB     r4,[sp,#0]
                  |L1.986|
;;;1172           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, &data))
0003da  6828              LDR      r0,[r5,#0]  ; st
0003dc  466b              MOV      r3,sp
0003de  2201              MOVS     r2,#1
0003e0  7bc1              LDRB     r1,[r0,#0xf]
0003e2  6868              LDR      r0,[r5,#4]  ; st
0003e4  7800              LDRB     r0,[r0,#0]
0003e6  f7fffffe          BL       dmp_iic_write
0003ea  b988              CBNZ     r0,|L1.1040|
;;;1173               return -1;
;;;1174           if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, &st.chip_cfg.fifo_enable))
0003ec  6828              LDR      r0,[r5,#0]  ; st
0003ee  4b03              LDR      r3,|L1.1020|
0003f0  7941              LDRB     r1,[r0,#5]
0003f2  6868              LDR      r0,[r5,#4]  ; st
0003f4  3310              ADDS     r3,r3,#0x10
0003f6  2201              MOVS     r2,#1
0003f8  7800              LDRB     r0,[r0,#0]
                  |L1.1018|
0003fa  e00a              B        |L1.1042|
                  |L1.1020|
                          DCD      ||.data||
                  |L1.1024|
000400  25233578          DCB      "%#5x: %#5x\r\n",0
000404  3a202523
000408  35780d0a
00040c  00      
00040d  00                DCB      0
00040e  00                DCB      0
00040f  00                DCB      0
                  |L1.1040|
000410  e003              B        |L1.1050|
                  |L1.1042|
000412  f7fffffe          BL       dmp_iic_write
000416  2800              CMP      r0,#0                 ;1155
000418  d000              BEQ      |L1.1052|
                  |L1.1050|
;;;1175               return -1;
00041a  4630              MOV      r0,r6
                  |L1.1052|
;;;1176       }
;;;1177       return 0;
;;;1178   }
00041c  bdf8              POP      {r3-r7,pc}
;;;1179   
                          ENDP

                  mpu_configure_fifo PROC
;;;1561    */
;;;1562   int mpu_configure_fifo(unsigned char sensors)
00041e  e92d41f0          PUSH     {r4-r8,lr}
;;;1563   {
;;;1564       unsigned char prev;
;;;1565       int result = 0;
000422  2600              MOVS     r6,#0
;;;1566   
;;;1567       /* Compass data isn't going into the FIFO. Stop trying. */
;;;1568       sensors &= ~INV_XYZ_COMPASS;
000424  f0200401          BIC      r4,r0,#1
;;;1569   
;;;1570       if (st.chip_cfg.dmp_on)
000428  4dfe              LDR      r5,|L1.2084|
00042a  f8950024          LDRB     r0,[r5,#0x24]  ; st
00042e  b110              CBZ      r0,|L1.1078|
;;;1571           return 0;
000430  2000              MOVS     r0,#0
                  |L1.1074|
;;;1572       else {
;;;1573           if (!(st.chip_cfg.sensors))
;;;1574               return -1;
;;;1575           prev = st.chip_cfg.fifo_enable;
;;;1576           st.chip_cfg.fifo_enable = sensors & st.chip_cfg.sensors;
;;;1577           if (st.chip_cfg.fifo_enable != sensors)
;;;1578               /* You're not getting what you asked for. Some sensors are
;;;1579                * asleep.
;;;1580                */
;;;1581               result = -1;
;;;1582           else
;;;1583               result = 0;
;;;1584           if (sensors || st.chip_cfg.lp_accel_mode)
;;;1585               set_int_enable(1);
;;;1586           else
;;;1587               set_int_enable(0);
;;;1588           if (sensors) {
;;;1589               if (mpu_reset_fifo()) {
;;;1590                   st.chip_cfg.fifo_enable = prev;
;;;1591                   return -1;
;;;1592               }
;;;1593           }
;;;1594       }
;;;1595   
;;;1596       return result;
;;;1597   }
000432  e8bd81f0          POP      {r4-r8,pc}
                  |L1.1078|
000436  7aa8              LDRB     r0,[r5,#0xa]          ;1573  ; st
000438  f04f38ff          MOV      r8,#0xffffffff        ;1574
00043c  b138              CBZ      r0,|L1.1102|
00043e  4020              ANDS     r0,r0,r4              ;1576
000440  7c2f              LDRB     r7,[r5,#0x10]         ;1575  ; st
000442  7428              STRB     r0,[r5,#0x10]         ;1576
000444  42a0              CMP      r0,r4                 ;1577
000446  d000              BEQ      |L1.1098|
000448  4646              MOV      r6,r8                 ;1581
                  |L1.1098|
00044a  b924              CBNZ     r4,|L1.1110|
00044c  e001              B        |L1.1106|
                  |L1.1102|
00044e  4640              MOV      r0,r8                 ;1574
000450  e7ef              B        |L1.1074|
                  |L1.1106|
000452  7d28              LDRB     r0,[r5,#0x14]         ;1584  ; st
000454  b140              CBZ      r0,|L1.1128|
                  |L1.1110|
000456  2001              MOVS     r0,#1                 ;1585
000458  f7fffffe          BL       set_int_enable
00045c  b13c              CBZ      r4,|L1.1134|
00045e  f7fffffe          BL       mpu_reset_fifo
000462  b120              CBZ      r0,|L1.1134|
000464  742f              STRB     r7,[r5,#0x10]         ;1590
000466  e7f2              B        |L1.1102|
                  |L1.1128|
000468  2000              MOVS     r0,#0                 ;1587
00046a  f7fffffe          BL       set_int_enable
                  |L1.1134|
00046e  4630              MOV      r0,r6                 ;1596
000470  e7df              B        |L1.1074|
;;;1598   
                          ENDP

                  mpu_set_lpf PROC
;;;1349    */
;;;1350   int mpu_set_lpf(unsigned short lpf)
000472  b538              PUSH     {r3-r5,lr}
;;;1351   {
;;;1352       unsigned char data;
;;;1353   
;;;1354       if (!(st.chip_cfg.sensors))
000474  4ceb              LDR      r4,|L1.2084|
;;;1355           return -1;
000476  f04f35ff          MOV      r5,#0xffffffff
00047a  7aa1              LDRB     r1,[r4,#0xa]          ;1354  ; st
00047c  b331              CBZ      r1,|L1.1228|
;;;1356   
;;;1357       if (lpf >= 188)
00047e  28bc              CMP      r0,#0xbc
000480  d301              BCC      |L1.1158|
;;;1358           data = INV_FILTER_188HZ;
000482  2001              MOVS     r0,#1
000484  e010              B        |L1.1192|
                  |L1.1158|
;;;1359       else if (lpf >= 98)
000486  2862              CMP      r0,#0x62
000488  d301              BCC      |L1.1166|
;;;1360           data = INV_FILTER_98HZ;
00048a  2002              MOVS     r0,#2
00048c  e00c              B        |L1.1192|
                  |L1.1166|
;;;1361       else if (lpf >= 42)
00048e  282a              CMP      r0,#0x2a
000490  d301              BCC      |L1.1174|
;;;1362           data = INV_FILTER_42HZ;
000492  2003              MOVS     r0,#3
000494  e008              B        |L1.1192|
                  |L1.1174|
;;;1363       else if (lpf >= 20)
000496  2814              CMP      r0,#0x14
000498  d301              BCC      |L1.1182|
;;;1364           data = INV_FILTER_20HZ;
00049a  2004              MOVS     r0,#4
00049c  e004              B        |L1.1192|
                  |L1.1182|
;;;1365       else if (lpf >= 10)
00049e  280a              CMP      r0,#0xa
0004a0  d301              BCC      |L1.1190|
;;;1366           data = INV_FILTER_10HZ;
0004a2  2005              MOVS     r0,#5
0004a4  e000              B        |L1.1192|
                  |L1.1190|
;;;1367       else
;;;1368           data = INV_FILTER_5HZ;
0004a6  2006              MOVS     r0,#6
                  |L1.1192|
0004a8  f88d0000          STRB     r0,[sp,#0]            ;1366
;;;1369   
;;;1370       if (st.chip_cfg.lpf == data)
0004ac  7ae0              LDRB     r0,[r4,#0xb]  ; st
0004ae  f89d1000          LDRB     r1,[sp,#0]
0004b2  4288              CMP      r0,r1
0004b4  d101              BNE      |L1.1210|
                  |L1.1206|
;;;1371           return 0;
0004b6  2000              MOVS     r0,#0
;;;1372       if (i2c_write(st.hw->addr, st.reg->lpf, 1, &data))
;;;1373           return -1;
;;;1374       st.chip_cfg.lpf = data;
;;;1375       return 0;
;;;1376   }
0004b8  bd38              POP      {r3-r5,pc}
                  |L1.1210|
0004ba  6820              LDR      r0,[r4,#0]            ;1372  ; st
0004bc  466b              MOV      r3,sp                 ;1372
0004be  2201              MOVS     r2,#1                 ;1372
0004c0  7881              LDRB     r1,[r0,#2]            ;1372
0004c2  6860              LDR      r0,[r4,#4]            ;1372  ; st
0004c4  7800              LDRB     r0,[r0,#0]            ;1372
0004c6  f7fffffe          BL       dmp_iic_write
0004ca  b108              CBZ      r0,|L1.1232|
                  |L1.1228|
0004cc  4628              MOV      r0,r5                 ;1373
0004ce  bd38              POP      {r3-r5,pc}
                  |L1.1232|
0004d0  f89d0000          LDRB     r0,[sp,#0]            ;1374
0004d4  72e0              STRB     r0,[r4,#0xb]          ;1374
0004d6  e7ee              B        |L1.1206|
;;;1377   
                          ENDP

                  mpu_lp_accel_mode PROC
;;;918     */
;;;919    int mpu_lp_accel_mode(unsigned char rate)
0004d8  e92d43f8          PUSH     {r3-r9,lr}
;;;920    {
0004dc  4604              MOV      r4,r0
;;;921        unsigned char tmp[2];
;;;922    
;;;923        if (rate > 40)
;;;924            return -1;
0004de  f04f39ff          MOV      r9,#0xffffffff
0004e2  2828              CMP      r0,#0x28              ;923
0004e4  d844              BHI      |L1.1392|
;;;925    
;;;926        if (!rate) {
;;;927            mpu_set_int_latched(0);
;;;928            tmp[0] = 0;
;;;929            tmp[1] = BIT_STBY_XYZG;
0004e6  2707              MOVS     r7,#7
;;;930            if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
0004e8  4dce              LDR      r5,|L1.2084|
0004ea  2600              MOVS     r6,#0                 ;929
0004ec  b17c              CBZ      r4,|L1.1294|
;;;931                return -1;
;;;932            st.chip_cfg.lp_accel_mode = 0;
;;;933            return 0;
;;;934        }
;;;935        /* For LP accel, we automatically configure the hardware to produce latched
;;;936         * interrupts. In LP accel mode, the hardware cycles into sleep mode before
;;;937         * it gets a chance to deassert the interrupt pin; therefore, we shift this
;;;938         * responsibility over to the MCU.
;;;939         *
;;;940         * Any register read will clear the interrupt.
;;;941         */
;;;942        mpu_set_int_latched(1);
0004ee  2001              MOVS     r0,#1
0004f0  f7fffffe          BL       mpu_set_int_latched
;;;943    #if defined MPU6050
;;;944        tmp[0] = BIT_LPA_CYCLE;
0004f4  2020              MOVS     r0,#0x20
0004f6  f88d0000          STRB     r0,[sp,#0]
0004fa  f04f0801          MOV      r8,#1                 ;942
;;;945        if (rate == 1) {
0004fe  2c01              CMP      r4,#1
000500  d017              BEQ      |L1.1330|
;;;946            tmp[1] = INV_LPA_1_25HZ;
;;;947            mpu_set_lpf(5);
;;;948        } else if (rate <= 5) {
000502  2c05              CMP      r4,#5
000504  d818              BHI      |L1.1336|
;;;949            tmp[1] = INV_LPA_5HZ;
000506  f88d8001          STRB     r8,[sp,#1]
                  |L1.1290|
00050a  2005              MOVS     r0,#5                 ;947
00050c  e01f              B        |L1.1358|
                  |L1.1294|
00050e  2000              MOVS     r0,#0                 ;927
000510  f7fffffe          BL       mpu_set_int_latched
000514  f88d6000          STRB     r6,[sp,#0]            ;928
000518  f88d7001          STRB     r7,[sp,#1]            ;929
00051c  6828              LDR      r0,[r5,#0]            ;930  ; st
00051e  466b              MOV      r3,sp                 ;930
000520  2202              MOVS     r2,#2                 ;930
000522  7c81              LDRB     r1,[r0,#0x12]         ;930
000524  6868              LDR      r0,[r5,#4]            ;930  ; st
000526  7800              LDRB     r0,[r0,#0]            ;930
000528  f7fffffe          BL       dmp_iic_write
00052c  bb00              CBNZ     r0,|L1.1392|
00052e  752e              STRB     r6,[r5,#0x14]         ;932
000530  e029              B        |L1.1414|
                  |L1.1330|
000532  f88d6001          STRB     r6,[sp,#1]            ;946
000536  e7e8              B        |L1.1290|
                  |L1.1336|
;;;950            mpu_set_lpf(5);
;;;951        } else if (rate <= 20) {
000538  2c14              CMP      r4,#0x14
00053a  d804              BHI      |L1.1350|
;;;952            tmp[1] = INV_LPA_20HZ;
00053c  2002              MOVS     r0,#2
00053e  f88d0001          STRB     r0,[sp,#1]
;;;953            mpu_set_lpf(10);
000542  200a              MOVS     r0,#0xa
000544  e003              B        |L1.1358|
                  |L1.1350|
;;;954        } else {
;;;955            tmp[1] = INV_LPA_40HZ;
000546  2003              MOVS     r0,#3
000548  f88d0001          STRB     r0,[sp,#1]
;;;956            mpu_set_lpf(20);
00054c  2014              MOVS     r0,#0x14
                  |L1.1358|
00054e  f7fffffe          BL       mpu_set_lpf
;;;957        }
;;;958        tmp[1] = (tmp[1] << 6) | BIT_STBY_XYZG;
000552  f89d0001          LDRB     r0,[sp,#1]
;;;959        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, tmp))
000556  466b              MOV      r3,sp
000558  eb071080          ADD      r0,r7,r0,LSL #6       ;958
00055c  f88d0001          STRB     r0,[sp,#1]            ;958
000560  6828              LDR      r0,[r5,#0]  ; st
000562  2202              MOVS     r2,#2
000564  7c81              LDRB     r1,[r0,#0x12]
000566  6868              LDR      r0,[r5,#4]  ; st
000568  7800              LDRB     r0,[r0,#0]
00056a  f7fffffe          BL       dmp_iic_write
00056e  b110              CBZ      r0,|L1.1398|
                  |L1.1392|
;;;960            return -1;
000570  4648              MOV      r0,r9
                  |L1.1394|
;;;961    #elif defined MPU6500
;;;962        /* Set wake frequency. */
;;;963        if (rate == 1)
;;;964            tmp[0] = INV_LPA_1_25HZ;
;;;965        else if (rate == 2)
;;;966            tmp[0] = INV_LPA_2_5HZ;
;;;967        else if (rate <= 5)
;;;968            tmp[0] = INV_LPA_5HZ;
;;;969        else if (rate <= 10)
;;;970            tmp[0] = INV_LPA_10HZ;
;;;971        else if (rate <= 20)
;;;972            tmp[0] = INV_LPA_20HZ;
;;;973        else if (rate <= 40)
;;;974            tmp[0] = INV_LPA_40HZ;
;;;975        else if (rate <= 80)
;;;976            tmp[0] = INV_LPA_80HZ;
;;;977        else if (rate <= 160)
;;;978            tmp[0] = INV_LPA_160HZ;
;;;979        else if (rate <= 320)
;;;980            tmp[0] = INV_LPA_320HZ;
;;;981        else
;;;982            tmp[0] = INV_LPA_640HZ;
;;;983        if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, tmp))
;;;984            return -1;
;;;985        tmp[0] = BIT_LPA_CYCLE;
;;;986        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, tmp))
;;;987            return -1;
;;;988    #endif
;;;989        st.chip_cfg.sensors = INV_XYZ_ACCEL;
;;;990        st.chip_cfg.clk_src = 0;
;;;991        st.chip_cfg.lp_accel_mode = 1;
;;;992        mpu_configure_fifo(0);
;;;993    
;;;994        return 0;
;;;995    }
000572  e8bd83f8          POP      {r3-r9,pc}
                  |L1.1398|
000576  2008              MOVS     r0,#8                 ;989
000578  72a8              STRB     r0,[r5,#0xa]          ;989
00057a  732e              STRB     r6,[r5,#0xc]          ;990
00057c  f8858014          STRB     r8,[r5,#0x14]         ;991
000580  2000              MOVS     r0,#0                 ;992
000582  f7fffffe          BL       mpu_configure_fifo
                  |L1.1414|
000586  2000              MOVS     r0,#0                 ;994
                  |L1.1416|
000588  e7f3              B        |L1.1394|
;;;996    
                          ENDP

                  mpu_set_sample_rate PROC
;;;1397    */
;;;1398   int mpu_set_sample_rate(unsigned short rate)
00058a  b5f8              PUSH     {r3-r7,lr}
;;;1399   {
;;;1400       unsigned char data;
;;;1401   
;;;1402       if (!(st.chip_cfg.sensors))
00058c  4da5              LDR      r5,|L1.2084|
00058e  4604              MOV      r4,r0                 ;1399
;;;1403           return -1;
000590  f04f37ff          MOV      r7,#0xffffffff
000594  7aa8              LDRB     r0,[r5,#0xa]          ;1402  ; st
000596  b328              CBZ      r0,|L1.1508|
;;;1404   
;;;1405       if (st.chip_cfg.dmp_on)
000598  f8950024          LDRB     r0,[r5,#0x24]  ; st
00059c  bb10              CBNZ     r0,|L1.1508|
;;;1406           return -1;
;;;1407       else {
;;;1408           if (st.chip_cfg.lp_accel_mode) {
00059e  7d28              LDRB     r0,[r5,#0x14]  ; st
0005a0  b148              CBZ      r0,|L1.1462|
;;;1409               if (rate && (rate <= 40)) {
0005a2  b12c              CBZ      r4,|L1.1456|
0005a4  2c28              CMP      r4,#0x28
0005a6  d803              BHI      |L1.1456|
;;;1410                   /* Just stay in low-power accel mode. */
;;;1411                   mpu_lp_accel_mode(rate);
0005a8  b2e0              UXTB     r0,r4
0005aa  f7fffffe          BL       mpu_lp_accel_mode
;;;1412                   return 0;
0005ae  e024              B        |L1.1530|
                  |L1.1456|
;;;1413               }
;;;1414               /* Requested rate exceeds the allowed frequencies in LP accel mode,
;;;1415                * switch back to full-power mode.
;;;1416                */
;;;1417               mpu_lp_accel_mode(0);
0005b0  2000              MOVS     r0,#0
0005b2  f7fffffe          BL       mpu_lp_accel_mode
                  |L1.1462|
;;;1418           }
;;;1419           if (rate < 4)
;;;1420               rate = 4;
;;;1421           else if (rate > 1000)
0005b6  f44f767a          MOV      r6,#0x3e8
0005ba  2c04              CMP      r4,#4                 ;1419
0005bc  d201              BCS      |L1.1474|
0005be  2404              MOVS     r4,#4                 ;1420
0005c0  e002              B        |L1.1480|
                  |L1.1474|
0005c2  42b4              CMP      r4,r6
0005c4  d900              BLS      |L1.1480|
;;;1422               rate = 1000;
0005c6  4634              MOV      r4,r6
                  |L1.1480|
;;;1423   
;;;1424           data = 1000 / rate - 1;
0005c8  fbb6f0f4          UDIV     r0,r6,r4
0005cc  1e40              SUBS     r0,r0,#1
0005ce  f88d0000          STRB     r0,[sp,#0]
;;;1425           if (i2c_write(st.hw->addr, st.reg->rate_div, 1, &data))
0005d2  6828              LDR      r0,[r5,#0]  ; st
0005d4  466b              MOV      r3,sp
0005d6  2201              MOVS     r2,#1
0005d8  7841              LDRB     r1,[r0,#1]
0005da  6868              LDR      r0,[r5,#4]  ; st
0005dc  7800              LDRB     r0,[r0,#0]
0005de  f7fffffe          BL       dmp_iic_write
0005e2  b108              CBZ      r0,|L1.1512|
                  |L1.1508|
;;;1426               return -1;
0005e4  4638              MOV      r0,r7
;;;1427   
;;;1428           st.chip_cfg.sample_rate = 1000 / (1 + data);
;;;1429   
;;;1430   #ifdef AK89xx_SECONDARY
;;;1431           mpu_set_compass_sample_rate(min(st.chip_cfg.compass_sample_rate, MAX_COMPASS_SAMPLE_RATE));
;;;1432   #endif
;;;1433   
;;;1434           /* Automatically set LPF to 1/2 sampling rate. */
;;;1435           mpu_set_lpf(st.chip_cfg.sample_rate >> 1);
;;;1436           return 0;
;;;1437       }
;;;1438   }
0005e6  bdf8              POP      {r3-r7,pc}
                  |L1.1512|
0005e8  f89d0000          LDRB     r0,[sp,#0]            ;1428
0005ec  1c40              ADDS     r0,r0,#1              ;1428
0005ee  fbb6f0f0          UDIV     r0,r6,r0              ;1428
0005f2  81e8              STRH     r0,[r5,#0xe]          ;1428
0005f4  0840              LSRS     r0,r0,#1              ;1435
0005f6  f7fffffe          BL       mpu_set_lpf
                  |L1.1530|
0005fa  2000              MOVS     r0,#0                 ;1436
0005fc  bdf8              POP      {r3-r7,pc}
;;;1439   
                          ENDP

                  mpu_set_accel_fsr PROC
;;;1276    */
;;;1277   int mpu_set_accel_fsr(unsigned char fsr)
0005fe  b538              PUSH     {r3-r5,lr}
;;;1278   {
;;;1279       unsigned char data;
;;;1280   
;;;1281       if (!(st.chip_cfg.sensors))
000600  4c88              LDR      r4,|L1.2084|
;;;1282           return -1;
000602  f04f35ff          MOV      r5,#0xffffffff
000606  7aa1              LDRB     r1,[r4,#0xa]          ;1281  ; st
000608  b319              CBZ      r1,|L1.1618|
;;;1283   
;;;1284       switch (fsr) {
00060a  2802              CMP      r0,#2
00060c  d006              BEQ      |L1.1564|
00060e  2804              CMP      r0,#4
000610  d006              BEQ      |L1.1568|
000612  2808              CMP      r0,#8
000614  d00e              BEQ      |L1.1588|
000616  2810              CMP      r0,#0x10
000618  d11b              BNE      |L1.1618|
00061a  e00d              B        |L1.1592|
                  |L1.1564|
;;;1285       case 2:
;;;1286           data = INV_FSR_2G << 3;
00061c  2000              MOVS     r0,#0
;;;1287           break;
00061e  e000              B        |L1.1570|
                  |L1.1568|
;;;1288       case 4:
;;;1289           data = INV_FSR_4G << 3;
000620  2008              MOVS     r0,#8
                  |L1.1570|
000622  f88d0000          STRB     r0,[sp,#0]            ;1286
;;;1290           break;
;;;1291       case 8:
;;;1292           data = INV_FSR_8G << 3;
;;;1293           break;
;;;1294       case 16:
;;;1295           data = INV_FSR_16G << 3;
;;;1296           break;
;;;1297       default:
;;;1298           return -1;
;;;1299       }
;;;1300   
;;;1301       if (st.chip_cfg.accel_fsr == (data >> 3))
000626  7a60              LDRB     r0,[r4,#9]  ; st
000628  f89d1000          LDRB     r1,[sp,#0]
00062c  ebb00fd1          CMP      r0,r1,LSR #3
000630  d004              BEQ      |L1.1596|
000632  e005              B        |L1.1600|
                  |L1.1588|
000634  2010              MOVS     r0,#0x10              ;1292
000636  e7f4              B        |L1.1570|
                  |L1.1592|
000638  2018              MOVS     r0,#0x18              ;1295
00063a  e7f2              B        |L1.1570|
                  |L1.1596|
;;;1302           return 0;
00063c  2000              MOVS     r0,#0
;;;1303       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, &data))
;;;1304           return -1;
;;;1305       st.chip_cfg.accel_fsr = data >> 3;
;;;1306       return 0;
;;;1307   }
00063e  bd38              POP      {r3-r5,pc}
                  |L1.1600|
000640  6820              LDR      r0,[r4,#0]            ;1303  ; st
000642  466b              MOV      r3,sp                 ;1303
000644  2201              MOVS     r2,#1                 ;1303
000646  79c1              LDRB     r1,[r0,#7]            ;1303
000648  6860              LDR      r0,[r4,#4]            ;1303  ; st
00064a  7800              LDRB     r0,[r0,#0]            ;1303
00064c  f7fffffe          BL       dmp_iic_write
000650  b108              CBZ      r0,|L1.1622|
                  |L1.1618|
000652  4628              MOV      r0,r5                 ;1304
000654  bd38              POP      {r3-r5,pc}
                  |L1.1622|
000656  f89d0000          LDRB     r0,[sp,#0]            ;1305
00065a  08c0              LSRS     r0,r0,#3              ;1305
00065c  7260              STRB     r0,[r4,#9]            ;1305
00065e  e7ed              B        |L1.1596|
;;;1308   
                          ENDP

                  mpu_set_gyro_fsr PROC
;;;1211    */
;;;1212   int mpu_set_gyro_fsr(unsigned short fsr)
000660  b538              PUSH     {r3-r5,lr}
;;;1213   {
;;;1214       unsigned char data;
;;;1215   
;;;1216       if (!(st.chip_cfg.sensors))
000662  4c70              LDR      r4,|L1.2084|
;;;1217           return -1;
000664  f04f35ff          MOV      r5,#0xffffffff
000668  7aa1              LDRB     r1,[r4,#0xa]          ;1216  ; st
00066a  b331              CBZ      r1,|L1.1722|
;;;1218   
;;;1219       switch (fsr) {
00066c  28fa              CMP      r0,#0xfa
00066e  d009              BEQ      |L1.1668|
000670  f5b07ffa          CMP      r0,#0x1f4
000674  d008              BEQ      |L1.1672|
000676  f5b07f7a          CMP      r0,#0x3e8
00067a  d00f              BEQ      |L1.1692|
00067c  f5b06ffa          CMP      r0,#0x7d0
000680  d11b              BNE      |L1.1722|
000682  e00d              B        |L1.1696|
                  |L1.1668|
;;;1220       case 250:
;;;1221           data = INV_FSR_250DPS << 3;
000684  2000              MOVS     r0,#0
;;;1222           break;
000686  e000              B        |L1.1674|
                  |L1.1672|
;;;1223       case 500:
;;;1224           data = INV_FSR_500DPS << 3;
000688  2008              MOVS     r0,#8
                  |L1.1674|
00068a  f88d0000          STRB     r0,[sp,#0]            ;1221
;;;1225           break;
;;;1226       case 1000:
;;;1227           data = INV_FSR_1000DPS << 3;
;;;1228           break;
;;;1229       case 2000:
;;;1230           data = INV_FSR_2000DPS << 3;
;;;1231           break;
;;;1232       default:
;;;1233           return -1;
;;;1234       }
;;;1235   
;;;1236       if (st.chip_cfg.gyro_fsr == (data >> 3))
00068e  7a20              LDRB     r0,[r4,#8]  ; st
000690  f89d1000          LDRB     r1,[sp,#0]
000694  ebb00fd1          CMP      r0,r1,LSR #3
000698  d004              BEQ      |L1.1700|
00069a  e005              B        |L1.1704|
                  |L1.1692|
00069c  2010              MOVS     r0,#0x10              ;1227
00069e  e7f4              B        |L1.1674|
                  |L1.1696|
0006a0  2018              MOVS     r0,#0x18              ;1230
0006a2  e7f2              B        |L1.1674|
                  |L1.1700|
;;;1237           return 0;
0006a4  2000              MOVS     r0,#0
;;;1238       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, &data))
;;;1239           return -1;
;;;1240       st.chip_cfg.gyro_fsr = data >> 3;
;;;1241       return 0;
;;;1242   }
0006a6  bd38              POP      {r3-r5,pc}
                  |L1.1704|
0006a8  6820              LDR      r0,[r4,#0]            ;1238  ; st
0006aa  466b              MOV      r3,sp                 ;1238
0006ac  2201              MOVS     r2,#1                 ;1238
0006ae  7981              LDRB     r1,[r0,#6]            ;1238
0006b0  6860              LDR      r0,[r4,#4]            ;1238  ; st
0006b2  7800              LDRB     r0,[r0,#0]            ;1238
0006b4  f7fffffe          BL       dmp_iic_write
0006b8  b108              CBZ      r0,|L1.1726|
                  |L1.1722|
0006ba  4628              MOV      r0,r5                 ;1239
0006bc  bd38              POP      {r3-r5,pc}
                  |L1.1726|
0006be  f89d0000          LDRB     r0,[sp,#0]            ;1240
0006c2  08c0              LSRS     r0,r0,#3              ;1240
0006c4  7220              STRB     r0,[r4,#8]            ;1240
0006c6  e7ed              B        |L1.1700|
;;;1243   
                          ENDP

                  mpu_init PROC
;;;787     */
;;;788    int mpu_init(void)
0006c8  e92d41fc          PUSH     {r2-r8,lr}
;;;789    {
;;;790        unsigned char data[6], rev;
;;;791    
;;;792        /* Reset device. */
;;;793        data[0] = BIT_RESET;
;;;794        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
0006cc  4c55              LDR      r4,|L1.2084|
0006ce  2080              MOVS     r0,#0x80              ;793
0006d0  f88d0000          STRB     r0,[sp,#0]            ;793
0006d4  6820              LDR      r0,[r4,#0]  ; st
0006d6  466b              MOV      r3,sp
0006d8  2201              MOVS     r2,#1
0006da  7c81              LDRB     r1,[r0,#0x12]
0006dc  6860              LDR      r0,[r4,#4]  ; st
0006de  7800              LDRB     r0,[r0,#0]
0006e0  f7fffffe          BL       dmp_iic_write
;;;795            return -1;
0006e4  f04f37ff          MOV      r7,#0xffffffff
0006e8  2800              CMP      r0,#0                 ;794
0006ea  d132              BNE      |L1.1874|
;;;796        delay_ms(100);
0006ec  2064              MOVS     r0,#0x64
0006ee  f7fffffe          BL       vTaskDelay
;;;797    
;;;798        /* Wake up chip. */
;;;799        data[0] = 0x00;
0006f2  2500              MOVS     r5,#0
0006f4  f88d5000          STRB     r5,[sp,#0]
;;;800        if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
0006f8  6820              LDR      r0,[r4,#0]  ; st
0006fa  466b              MOV      r3,sp
0006fc  2201              MOVS     r2,#1
0006fe  7c81              LDRB     r1,[r0,#0x12]
000700  6860              LDR      r0,[r4,#4]  ; st
000702  7800              LDRB     r0,[r0,#0]
000704  f7fffffe          BL       dmp_iic_write
000708  2800              CMP      r0,#0
00070a  d170              BNE      |L1.2030|
;;;801            return -1;
;;;802    
;;;803    #if defined MPU6050
;;;804        /* Check product revision. */
;;;805        if (i2c_read(st.hw->addr, st.reg->accel_offs, 6, data))
00070c  6820              LDR      r0,[r4,#0]  ; st
00070e  466b              MOV      r3,sp
000710  2206              MOVS     r2,#6
000712  7d81              LDRB     r1,[r0,#0x16]
000714  6860              LDR      r0,[r4,#4]  ; st
000716  7800              LDRB     r0,[r0,#0]
000718  f7fffffe          BL       dmp_iic_read
00071c  2800              CMP      r0,#0
00071e  d166              BNE      |L1.2030|
;;;806            return -1;
;;;807        rev = ((data[5] & 0x01) << 2) | ((data[3] & 0x01) << 1) |
000720  f89d0005          LDRB     r0,[sp,#5]
000724  f89d1003          LDRB     r1,[sp,#3]
000728  07c0              LSLS     r0,r0,#31
00072a  0f40              LSRS     r0,r0,#29
00072c  f0010101          AND      r1,r1,#1
000730  ea400141          ORR      r1,r0,r1,LSL #1
000734  f89d0001          LDRB     r0,[sp,#1]
000738  f04f0601          MOV      r6,#1                 ;794
00073c  f0000001          AND      r0,r0,#1
000740  4301              ORRS     r1,r1,r0
;;;808            (data[1] & 0x01);
;;;809    
;;;810        if (rev) {
000742  d009              BEQ      |L1.1880|
;;;811            /* Congrats, these parts are better. */
;;;812            if (rev == 1)
000744  2901              CMP      r1,#1
000746  d005              BEQ      |L1.1876|
;;;813                st.chip_cfg.accel_half = 1;
;;;814            else if (rev == 2)
000748  2902              CMP      r1,#2
00074a  d015              BEQ      |L1.1912|
;;;815                st.chip_cfg.accel_half = 0;
;;;816            else {
;;;817                log_e("Unsupported software product rev %d.\n", rev);
00074c  a036              ADR      r0,|L1.2088|
00074e  f7fffffe          BL       __2printf
                  |L1.1874|
;;;818                return -1;
000752  e04c              B        |L1.2030|
                  |L1.1876|
000754  74e6              STRB     r6,[r4,#0x13]         ;813
000756  e010              B        |L1.1914|
                  |L1.1880|
;;;819            }
;;;820        } else {
;;;821            if (i2c_read(st.hw->addr, st.reg->prod_id, 1, data))
000758  6820              LDR      r0,[r4,#0]  ; st
00075a  466b              MOV      r3,sp
00075c  2201              MOVS     r2,#1
00075e  78c1              LDRB     r1,[r0,#3]
000760  6860              LDR      r0,[r4,#4]  ; st
000762  7800              LDRB     r0,[r0,#0]
000764  f7fffffe          BL       dmp_iic_read
000768  bb40              CBNZ     r0,|L1.1980|
;;;822                return -1;
;;;823            rev = data[0] & 0x0F;
00076a  f89d0000          LDRB     r0,[sp,#0]
00076e  f010000f          ANDS     r0,r0,#0xf
;;;824            if (!rev) {
000772  d020              BEQ      |L1.1974|
;;;825                log_e("Product ID read as 0 indicates device is either "
;;;826                    "incompatible or an MPU3050.\n");
;;;827                return -1;
;;;828            } else if (rev == 4) {
000774  2804              CMP      r0,#4
000776  d022              BEQ      |L1.1982|
                  |L1.1912|
;;;829                log_i("Half sensitivity part found.\n");
;;;830                st.chip_cfg.accel_half = 1;
;;;831            } else
;;;832                st.chip_cfg.accel_half = 0;
000778  74e5              STRB     r5,[r4,#0x13]
                  |L1.1914|
;;;833        }
;;;834    #elif defined MPU6500
;;;835    #define MPU6500_MEM_REV_ADDR    (0x17)
;;;836        if (mpu_read_mem(MPU6500_MEM_REV_ADDR, 1, &rev))
;;;837            return -1;
;;;838        if (rev == 0x1)
;;;839            st.chip_cfg.accel_half = 0;
;;;840        else {
;;;841            log_e("Unsupported software product rev %d.\n", rev);
;;;842            return -1;
;;;843        }
;;;844    
;;;845        /* MPU6500 shares 4kB of memory between the DMP and the FIFO. Since the
;;;846         * first 3kB are needed by the DMP, we'll use the last 1kB for the FIFO.
;;;847         */
;;;848        data[0] = BIT_FIFO_SIZE_1024 | 0x8;
;;;849        if (i2c_write(st.hw->addr, st.reg->accel_cfg2, 1, data))
;;;850            return -1;
;;;851    #endif
;;;852    
;;;853        /* Set to invalid values to ensure no I2C writes are skipped. */
;;;854        st.chip_cfg.sensors = 0xFF;
00077a  20ff              MOVS     r0,#0xff
00077c  f8040f0a          STRB     r0,[r4,#0xa]!
;;;855        st.chip_cfg.gyro_fsr = 0xFF;
;;;856        st.chip_cfg.accel_fsr = 0xFF;
;;;857        st.chip_cfg.lpf = 0xFF;
;;;858        st.chip_cfg.sample_rate = 0xFFFF;
000780  f64f71ff          MOV      r1,#0xffff
000784  f8040c02          STRB     r0,[r4,#-2]           ;855
000788  f8040c01          STRB     r0,[r4,#-1]           ;856
00078c  7060              STRB     r0,[r4,#1]            ;857
00078e  80a1              STRH     r1,[r4,#4]
;;;859        st.chip_cfg.fifo_enable = 0xFF;
000790  71a0              STRB     r0,[r4,#6]
;;;860        st.chip_cfg.bypass_mode = 0xFF;
000792  7220              STRB     r0,[r4,#8]
;;;861    #ifdef AK89xx_SECONDARY
;;;862        st.chip_cfg.compass_sample_rate = 0xFFFF;
;;;863    #endif
;;;864        /* mpu_set_sensors always preserves this setting. */
;;;865        st.chip_cfg.clk_src = INV_CLK_PLL;
000794  70a6              STRB     r6,[r4,#2]
;;;866        /* Handled in next call to mpu_set_bypass. */
;;;867        st.chip_cfg.active_low_int = 1;
000796  7626              STRB     r6,[r4,#0x18]
;;;868        st.chip_cfg.latched_int = 0;
000798  7665              STRB     r5,[r4,#0x19]
;;;869        st.chip_cfg.int_motion_only = 0;
00079a  72e5              STRB     r5,[r4,#0xb]
;;;870        st.chip_cfg.lp_accel_mode = 0;
00079c  72a5              STRB     r5,[r4,#0xa]
;;;871        memset(&st.chip_cfg.cache, 0, sizeof(st.chip_cfg.cache));
00079e  60e5              STR      r5,[r4,#0xc]  ; st
0007a0  6125              STR      r5,[r4,#0x10]  ; st
0007a2  6165              STR      r5,[r4,#0x14]  ; st
;;;872        st.chip_cfg.dmp_on = 0;
0007a4  76a5              STRB     r5,[r4,#0x1a]
;;;873        st.chip_cfg.dmp_loaded = 0;
0007a6  76e5              STRB     r5,[r4,#0x1b]
;;;874        st.chip_cfg.dmp_sample_rate = 0;
0007a8  83a5              STRH     r5,[r4,#0x1c]
;;;875    
;;;876        if (mpu_set_gyro_fsr(2000))
0007aa  f44f60fa          MOV      r0,#0x7d0
0007ae  f7fffffe          BL       mpu_set_gyro_fsr
0007b2  b918              CBNZ     r0,|L1.1980|
0007b4  e007              B        |L1.1990|
                  |L1.1974|
0007b6  4826              LDR      r0,|L1.2128|
0007b8  f7fffffe          BL       __2printf
                  |L1.1980|
0007bc  e017              B        |L1.2030|
                  |L1.1982|
0007be  a025              ADR      r0,|L1.2132|
0007c0  f7fffffe          BL       __2printf
0007c4  e7c6              B        |L1.1876|
                  |L1.1990|
;;;877            return -1;
;;;878        if (mpu_set_accel_fsr(2))
0007c6  2002              MOVS     r0,#2
0007c8  f7fffffe          BL       mpu_set_accel_fsr
0007cc  b978              CBNZ     r0,|L1.2030|
;;;879            return -1;
;;;880        if (mpu_set_lpf(42))
0007ce  202a              MOVS     r0,#0x2a
0007d0  f7fffffe          BL       mpu_set_lpf
0007d4  b958              CBNZ     r0,|L1.2030|
;;;881            return -1;
;;;882        if (mpu_set_sample_rate(50))
0007d6  2032              MOVS     r0,#0x32
0007d8  f7fffffe          BL       mpu_set_sample_rate
0007dc  b938              CBNZ     r0,|L1.2030|
;;;883            return -1;
;;;884        if (mpu_configure_fifo(0))
0007de  2000              MOVS     r0,#0
0007e0  f7fffffe          BL       mpu_configure_fifo
0007e4  b918              CBNZ     r0,|L1.2030|
;;;885            return -1;
;;;886    
;;;887    //    if (int_param)
;;;888    //        reg_int_cb(int_param);
;;;889    
;;;890    #ifdef AK89xx_SECONDARY
;;;891        setup_compass();
;;;892        if (mpu_set_compass_sample_rate(10))
;;;893            return -1;
;;;894    #else
;;;895        /* Already disabled by setup_compass. */
;;;896        if (mpu_set_bypass(0))
0007e6  2000              MOVS     r0,#0
0007e8  f7fffffe          BL       mpu_set_bypass
0007ec  b110              CBZ      r0,|L1.2036|
                  |L1.2030|
;;;897            return -1;
0007ee  4638              MOV      r0,r7
                  |L1.2032|
;;;898    #endif
;;;899    
;;;900        mpu_set_sensors(0);
;;;901        return 0;
;;;902    }
0007f0  e8bd81fc          POP      {r2-r8,pc}
                  |L1.2036|
0007f4  2000              MOVS     r0,#0                 ;900
0007f6  f7fffffe          BL       mpu_set_sensors
0007fa  2000              MOVS     r0,#0                 ;901
0007fc  e7f8              B        |L1.2032|
;;;903    
                          ENDP

                  mget_ms PROC
;;;2973   //空函数,未用到.
;;;2974   void mget_ms(unsigned long *time)
0007fe  4770              BX       lr
;;;2975   {
;;;2976   
;;;2977   }
;;;2978   //mpu6050,dmp初始化
                          ENDP

                  mpu_get_gyro_reg PROC
;;;1002    */
;;;1003   int mpu_get_gyro_reg(short *data, unsigned long *timestamp)
000800  b57c              PUSH     {r2-r6,lr}
;;;1004   {
000802  4604              MOV      r4,r0
;;;1005       unsigned char tmp[6];
;;;1006   
;;;1007       if (!(st.chip_cfg.sensors & INV_XYZ_GYRO))
000804  4807              LDR      r0,|L1.2084|
;;;1008           return -1;
000806  f04f35ff          MOV      r5,#0xffffffff
00080a  7a81              LDRB     r1,[r0,#0xa]          ;1007  ; st
00080c  f0110f70          TST      r1,#0x70              ;1007
000810  d031              BEQ      |L1.2166|
;;;1009   
;;;1010       if (i2c_read(st.hw->addr, st.reg->raw_gyro, 6, tmp))
000812  6801              LDR      r1,[r0,#0]  ; st
000814  6840              LDR      r0,[r0,#4]  ; st
000816  466b              MOV      r3,sp
000818  7b09              LDRB     r1,[r1,#0xc]
00081a  7800              LDRB     r0,[r0,#0]
00081c  2206              MOVS     r2,#6
00081e  f7fffffe          BL       dmp_iic_read
000822  e027              B        |L1.2164|
                  |L1.2084|
                          DCD      ||.data||
                  |L1.2088|
000828  556e7375          DCB      "Unsupported software product rev %d.\n",0
00082c  70706f72
000830  74656420
000834  736f6674
000838  77617265
00083c  2070726f
000840  64756374
000844  20726576
000848  2025642e
00084c  0a00    
00084e  00                DCB      0
00084f  00                DCB      0
                  |L1.2128|
                          DCD      ||.conststring||
                  |L1.2132|
000854  48616c66          DCB      "Half sensitivity part found.\n",0
000858  2073656e
00085c  73697469
000860  76697479
000864  20706172
000868  7420666f
00086c  756e642e
000870  0a00    
000872  00                DCB      0
000873  00                DCB      0
                  |L1.2164|
000874  b108              CBZ      r0,|L1.2170|
                  |L1.2166|
;;;1011           return -1;
000876  4628              MOV      r0,r5
;;;1012       data[0] = (tmp[0] << 8) | tmp[1];
;;;1013       data[1] = (tmp[2] << 8) | tmp[3];
;;;1014       data[2] = (tmp[4] << 8) | tmp[5];
;;;1015       if (timestamp)
;;;1016           get_ms(timestamp);
;;;1017       return 0;
;;;1018   }
000878  bd7c              POP      {r2-r6,pc}
                  |L1.2170|
00087a  f8bd0000          LDRH     r0,[sp,#0]            ;1012
00087e  ba40              REV16    r0,r0                 ;1012
000880  8020              STRH     r0,[r4,#0]            ;1012
000882  f8bd0002          LDRH     r0,[sp,#2]            ;1013
000886  ba40              REV16    r0,r0                 ;1013
000888  8060              STRH     r0,[r4,#2]            ;1013
00088a  f8bd0004          LDRH     r0,[sp,#4]            ;1014
00088e  ba40              REV16    r0,r0                 ;1014
000890  80a0              STRH     r0,[r4,#4]            ;1014
000892  2000              MOVS     r0,#0                 ;1017
000894  bd7c              POP      {r2-r6,pc}
;;;1019   
                          ENDP

                  mpu_get_accel_reg PROC
;;;1025    */
;;;1026   int mpu_get_accel_reg(short *data, unsigned long *timestamp)
000896  b57c              PUSH     {r2-r6,lr}
;;;1027   {
000898  4604              MOV      r4,r0
;;;1028       unsigned char tmp[6];
;;;1029   
;;;1030       if (!(st.chip_cfg.sensors & INV_XYZ_ACCEL))
00089a  48fe              LDR      r0,|L1.3220|
;;;1031           return -1;
00089c  f04f35ff          MOV      r5,#0xffffffff
0008a0  7a81              LDRB     r1,[r0,#0xa]          ;1030  ; st
0008a2  0709              LSLS     r1,r1,#28             ;1030
0008a4  d508              BPL      |L1.2232|
;;;1032   
;;;1033       if (i2c_read(st.hw->addr, st.reg->raw_accel, 6, tmp))
0008a6  6801              LDR      r1,[r0,#0]  ; st
0008a8  6840              LDR      r0,[r0,#4]  ; st
0008aa  466b              MOV      r3,sp
0008ac  7b49              LDRB     r1,[r1,#0xd]
0008ae  7800              LDRB     r0,[r0,#0]
0008b0  2206              MOVS     r2,#6
0008b2  f7fffffe          BL       dmp_iic_read
0008b6  b108              CBZ      r0,|L1.2236|
                  |L1.2232|
;;;1034           return -1;
0008b8  4628              MOV      r0,r5
;;;1035       data[0] = (tmp[0] << 8) | tmp[1];
;;;1036       data[1] = (tmp[2] << 8) | tmp[3];
;;;1037       data[2] = (tmp[4] << 8) | tmp[5];
;;;1038       if (timestamp)
;;;1039           get_ms(timestamp);
;;;1040       return 0;
;;;1041   }
0008ba  bd7c              POP      {r2-r6,pc}
                  |L1.2236|
0008bc  f8bd0000          LDRH     r0,[sp,#0]            ;1035
0008c0  ba40              REV16    r0,r0                 ;1035
0008c2  8020              STRH     r0,[r4,#0]            ;1035
0008c4  f8bd0002          LDRH     r0,[sp,#2]            ;1036
0008c8  ba40              REV16    r0,r0                 ;1036
0008ca  8060              STRH     r0,[r4,#2]            ;1036
0008cc  f8bd0004          LDRH     r0,[sp,#4]            ;1037
0008d0  ba40              REV16    r0,r0                 ;1037
0008d2  80a0              STRH     r0,[r4,#4]            ;1037
0008d4  2000              MOVS     r0,#0                 ;1040
0008d6  bd7c              POP      {r2-r6,pc}
;;;1042   
                          ENDP

                  mpu_get_temperature PROC
;;;1048    */
;;;1049   int mpu_get_temperature(long *data, unsigned long *timestamp)
0008d8  b5f8              PUSH     {r3-r7,lr}
;;;1050   {
;;;1051       unsigned char tmp[2];
;;;1052       short raw;
;;;1053   
;;;1054       if (!(st.chip_cfg.sensors))
0008da  4cee              LDR      r4,|L1.3220|
0008dc  4607              MOV      r7,r0                 ;1050
;;;1055           return -1;
0008de  f04f35ff          MOV      r5,#0xffffffff
0008e2  7aa0              LDRB     r0,[r4,#0xa]          ;1054  ; st
0008e4  b140              CBZ      r0,|L1.2296|
;;;1056   
;;;1057       if (i2c_read(st.hw->addr, st.reg->temp, 2, tmp))
0008e6  6820              LDR      r0,[r4,#0]  ; st
0008e8  466b              MOV      r3,sp
0008ea  2202              MOVS     r2,#2
0008ec  7b81              LDRB     r1,[r0,#0xe]
0008ee  6860              LDR      r0,[r4,#4]  ; st
0008f0  7800              LDRB     r0,[r0,#0]
0008f2  f7fffffe          BL       dmp_iic_read
0008f6  b108              CBZ      r0,|L1.2300|
                  |L1.2296|
;;;1058           return -1;
0008f8  4628              MOV      r0,r5
;;;1059       raw = (tmp[0] << 8) | tmp[1];
;;;1060       if (timestamp)
;;;1061           get_ms(timestamp);
;;;1062   
;;;1063       data[0] = (long)((35 + ((raw - (float)st.hw->temp_offset) / st.hw->temp_sens)) * 65536L);
;;;1064       return 0;
;;;1065   }
0008fa  bdf8              POP      {r3-r7,pc}
                  |L1.2300|
0008fc  f8bd0000          LDRH     r0,[sp,#0]            ;1059
000900  6864              LDR      r4,[r4,#4]            ;1063  ; st
000902  ba40              REV16    r0,r0                 ;1059
000904  b205              SXTH     r5,r0                 ;1059
000906  88e0              LDRH     r0,[r4,#6]            ;1063
000908  f7fffffe          BL       __aeabi_ui2f
00090c  4606              MOV      r6,r0                 ;1063
00090e  f9b40008          LDRSH    r0,[r4,#8]            ;1063
000912  f7fffffe          BL       __aeabi_i2f
000916  4604              MOV      r4,r0                 ;1063
000918  4628              MOV      r0,r5                 ;1063
00091a  f7fffffe          BL       __aeabi_i2f
00091e  4621              MOV      r1,r4                 ;1063
000920  f7fffffe          BL       __aeabi_fsub
000924  4631              MOV      r1,r6                 ;1063
000926  f7fffffe          BL       __aeabi_fdiv
00092a  49db              LDR      r1,|L1.3224|
00092c  f7fffffe          BL       __aeabi_fadd
000930  2110              MOVS     r1,#0x10              ;1063
000932  f7fffffe          BL       __ARM_scalbnf
000936  f7fffffe          BL       __aeabi_f2iz
00093a  6038              STR      r0,[r7,#0]            ;1064
00093c  2000              MOVS     r0,#0                 ;1064
00093e  bdf8              POP      {r3-r7,pc}
;;;1066   
                          ENDP

                  mpu_set_accel_bias PROC
;;;1073    */
;;;1074   int mpu_set_accel_bias(const long *accel_bias)
000940  e92d41fc          PUSH     {r2-r8,lr}
;;;1075   {
000944  0004              MOVS     r4,r0
;;;1076       unsigned char data[6];
;;;1077       short accel_hw[3];
;;;1078       short got_accel[3];
;;;1079       short fg[3];
;;;1080   
;;;1081       if (!accel_bias)
;;;1082           return -1;
000946  f04f38ff          MOV      r8,#0xffffffff
00094a  d062              BEQ      |L1.2578|
;;;1083       if (!accel_bias[0] && !accel_bias[1] && !accel_bias[2])
00094c  6820              LDR      r0,[r4,#0]
00094e  b920              CBNZ     r0,|L1.2394|
000950  6860              LDR      r0,[r4,#4]
000952  b910              CBNZ     r0,|L1.2394|
000954  68a0              LDR      r0,[r4,#8]
000956  2800              CMP      r0,#0
000958  d05c              BEQ      |L1.2580|
                  |L1.2394|
;;;1084           return 0;
;;;1085   
;;;1086       if (i2c_read(st.hw->addr, 3, 3, data))
00095a  4fce              LDR      r7,|L1.3220|
00095c  2203              MOVS     r2,#3
00095e  466b              MOV      r3,sp
000960  6878              LDR      r0,[r7,#4]  ; st
000962  4611              MOV      r1,r2
000964  7800              LDRB     r0,[r0,#0]
000966  f7fffffe          BL       dmp_iic_read
00096a  bbe0              CBNZ     r0,|L1.2534|
;;;1087           return -1;
;;;1088       fg[0] = ((data[0] >> 4) + 8) & 0xf;
00096c  f89d1000          LDRB     r1,[sp,#0]
000970  2008              MOVS     r0,#8
000972  eb001111          ADD      r1,r0,r1,LSR #4
000976  f001020f          AND      r2,r1,#0xf
;;;1089       fg[1] = ((data[1] >> 4) + 8) & 0xf;
00097a  f89d1001          LDRB     r1,[sp,#1]
;;;1090       fg[2] = ((data[2] >> 4) + 8) & 0xf;
00097e  f89d3002          LDRB     r3,[sp,#2]
000982  eb001111          ADD      r1,r0,r1,LSR #4       ;1089
000986  eb001013          ADD      r0,r0,r3,LSR #4
;;;1091   
;;;1092       accel_hw[0] = (short)(accel_bias[0] * 2 / (64 + fg[0]));
00098a  6823              LDR      r3,[r4,#0]
00098c  3240              ADDS     r2,r2,#0x40
00098e  005b              LSLS     r3,r3,#1
000990  fb93f2f2          SDIV     r2,r3,r2
000994  b216              SXTH     r6,r2
;;;1093       accel_hw[1] = (short)(accel_bias[1] * 2 / (64 + fg[1]));
000996  6862              LDR      r2,[r4,#4]
000998  f001010f          AND      r1,r1,#0xf            ;1089
00099c  0052              LSLS     r2,r2,#1
00099e  3140              ADDS     r1,r1,#0x40
0009a0  fb92f1f1          SDIV     r1,r2,r1
0009a4  b20d              SXTH     r5,r1
;;;1094       accel_hw[2] = (short)(accel_bias[2] * 2 / (64 + fg[2]));
0009a6  68a1              LDR      r1,[r4,#8]
0009a8  f000000f          AND      r0,r0,#0xf            ;1090
0009ac  0049              LSLS     r1,r1,#1
0009ae  3040              ADDS     r0,r0,#0x40
0009b0  fb91f0f0          SDIV     r0,r1,r0
0009b4  b204              SXTH     r4,r0
;;;1095   
;;;1096       if (i2c_read(st.hw->addr, 0x06, 6, data))
0009b6  6878              LDR      r0,[r7,#4]  ; st
0009b8  2206              MOVS     r2,#6
0009ba  466b              MOV      r3,sp
0009bc  7800              LDRB     r0,[r0,#0]
0009be  4611              MOV      r1,r2
0009c0  f7fffffe          BL       dmp_iic_read
0009c4  b978              CBNZ     r0,|L1.2534|
;;;1097           return -1;
;;;1098   
;;;1099       got_accel[0] = ((short)data[0] << 8) | data[1];
0009c6  f8bd0000          LDRH     r0,[sp,#0]
;;;1100       got_accel[1] = ((short)data[2] << 8) | data[3];
0009ca  f8bd1002          LDRH     r1,[sp,#2]
0009ce  ba40              REV16    r0,r0                 ;1099
;;;1101       got_accel[2] = ((short)data[4] << 8) | data[5];
0009d0  f8bd2004          LDRH     r2,[sp,#4]
;;;1102   
;;;1103       accel_hw[0] += got_accel[0];
0009d4  4430              ADD      r0,r0,r6
0009d6  ba49              REV16    r1,r1                 ;1100
0009d8  ba52              REV16    r2,r2                 ;1101
;;;1104       accel_hw[1] += got_accel[1];
;;;1105       accel_hw[2] += got_accel[2];
;;;1106   
;;;1107       data[0] = (accel_hw[0] >> 8) & 0xff;
0009da  0a03              LSRS     r3,r0,#8
0009dc  4429              ADD      r1,r1,r5              ;1104
0009de  4422              ADD      r2,r2,r4              ;1105
0009e0  f88d3000          STRB     r3,[sp,#0]
;;;1108       data[1] = (accel_hw[0]) & 0xff;
0009e4  e000              B        |L1.2536|
                  |L1.2534|
0009e6  e014              B        |L1.2578|
                  |L1.2536|
0009e8  f88d0001          STRB     r0,[sp,#1]
;;;1109       data[2] = (accel_hw[1] >> 8) & 0xff;
0009ec  0a08              LSRS     r0,r1,#8
0009ee  f88d0002          STRB     r0,[sp,#2]
;;;1110       data[3] = (accel_hw[1]) & 0xff;
;;;1111       data[4] = (accel_hw[2] >> 8) & 0xff;
0009f2  0a10              LSRS     r0,r2,#8
0009f4  f88d0004          STRB     r0,[sp,#4]
0009f8  f88d1003          STRB     r1,[sp,#3]            ;1110
;;;1112       data[5] = (accel_hw[2]) & 0xff;
0009fc  f88d2005          STRB     r2,[sp,#5]
;;;1113   
;;;1114       if (i2c_write(st.hw->addr, 0x06, 6, data))
000a00  6878              LDR      r0,[r7,#4]  ; st
000a02  2206              MOVS     r2,#6
000a04  466b              MOV      r3,sp
000a06  7800              LDRB     r0,[r0,#0]
000a08  4611              MOV      r1,r2
000a0a  f7fffffe          BL       dmp_iic_write
000a0e  2800              CMP      r0,#0
000a10  d000              BEQ      |L1.2580|
                  |L1.2578|
;;;1115           return -1;
000a12  4640              MOV      r0,r8
                  |L1.2580|
;;;1116       return 0;
;;;1117   }
000a14  e6ec              B        |L1.2032|
;;;1118   
                          ENDP

                  mpu_get_gyro_fsr PROC
;;;1184    */
;;;1185   int mpu_get_gyro_fsr(unsigned short *fsr)
000a16  499f              LDR      r1,|L1.3220|
;;;1186   {
;;;1187       switch (st.chip_cfg.gyro_fsr) {
000a18  7a09              LDRB     r1,[r1,#8]  ; st
000a1a  b139              CBZ      r1,|L1.2604|
000a1c  2901              CMP      r1,#1
000a1e  d007              BEQ      |L1.2608|
000a20  2902              CMP      r1,#2
000a22  d00a              BEQ      |L1.2618|
000a24  2903              CMP      r1,#3
000a26  d00b              BEQ      |L1.2624|
;;;1188       case INV_FSR_250DPS:
;;;1189           fsr[0] = 250;
;;;1190           break;
;;;1191       case INV_FSR_500DPS:
;;;1192           fsr[0] = 500;
;;;1193           break;
;;;1194       case INV_FSR_1000DPS:
;;;1195           fsr[0] = 1000;
;;;1196           break;
;;;1197       case INV_FSR_2000DPS:
;;;1198           fsr[0] = 2000;
;;;1199           break;
;;;1200       default:
;;;1201           fsr[0] = 0;
000a28  2100              MOVS     r1,#0
;;;1202           break;
000a2a  e003              B        |L1.2612|
                  |L1.2604|
000a2c  21fa              MOVS     r1,#0xfa              ;1189
000a2e  e001              B        |L1.2612|
                  |L1.2608|
000a30  f44f71fa          MOV      r1,#0x1f4             ;1192
                  |L1.2612|
000a34  8001              STRH     r1,[r0,#0]            ;1189
;;;1203       }
;;;1204       return 0;
000a36  2000              MOVS     r0,#0
;;;1205   }
000a38  4770              BX       lr
                  |L1.2618|
000a3a  f44f717a          MOV      r1,#0x3e8             ;1195
000a3e  e7f9              B        |L1.2612|
                  |L1.2624|
000a40  f44f61fa          MOV      r1,#0x7d0             ;1198
000a44  e7f6              B        |L1.2612|
;;;1206   
                          ENDP

                  mpu_get_accel_fsr PROC
;;;1248    */
;;;1249   int mpu_get_accel_fsr(unsigned char *fsr)
000a46  4a93              LDR      r2,|L1.3220|
;;;1250   {
;;;1251       switch (st.chip_cfg.accel_fsr) {
000a48  7a51              LDRB     r1,[r2,#9]  ; st
000a4a  b141              CBZ      r1,|L1.2654|
000a4c  2901              CMP      r1,#1
000a4e  d008              BEQ      |L1.2658|
000a50  2902              CMP      r1,#2
000a52  d00f              BEQ      |L1.2676|
000a54  2903              CMP      r1,#3
000a56  d00f              BEQ      |L1.2680|
;;;1252       case INV_FSR_2G:
;;;1253           fsr[0] = 2;
;;;1254           break;
;;;1255       case INV_FSR_4G:
;;;1256           fsr[0] = 4;
;;;1257           break;
;;;1258       case INV_FSR_8G:
;;;1259           fsr[0] = 8;
;;;1260           break;
;;;1261       case INV_FSR_16G:
;;;1262           fsr[0] = 16;
;;;1263           break;
;;;1264       default:
;;;1265           return -1;
000a58  f04f30ff          MOV      r0,#0xffffffff
;;;1266       }
;;;1267       if (st.chip_cfg.accel_half)
;;;1268           fsr[0] <<= 1;
;;;1269       return 0;
;;;1270   }
000a5c  4770              BX       lr
                  |L1.2654|
000a5e  2102              MOVS     r1,#2                 ;1253
000a60  e000              B        |L1.2660|
                  |L1.2658|
000a62  2104              MOVS     r1,#4                 ;1256
                  |L1.2660|
000a64  7001              STRB     r1,[r0,#0]            ;1253
000a66  7cd1              LDRB     r1,[r2,#0x13]         ;1267  ; st
000a68  b111              CBZ      r1,|L1.2672|
000a6a  7801              LDRB     r1,[r0,#0]            ;1268
000a6c  0049              LSLS     r1,r1,#1              ;1268
000a6e  7001              STRB     r1,[r0,#0]            ;1268
                  |L1.2672|
000a70  2000              MOVS     r0,#0                 ;1269
000a72  4770              BX       lr
                  |L1.2676|
000a74  2108              MOVS     r1,#8                 ;1259
000a76  e7f5              B        |L1.2660|
                  |L1.2680|
000a78  2110              MOVS     r1,#0x10              ;1262
000a7a  e7f3              B        |L1.2660|
;;;1271   
                          ENDP

                  mpu_get_lpf PROC
;;;1313    */
;;;1314   int mpu_get_lpf(unsigned short *lpf)
000a7c  4985              LDR      r1,|L1.3220|
;;;1315   {
;;;1316       switch (st.chip_cfg.lpf) {
000a7e  7ac9              LDRB     r1,[r1,#0xb]  ; st
000a80  2907              CMP      r1,#7
000a82  d213              BCS      |L1.2732|
000a84  e8dff001          TBB      [pc,r1]
000a88  1204060a          DCB      0x12,0x04,0x06,0x0a
000a8c  0c0e1000          DCB      0x0c,0x0e,0x10,0x00
;;;1317       case INV_FILTER_188HZ:
;;;1318           lpf[0] = 188;
000a90  21bc              MOVS     r1,#0xbc
;;;1319           break;
000a92  e000              B        |L1.2710|
;;;1320       case INV_FILTER_98HZ:
;;;1321           lpf[0] = 98;
000a94  2162              MOVS     r1,#0x62
                  |L1.2710|
000a96  8001              STRH     r1,[r0,#0]            ;1318
;;;1322           break;
;;;1323       case INV_FILTER_42HZ:
;;;1324           lpf[0] = 42;
;;;1325           break;
;;;1326       case INV_FILTER_20HZ:
;;;1327           lpf[0] = 20;
;;;1328           break;
;;;1329       case INV_FILTER_10HZ:
;;;1330           lpf[0] = 10;
;;;1331           break;
;;;1332       case INV_FILTER_5HZ:
;;;1333           lpf[0] = 5;
;;;1334           break;
;;;1335       case INV_FILTER_256HZ_NOLPF2:
;;;1336       case INV_FILTER_2100HZ_NOLPF:
;;;1337       default:
;;;1338           lpf[0] = 0;
;;;1339           break;
;;;1340       }
;;;1341       return 0;
000a98  2000              MOVS     r0,#0
;;;1342   }
000a9a  4770              BX       lr
000a9c  212a              MOVS     r1,#0x2a              ;1324
000a9e  e7fa              B        |L1.2710|
000aa0  2114              MOVS     r1,#0x14              ;1327
000aa2  e7f8              B        |L1.2710|
000aa4  210a              MOVS     r1,#0xa               ;1330
000aa6  e7f6              B        |L1.2710|
000aa8  2105              MOVS     r1,#5                 ;1333
000aaa  e7f4              B        |L1.2710|
                  |L1.2732|
000aac  2100              MOVS     r1,#0                 ;1338
000aae  e7f2              B        |L1.2710|
;;;1343   
                          ENDP

                  mpu_get_sample_rate PROC
;;;1382    */
;;;1383   int mpu_get_sample_rate(unsigned short *rate)
000ab0  4978              LDR      r1,|L1.3220|
;;;1384   {
;;;1385       if (st.chip_cfg.dmp_on)
000ab2  f8912024          LDRB     r2,[r1,#0x24]  ; st
000ab6  b112              CBZ      r2,|L1.2750|
;;;1386           return -1;
000ab8  f04f30ff          MOV      r0,#0xffffffff
;;;1387       else
;;;1388           rate[0] = st.chip_cfg.sample_rate;
;;;1389       return 0;
;;;1390   }
000abc  4770              BX       lr
                  |L1.2750|
000abe  89c9              LDRH     r1,[r1,#0xe]          ;1388  ; st
000ac0  8001              STRH     r1,[r0,#0]            ;1388
000ac2  2000              MOVS     r0,#0                 ;1389
000ac4  4770              BX       lr
;;;1391   
                          ENDP

                  mpu_get_compass_sample_rate PROC
;;;1444    */
;;;1445   int mpu_get_compass_sample_rate(unsigned short *rate)
000ac6  2100              MOVS     r1,#0
;;;1446   {
;;;1447   #ifdef AK89xx_SECONDARY
;;;1448       rate[0] = st.chip_cfg.compass_sample_rate;
;;;1449       return 0;
;;;1450   #else
;;;1451       rate[0] = 0;
000ac8  8001              STRH     r1,[r0,#0]
;;;1452       return -1;
000aca  1e48              SUBS     r0,r1,#1
;;;1453   #endif
;;;1454   }
000acc  4770              BX       lr
;;;1455   
                          ENDP

                  mpu_set_compass_sample_rate PROC
;;;1466    */
;;;1467   int mpu_set_compass_sample_rate(unsigned short rate)
000ace  f04f30ff          MOV      r0,#0xffffffff
;;;1468   {
;;;1469   #ifdef AK89xx_SECONDARY
;;;1470       unsigned char div;
;;;1471       if (!rate || rate > st.chip_cfg.sample_rate || rate > MAX_COMPASS_SAMPLE_RATE)
;;;1472           return -1;
;;;1473   
;;;1474       div = st.chip_cfg.sample_rate / rate - 1;
;;;1475       if (i2c_write(st.hw->addr, st.reg->s4_ctrl, 1, &div))
;;;1476           return -1;
;;;1477       st.chip_cfg.compass_sample_rate = st.chip_cfg.sample_rate / (div + 1);
;;;1478       return 0;
;;;1479   #else
;;;1480       return -1;
;;;1481   #endif
;;;1482   }
000ad2  4770              BX       lr
;;;1483   
                          ENDP

                  mpu_get_gyro_sens PROC
;;;1488    */
;;;1489   int mpu_get_gyro_sens(float *sens)
000ad4  496f              LDR      r1,|L1.3220|
;;;1490   {
;;;1491       switch (st.chip_cfg.gyro_fsr) {
000ad6  7a09              LDRB     r1,[r1,#8]  ; st
000ad8  b141              CBZ      r1,|L1.2796|
000ada  2901              CMP      r1,#1
000adc  d008              BEQ      |L1.2800|
000ade  2902              CMP      r1,#2
000ae0  d00a              BEQ      |L1.2808|
000ae2  2903              CMP      r1,#3
000ae4  d00a              BEQ      |L1.2812|
;;;1492       case INV_FSR_250DPS:
;;;1493           sens[0] = 131.f;
;;;1494           break;
;;;1495       case INV_FSR_500DPS:
;;;1496           sens[0] = 65.5f;
;;;1497           break;
;;;1498       case INV_FSR_1000DPS:
;;;1499           sens[0] = 32.8f;
;;;1500           break;
;;;1501       case INV_FSR_2000DPS:
;;;1502           sens[0] = 16.4f;
;;;1503           break;
;;;1504       default:
;;;1505           return -1;
000ae6  f04f30ff          MOV      r0,#0xffffffff
;;;1506       }
;;;1507       return 0;
;;;1508   }
000aea  4770              BX       lr
                  |L1.2796|
000aec  496b              LDR      r1,|L1.3228|
000aee  e000              B        |L1.2802|
                  |L1.2800|
000af0  496b              LDR      r1,|L1.3232|
                  |L1.2802|
000af2  6001              STR      r1,[r0,#0]            ;1507
000af4  2000              MOVS     r0,#0                 ;1507
000af6  4770              BX       lr
                  |L1.2808|
000af8  496a              LDR      r1,|L1.3236|
000afa  e7fa              B        |L1.2802|
                  |L1.2812|
000afc  496a              LDR      r1,|L1.3240|
000afe  e7f8              B        |L1.2802|
;;;1509   
                          ENDP

                  mpu_get_accel_sens PROC
;;;1514    */
;;;1515   int mpu_get_accel_sens(unsigned short *sens)
000b00  4a64              LDR      r2,|L1.3220|
;;;1516   {
;;;1517       switch (st.chip_cfg.accel_fsr) {
000b02  7a51              LDRB     r1,[r2,#9]  ; st
000b04  b141              CBZ      r1,|L1.2840|
000b06  2901              CMP      r1,#1
000b08  d009              BEQ      |L1.2846|
000b0a  2902              CMP      r1,#2
000b0c  d011              BEQ      |L1.2866|
000b0e  2903              CMP      r1,#3
000b10  d012              BEQ      |L1.2872|
;;;1518       case INV_FSR_2G:
;;;1519           sens[0] = 16384;
;;;1520           break;
;;;1521       case INV_FSR_4G:
;;;1522           sens[0] = 8092;
;;;1523           break;
;;;1524       case INV_FSR_8G:
;;;1525           sens[0] = 4096;
;;;1526           break;
;;;1527       case INV_FSR_16G:
;;;1528           sens[0] = 2048;
;;;1529           break;
;;;1530       default:
;;;1531           return -1;
000b12  f04f30ff          MOV      r0,#0xffffffff
;;;1532       }
;;;1533       if (st.chip_cfg.accel_half)
;;;1534           sens[0] >>= 1;
;;;1535       return 0;
;;;1536   }
000b16  4770              BX       lr
                  |L1.2840|
000b18  f44f4180          MOV      r1,#0x4000            ;1519
000b1c  e001              B        |L1.2850|
                  |L1.2846|
000b1e  f641719c          MOV      r1,#0x1f9c            ;1522
                  |L1.2850|
000b22  8001              STRH     r1,[r0,#0]            ;1519
000b24  7cd1              LDRB     r1,[r2,#0x13]         ;1533  ; st
000b26  b111              CBZ      r1,|L1.2862|
000b28  8801              LDRH     r1,[r0,#0]            ;1534
000b2a  0849              LSRS     r1,r1,#1              ;1534
000b2c  8001              STRH     r1,[r0,#0]            ;1534
                  |L1.2862|
000b2e  2000              MOVS     r0,#0                 ;1535
000b30  4770              BX       lr
                  |L1.2866|
000b32  f44f5180          MOV      r1,#0x1000            ;1525
000b36  e7f4              B        |L1.2850|
                  |L1.2872|
000b38  f44f6100          MOV      r1,#0x800             ;1528
000b3c  e7f1              B        |L1.2850|
;;;1537   
                          ENDP

                  mpu_get_fifo_config PROC
;;;1546    */
;;;1547   int mpu_get_fifo_config(unsigned char *sensors)
000b3e  4955              LDR      r1,|L1.3220|
;;;1548   {
;;;1549       sensors[0] = st.chip_cfg.fifo_enable;
000b40  7c09              LDRB     r1,[r1,#0x10]  ; st
000b42  7001              STRB     r1,[r0,#0]
;;;1550       return 0;
000b44  2000              MOVS     r0,#0
;;;1551   }
000b46  4770              BX       lr
;;;1552   
                          ENDP

                  mpu_get_power_state PROC
;;;1603    */
;;;1604   int mpu_get_power_state(unsigned char *power_on)
000b48  4952              LDR      r1,|L1.3220|
;;;1605   {
;;;1606       if (st.chip_cfg.sensors)
000b4a  7a89              LDRB     r1,[r1,#0xa]  ; st
000b4c  b101              CBZ      r1,|L1.2896|
;;;1607           power_on[0] = 1;
000b4e  2101              MOVS     r1,#1
                  |L1.2896|
;;;1608       else
;;;1609           power_on[0] = 0;
000b50  7001              STRB     r1,[r0,#0]
;;;1610       return 0;
000b52  2000              MOVS     r0,#0
;;;1611   }
000b54  4770              BX       lr
;;;1612   
                          ENDP

                  mpu_get_int_status PROC
;;;1699    */
;;;1700   int mpu_get_int_status(short *status)
000b56  b538              PUSH     {r3-r5,lr}
;;;1701   {
000b58  4605              MOV      r5,r0
;;;1702       unsigned char tmp[2];
;;;1703       if (!st.chip_cfg.sensors)
000b5a  484e              LDR      r0,|L1.3220|
;;;1704           return -1;
000b5c  f04f34ff          MOV      r4,#0xffffffff
000b60  7a81              LDRB     r1,[r0,#0xa]          ;1703  ; st
000b62  b141              CBZ      r1,|L1.2934|
;;;1705       if (i2c_read(st.hw->addr, st.reg->dmp_int_status, 2, tmp))
000b64  6801              LDR      r1,[r0,#0]  ; st
000b66  6840              LDR      r0,[r0,#4]  ; st
000b68  466b              MOV      r3,sp
000b6a  7c09              LDRB     r1,[r1,#0x10]
000b6c  7800              LDRB     r0,[r0,#0]
000b6e  2202              MOVS     r2,#2
000b70  f7fffffe          BL       dmp_iic_read
000b74  b108              CBZ      r0,|L1.2938|
                  |L1.2934|
;;;1706           return -1;
000b76  4620              MOV      r0,r4
;;;1707       status[0] = (tmp[0] << 8) | tmp[1];
;;;1708       return 0;
;;;1709   }
000b78  bd38              POP      {r3-r5,pc}
                  |L1.2938|
000b7a  f8bd0000          LDRH     r0,[sp,#0]            ;1707
000b7e  ba40              REV16    r0,r0                 ;1707
000b80  8028              STRH     r0,[r5,#0]            ;1707
000b82  2000              MOVS     r0,#0                 ;1708
000b84  bd38              POP      {r3-r5,pc}
;;;1710   
                          ENDP

                  mpu_read_fifo PROC
;;;1728    */
;;;1729   int mpu_read_fifo(short *gyro, short *accel, unsigned long *timestamp,
000b86  e92d4ffe          PUSH     {r1-r11,lr}
;;;1730           unsigned char *sensors, unsigned char *more)
;;;1731   {
000b8a  4688              MOV      r8,r1
;;;1732       /* Assumes maximum packet size is gyro (6) + accel (6). */
;;;1733       unsigned char data[MAX_PACKET_LENGTH];
;;;1734       unsigned char packet_size = 0;
;;;1735       unsigned short fifo_count, index = 0;
;;;1736   
;;;1737       if (st.chip_cfg.dmp_on)
000b8c  4941              LDR      r1,|L1.3220|
000b8e  4681              MOV      r9,r0                 ;1731
000b90  2400              MOVS     r4,#0                 ;1734
000b92  f8910024          LDRB     r0,[r1,#0x24]  ; st
000b96  461e              MOV      r6,r3                 ;1731
000b98  4625              MOV      r5,r4                 ;1735
;;;1738           return -1;
000b9a  f04f3bff          MOV      r11,#0xffffffff
000b9e  bbd0              CBNZ     r0,|L1.3094|
;;;1739   
;;;1740       sensors[0] = 0;
000ba0  2000              MOVS     r0,#0
000ba2  7030              STRB     r0,[r6,#0]
;;;1741       if (!st.chip_cfg.sensors)
000ba4  7a88              LDRB     r0,[r1,#0xa]  ; st
000ba6  b3b0              CBZ      r0,|L1.3094|
;;;1742           return -1;
;;;1743       if (!st.chip_cfg.fifo_enable)
000ba8  7c08              LDRB     r0,[r1,#0x10]  ; st
000baa  b3a0              CBZ      r0,|L1.3094|
;;;1744           return -1;
;;;1745   
;;;1746       if (st.chip_cfg.fifo_enable & INV_X_GYRO)
000bac  0642              LSLS     r2,r0,#25
000bae  d500              BPL      |L1.2994|
;;;1747           packet_size += 2;
000bb0  2402              MOVS     r4,#2
                  |L1.2994|
;;;1748       if (st.chip_cfg.fifo_enable & INV_Y_GYRO)
000bb2  0682              LSLS     r2,r0,#26
000bb4  d500              BPL      |L1.3000|
000bb6  1ca4              ADDS     r4,r4,#2
                  |L1.3000|
;;;1749           packet_size += 2;
;;;1750       if (st.chip_cfg.fifo_enable & INV_Z_GYRO)
000bb8  06c2              LSLS     r2,r0,#27
000bba  d500              BPL      |L1.3006|
000bbc  1ca4              ADDS     r4,r4,#2
                  |L1.3006|
;;;1751           packet_size += 2;
;;;1752       if (st.chip_cfg.fifo_enable & INV_XYZ_ACCEL)
000bbe  0700              LSLS     r0,r0,#28
000bc0  d500              BPL      |L1.3012|
000bc2  1da4              ADDS     r4,r4,#6
                  |L1.3012|
;;;1753           packet_size += 6;
;;;1754   
;;;1755       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
000bc4  468a              MOV      r10,r1
000bc6  6809              LDR      r1,[r1,#0]  ; st
000bc8  f8da0004          LDR      r0,[r10,#4]  ; st
000bcc  466b              MOV      r3,sp
000bce  7a89              LDRB     r1,[r1,#0xa]
000bd0  7800              LDRB     r0,[r0,#0]
000bd2  2202              MOVS     r2,#2
000bd4  f7fffffe          BL       dmp_iic_read
000bd8  b9e8              CBNZ     r0,|L1.3094|
;;;1756           return -1;
;;;1757       fifo_count = (data[0] << 8) | data[1];
000bda  f8bd0000          LDRH     r0,[sp,#0]
000bde  ba47              REV16    r7,r0
;;;1758       if (fifo_count < packet_size)
000be0  42a7              CMP      r7,r4
000be2  d363              BCC      |L1.3244|
;;;1759           return 0;
;;;1760   //    log_i("FIFO count: %hd\n", fifo_count);
;;;1761       if (fifo_count > (st.hw->max_fifo >> 1)) {
000be4  f8da0004          LDR      r0,[r10,#4]  ; st
000be8  8841              LDRH     r1,[r0,#2]
000bea  ebb70f51          CMP      r7,r1,LSR #1
000bee  d913              BLS      |L1.3096|
;;;1762           /* FIFO is 50% full, better check overflow bit. */
;;;1763           if (i2c_read(st.hw->addr, st.reg->int_status, 1, data))
000bf0  f8da1000          LDR      r1,[r10,#0]  ; st
000bf4  7800              LDRB     r0,[r0,#0]
000bf6  466b              MOV      r3,sp
000bf8  7c49              LDRB     r1,[r1,#0x11]
000bfa  2201              MOVS     r2,#1
000bfc  f7fffffe          BL       dmp_iic_read
000c00  b948              CBNZ     r0,|L1.3094|
;;;1764               return -1;
;;;1765           if (data[0] & BIT_FIFO_OVERFLOW) {
000c02  f89d0000          LDRB     r0,[sp,#0]
000c06  06c0              LSLS     r0,r0,#27
000c08  d506              BPL      |L1.3096|
;;;1766               mpu_reset_fifo();
000c0a  f7fffffe          BL       mpu_reset_fifo
;;;1767               return -2;
000c0e  f06f0001          MVN      r0,#1
                  |L1.3090|
;;;1768           }
;;;1769       }
;;;1770       get_ms((unsigned long*)timestamp);
;;;1771   
;;;1772       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, packet_size, data))
;;;1773           return -1;
;;;1774       more[0] = fifo_count / packet_size - 1;
;;;1775       sensors[0] = 0;
;;;1776   
;;;1777       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_XYZ_ACCEL) {
;;;1778           accel[0] = (data[index+0] << 8) | data[index+1];
;;;1779           accel[1] = (data[index+2] << 8) | data[index+3];
;;;1780           accel[2] = (data[index+4] << 8) | data[index+5];
;;;1781           sensors[0] |= INV_XYZ_ACCEL;
;;;1782           index += 6;
;;;1783       }
;;;1784       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_X_GYRO) {
;;;1785           gyro[0] = (data[index+0] << 8) | data[index+1];
;;;1786           sensors[0] |= INV_X_GYRO;
;;;1787           index += 2;
;;;1788       }
;;;1789       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Y_GYRO) {
;;;1790           gyro[1] = (data[index+0] << 8) | data[index+1];
;;;1791           sensors[0] |= INV_Y_GYRO;
;;;1792           index += 2;
;;;1793       }
;;;1794       if ((index != packet_size) && st.chip_cfg.fifo_enable & INV_Z_GYRO) {
;;;1795           gyro[2] = (data[index+0] << 8) | data[index+1];
;;;1796           sensors[0] |= INV_Z_GYRO;
;;;1797           index += 2;
;;;1798       }
;;;1799   
;;;1800       return 0;
;;;1801   }
000c12  e8bd8ffe          POP      {r1-r11,pc}
                  |L1.3094|
000c16  e00a              B        |L1.3118|
                  |L1.3096|
000c18  f8da1000          LDR      r1,[r10,#0]           ;1772  ; st
000c1c  f8da0004          LDR      r0,[r10,#4]           ;1772  ; st
000c20  466b              MOV      r3,sp                 ;1772
000c22  7ac9              LDRB     r1,[r1,#0xb]          ;1772
000c24  7800              LDRB     r0,[r0,#0]            ;1772
000c26  4622              MOV      r2,r4                 ;1772
000c28  f7fffffe          BL       dmp_iic_read
000c2c  b108              CBZ      r0,|L1.3122|
                  |L1.3118|
000c2e  4658              MOV      r0,r11                ;1773
000c30  e7ef              B        |L1.3090|
                  |L1.3122|
000c32  fbb7f0f4          UDIV     r0,r7,r4              ;1774
000c36  990c              LDR      r1,[sp,#0x30]         ;1774
000c38  1e40              SUBS     r0,r0,#1              ;1774
000c3a  7008              STRB     r0,[r1,#0]            ;1774
000c3c  2000              MOVS     r0,#0                 ;1775
000c3e  7030              STRB     r0,[r6,#0]            ;1775
000c40  b3a4              CBZ      r4,|L1.3244|
000c42  f89a1010          LDRB     r1,[r10,#0x10]        ;1777  ; st
000c46  4650              MOV      r0,r10                ;1777
000c48  070a              LSLS     r2,r1,#28             ;1777
000c4a  4669              MOV      r1,sp                 ;1733
000c4c  d513              BPL      |L1.3190|
000c4e  f8bd2000          LDRH     r2,[sp,#0]            ;1778
000c52  2506              MOVS     r5,#6                 ;1782
000c54  ba52              REV16    r2,r2                 ;1778
000c56  f8a82000          STRH     r2,[r8,#0]            ;1778
000c5a  f8bd2002          LDRH     r2,[sp,#2]            ;1779
000c5e  ba52              REV16    r2,r2                 ;1779
000c60  f8a82002          STRH     r2,[r8,#2]            ;1779
000c64  f8bd2004          LDRH     r2,[sp,#4]            ;1780
000c68  ba52              REV16    r2,r2                 ;1780
000c6a  f8a82004          STRH     r2,[r8,#4]            ;1780
000c6e  7832              LDRB     r2,[r6,#0]            ;1781
000c70  f0420208          ORR      r2,r2,#8              ;1781
000c74  7032              STRB     r2,[r6,#0]            ;1781
                  |L1.3190|
000c76  42a5              CMP      r5,r4                 ;1784
000c78  d01a              BEQ      |L1.3248|
000c7a  7c02              LDRB     r2,[r0,#0x10]         ;1784  ; st
000c7c  0652              LSLS     r2,r2,#25             ;1784
000c7e  d517              BPL      |L1.3248|
000c80  194a              ADDS     r2,r1,r5              ;1785
000c82  8812              LDRH     r2,[r2,#0]            ;1785
000c84  ba52              REV16    r2,r2                 ;1785
000c86  f8a92000          STRH     r2,[r9,#0]            ;1785
000c8a  7832              LDRB     r2,[r6,#0]            ;1786
000c8c  f0420240          ORR      r2,r2,#0x40           ;1786
000c90  7032              STRB     r2,[r6,#0]            ;1786
000c92  e00c              B        |L1.3246|
                  |L1.3220|
                          DCD      ||.data||
                  |L1.3224|
                          DCD      0x420c0000
                  |L1.3228|
                          DCD      0x43030000
                  |L1.3232|
                          DCD      0x42830000
                  |L1.3236|
                          DCD      0x42033333
                  |L1.3240|
                          DCD      0x41833333
                  |L1.3244|
000cac  e01e              B        |L1.3308|
                  |L1.3246|
000cae  1cad              ADDS     r5,r5,#2              ;1786
                  |L1.3248|
000cb0  42a5              CMP      r5,r4                 ;1789
000cb2  d00c              BEQ      |L1.3278|
000cb4  7c02              LDRB     r2,[r0,#0x10]         ;1789  ; st
000cb6  0692              LSLS     r2,r2,#26             ;1789
000cb8  d509              BPL      |L1.3278|
000cba  194a              ADDS     r2,r1,r5              ;1790
000cbc  1cad              ADDS     r5,r5,#2              ;1791
000cbe  8812              LDRH     r2,[r2,#0]            ;1790
000cc0  ba52              REV16    r2,r2                 ;1790
000cc2  f8a92002          STRH     r2,[r9,#2]            ;1790
000cc6  7832              LDRB     r2,[r6,#0]            ;1791
000cc8  f0420220          ORR      r2,r2,#0x20           ;1791
000ccc  7032              STRB     r2,[r6,#0]            ;1791
                  |L1.3278|
000cce  42a5              CMP      r5,r4                 ;1794
000cd0  d00c              BEQ      |L1.3308|
000cd2  f89a0010          LDRB     r0,[r10,#0x10]        ;1794  ; st
000cd6  06c0              LSLS     r0,r0,#27             ;1794
000cd8  d508              BPL      |L1.3308|
000cda  1948              ADDS     r0,r1,r5              ;1795
000cdc  8800              LDRH     r0,[r0,#0]            ;1795
000cde  ba40              REV16    r0,r0                 ;1795
000ce0  f8a90004          STRH     r0,[r9,#4]            ;1795
000ce4  7830              LDRB     r0,[r6,#0]            ;1796
000ce6  f0400010          ORR      r0,r0,#0x10           ;1796
000cea  7030              STRB     r0,[r6,#0]            ;1796
                  |L1.3308|
000cec  2000              MOVS     r0,#0                 ;1800
000cee  e790              B        |L1.3090|
;;;1802   
                          ENDP

                  mpu_read_fifo_stream PROC
;;;1809    */
;;;1810   int mpu_read_fifo_stream(unsigned short length, unsigned char *data,
000cf0  e92d43f8          PUSH     {r3-r9,lr}
;;;1811       unsigned char *more)
;;;1812   {
;;;1813       unsigned char tmp[2];
;;;1814       unsigned short fifo_count;
;;;1815       if (!st.chip_cfg.dmp_on)
000cf4  4efa              LDR      r6,|L1.4320|
000cf6  4605              MOV      r5,r0                 ;1812
000cf8  4617              MOV      r7,r2                 ;1812
000cfa  f8960024          LDRB     r0,[r6,#0x24]  ; st
000cfe  4689              MOV      r9,r1                 ;1812
;;;1816           return -1;
000d00  f04f38ff          MOV      r8,#0xffffffff
000d04  b388              CBZ      r0,|L1.3434|
;;;1817       if (!st.chip_cfg.sensors)
000d06  7ab0              LDRB     r0,[r6,#0xa]  ; st
000d08  b378              CBZ      r0,|L1.3434|
;;;1818           return -1;
;;;1819   
;;;1820       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, tmp))
000d0a  6830              LDR      r0,[r6,#0]  ; st
000d0c  466b              MOV      r3,sp
000d0e  2202              MOVS     r2,#2
000d10  7a81              LDRB     r1,[r0,#0xa]
000d12  6870              LDR      r0,[r6,#4]  ; st
000d14  7800              LDRB     r0,[r0,#0]
000d16  f7fffffe          BL       dmp_iic_read
000d1a  bb30              CBNZ     r0,|L1.3434|
;;;1821           return -1;
;;;1822       fifo_count = (tmp[0] << 8) | tmp[1];
000d1c  f8bd0000          LDRH     r0,[sp,#0]
000d20  ba44              REV16    r4,r0
;;;1823       if (fifo_count < length) {
000d22  42ac              CMP      r4,r5
000d24  d202              BCS      |L1.3372|
;;;1824           more[0] = 0;
000d26  2000              MOVS     r0,#0
000d28  7038              STRB     r0,[r7,#0]
;;;1825           return -1;
000d2a  e01e              B        |L1.3434|
                  |L1.3372|
;;;1826       }
;;;1827       if (fifo_count > (st.hw->max_fifo >> 1)) {
000d2c  6870              LDR      r0,[r6,#4]  ; st
000d2e  8841              LDRH     r1,[r0,#2]
000d30  ebb40f51          CMP      r4,r1,LSR #1
000d34  d910              BLS      |L1.3416|
;;;1828           /* FIFO is 50% full, better check overflow bit. */
;;;1829           if (i2c_read(st.hw->addr, st.reg->int_status, 1, tmp))
000d36  6831              LDR      r1,[r6,#0]  ; st
000d38  7800              LDRB     r0,[r0,#0]
000d3a  466b              MOV      r3,sp
000d3c  7c49              LDRB     r1,[r1,#0x11]
000d3e  2201              MOVS     r2,#1
000d40  f7fffffe          BL       dmp_iic_read
000d44  b988              CBNZ     r0,|L1.3434|
;;;1830               return -1;
;;;1831           if (tmp[0] & BIT_FIFO_OVERFLOW) {
000d46  f89d0000          LDRB     r0,[sp,#0]
000d4a  06c0              LSLS     r0,r0,#27
000d4c  d504              BPL      |L1.3416|
;;;1832               mpu_reset_fifo();
000d4e  f7fffffe          BL       mpu_reset_fifo
;;;1833               return -2;
000d52  f06f0001          MVN      r0,#1
;;;1834           }
;;;1835       }
;;;1836   
;;;1837       if (i2c_read(st.hw->addr, st.reg->fifo_r_w, length, data))
;;;1838           return -1;
;;;1839       more[0] = fifo_count / length - 1;
;;;1840       return 0;
;;;1841   }
000d56  e40c              B        |L1.1394|
                  |L1.3416|
000d58  6830              LDR      r0,[r6,#0]            ;1837  ; st
000d5a  b2ea              UXTB     r2,r5                 ;1837
000d5c  464b              MOV      r3,r9                 ;1837
000d5e  7ac1              LDRB     r1,[r0,#0xb]          ;1837
000d60  6870              LDR      r0,[r6,#4]            ;1837  ; st
000d62  7800              LDRB     r0,[r0,#0]            ;1837
000d64  f7fffffe          BL       dmp_iic_read
000d68  b108              CBZ      r0,|L1.3438|
                  |L1.3434|
000d6a  4640              MOV      r0,r8                 ;1838
000d6c  e40c              B        |L1.1416|
                  |L1.3438|
000d6e  fbb4f0f5          UDIV     r0,r4,r5              ;1839
000d72  1e40              SUBS     r0,r0,#1              ;1839
000d74  7038              STRB     r0,[r7,#0]            ;1839
000d76  2000              MOVS     r0,#0                 ;1840
000d78  e406              B        |L1.1416|
;;;1842   
                          ENDP

                  mpu_set_int_level PROC
;;;1897    */
;;;1898   int mpu_set_int_level(unsigned char active_low)
000d7a  49d9              LDR      r1,|L1.4320|
;;;1899   {
;;;1900       st.chip_cfg.active_low_int = active_low;
000d7c  f8810022          STRB     r0,[r1,#0x22]
;;;1901       return 0;
000d80  2000              MOVS     r0,#0
;;;1902   }
000d82  4770              BX       lr
;;;1903   
                          ENDP

                  get_st_biases PROC
;;;2059   
;;;2060   static int get_st_biases(long *gyro, long *accel, unsigned char hw_test)
000d84  e92d4ffe          PUSH     {r1-r11,lr}
;;;2061   {
000d88  4605              MOV      r5,r0
;;;2062       unsigned char data[MAX_PACKET_LENGTH];
;;;2063       unsigned char packet_count, ii;
;;;2064       unsigned short fifo_count;
;;;2065   
;;;2066       data[0] = 0x01;
000d8a  2001              MOVS     r0,#1
;;;2067       data[1] = 0;
;;;2068       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
000d8c  4ed4              LDR      r6,|L1.4320|
000d8e  f88d0000          STRB     r0,[sp,#0]            ;2066
000d92  f04f0800          MOV      r8,#0                 ;2067
000d96  f88d8001          STRB     r8,[sp,#1]            ;2067
000d9a  6830              LDR      r0,[r6,#0]  ; st
000d9c  460c              MOV      r4,r1                 ;2061
000d9e  4617              MOV      r7,r2                 ;2061
000da0  7c81              LDRB     r1,[r0,#0x12]
000da2  6870              LDR      r0,[r6,#4]  ; st
000da4  466b              MOV      r3,sp
000da6  2202              MOVS     r2,#2
000da8  7800              LDRB     r0,[r0,#0]
000daa  f7fffffe          BL       dmp_iic_write
;;;2069           return -1;
000dae  f04f3aff          MOV      r10,#0xffffffff
000db2  2800              CMP      r0,#0                 ;2068
                  |L1.3508|
000db4  d17a              BNE      |L1.3756|
;;;2070       delay_ms(200);
000db6  20c8              MOVS     r0,#0xc8
000db8  f7fffffe          BL       vTaskDelay
;;;2071       data[0] = 0;
000dbc  f88d8000          STRB     r8,[sp,#0]
;;;2072       if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
000dc0  6830              LDR      r0,[r6,#0]  ; st
000dc2  466b              MOV      r3,sp
000dc4  2201              MOVS     r2,#1
000dc6  7bc1              LDRB     r1,[r0,#0xf]
000dc8  6870              LDR      r0,[r6,#4]  ; st
000dca  7800              LDRB     r0,[r0,#0]
000dcc  f7fffffe          BL       dmp_iic_write
000dd0  2800              CMP      r0,#0
000dd2  d1ef              BNE      |L1.3508|
;;;2073           return -1;
;;;2074       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
000dd4  6830              LDR      r0,[r6,#0]  ; st
000dd6  466b              MOV      r3,sp
000dd8  2201              MOVS     r2,#1
000dda  7941              LDRB     r1,[r0,#5]
000ddc  6870              LDR      r0,[r6,#4]  ; st
000dde  7800              LDRB     r0,[r0,#0]
000de0  f7fffffe          BL       dmp_iic_write
000de4  2800              CMP      r0,#0
000de6  d1e5              BNE      |L1.3508|
;;;2075           return -1;
;;;2076       if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
000de8  6830              LDR      r0,[r6,#0]  ; st
000dea  466b              MOV      r3,sp
000dec  2201              MOVS     r2,#1
000dee  7c81              LDRB     r1,[r0,#0x12]
000df0  6870              LDR      r0,[r6,#4]  ; st
000df2  7800              LDRB     r0,[r0,#0]
000df4  f7fffffe          BL       dmp_iic_write
000df8  2800              CMP      r0,#0
000dfa  d1db              BNE      |L1.3508|
;;;2077           return -1;
;;;2078       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
000dfc  6830              LDR      r0,[r6,#0]  ; st
000dfe  466b              MOV      r3,sp
000e00  2201              MOVS     r2,#1
000e02  7dc1              LDRB     r1,[r0,#0x17]
000e04  6870              LDR      r0,[r6,#4]  ; st
000e06  7800              LDRB     r0,[r0,#0]
000e08  f7fffffe          BL       dmp_iic_write
000e0c  2800              CMP      r0,#0
000e0e  d1d1              BNE      |L1.3508|
;;;2079           return -1;
;;;2080       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
000e10  6830              LDR      r0,[r6,#0]  ; st
000e12  466b              MOV      r3,sp
000e14  2201              MOVS     r2,#1
000e16  7901              LDRB     r1,[r0,#4]
000e18  6870              LDR      r0,[r6,#4]  ; st
000e1a  7800              LDRB     r0,[r0,#0]
000e1c  f7fffffe          BL       dmp_iic_write
000e20  2800              CMP      r0,#0
000e22  d1c7              BNE      |L1.3508|
;;;2081           return -1;
;;;2082       data[0] = BIT_FIFO_RST | BIT_DMP_RST;
000e24  f04f090c          MOV      r9,#0xc
000e28  f88d9000          STRB     r9,[sp,#0]
;;;2083       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
000e2c  6830              LDR      r0,[r6,#0]  ; st
000e2e  466b              MOV      r3,sp
000e30  2201              MOVS     r2,#1
000e32  7901              LDRB     r1,[r0,#4]
000e34  6870              LDR      r0,[r6,#4]  ; st
000e36  7800              LDRB     r0,[r0,#0]
000e38  f7fffffe          BL       dmp_iic_write
000e3c  2800              CMP      r0,#0
000e3e  d135              BNE      |L1.3756|
;;;2084           return -1;
;;;2085       delay_ms(15);
000e40  200f              MOVS     r0,#0xf
000e42  f7fffffe          BL       vTaskDelay
;;;2086       data[0] = st.test->reg_lpf;
000e46  6ab0              LDR      r0,[r6,#0x28]  ; st
;;;2087       if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
000e48  466b              MOV      r3,sp
000e4a  2201              MOVS     r2,#1
000e4c  7a40              LDRB     r0,[r0,#9]            ;2086
000e4e  f88d0000          STRB     r0,[sp,#0]            ;2086
000e52  6830              LDR      r0,[r6,#0]  ; st
000e54  7881              LDRB     r1,[r0,#2]
000e56  6870              LDR      r0,[r6,#4]  ; st
000e58  7800              LDRB     r0,[r0,#0]
000e5a  f7fffffe          BL       dmp_iic_write
000e5e  2800              CMP      r0,#0
000e60  d124              BNE      |L1.3756|
;;;2088           return -1;
;;;2089       data[0] = st.test->reg_rate_div;
000e62  6ab0              LDR      r0,[r6,#0x28]  ; st
;;;2090       if (i2c_write(st.hw->addr, st.reg->rate_div, 1, data))
000e64  466b              MOV      r3,sp
000e66  2201              MOVS     r2,#1
000e68  7a00              LDRB     r0,[r0,#8]            ;2089
000e6a  f88d0000          STRB     r0,[sp,#0]            ;2089
000e6e  6830              LDR      r0,[r6,#0]  ; st
000e70  7841              LDRB     r1,[r0,#1]
000e72  6870              LDR      r0,[r6,#4]  ; st
000e74  7800              LDRB     r0,[r0,#0]
000e76  f7fffffe          BL       dmp_iic_write
000e7a  2800              CMP      r0,#0
000e7c  d173              BNE      |L1.3942|
;;;2091           return -1;
;;;2092       if (hw_test)
;;;2093           data[0] = st.test->reg_gyro_fsr | 0xE0;
;;;2094       else
;;;2095           data[0] = st.test->reg_gyro_fsr;
000e7e  6ab0              LDR      r0,[r6,#0x28]  ; st
000e80  7a80              LDRB     r0,[r0,#0xa]
000e82  b10f              CBZ      r7,|L1.3720|
000e84  f04000e0          ORR      r0,r0,#0xe0           ;2093
                  |L1.3720|
000e88  f88d0000          STRB     r0,[sp,#0]
;;;2096       if (i2c_write(st.hw->addr, st.reg->gyro_cfg, 1, data))
000e8c  6830              LDR      r0,[r6,#0]  ; st
000e8e  466b              MOV      r3,sp
000e90  2201              MOVS     r2,#1
000e92  7981              LDRB     r1,[r0,#6]
000e94  6870              LDR      r0,[r6,#4]  ; st
000e96  7800              LDRB     r0,[r0,#0]
000e98  f7fffffe          BL       dmp_iic_write
000e9c  2800              CMP      r0,#0
000e9e  d162              BNE      |L1.3942|
;;;2097           return -1;
;;;2098   
;;;2099       if (hw_test)
000ea0  b12f              CBZ      r7,|L1.3758|
;;;2100           data[0] = st.test->reg_accel_fsr | 0xE0;
000ea2  6ab0              LDR      r0,[r6,#0x28]  ; st
000ea4  7ac0              LDRB     r0,[r0,#0xb]
000ea6  f04000e0          ORR      r0,r0,#0xe0
000eaa  e001              B        |L1.3760|
                  |L1.3756|
000eac  e04a              B        |L1.3908|
                  |L1.3758|
;;;2101       else
;;;2102           data[0] = test.reg_accel_fsr;
000eae  2018              MOVS     r0,#0x18
                  |L1.3760|
000eb0  f88d0000          STRB     r0,[sp,#0]
;;;2103       if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
000eb4  6830              LDR      r0,[r6,#0]  ; st
000eb6  466b              MOV      r3,sp
000eb8  2201              MOVS     r2,#1
000eba  79c1              LDRB     r1,[r0,#7]
000ebc  6870              LDR      r0,[r6,#4]  ; st
000ebe  7800              LDRB     r0,[r0,#0]
000ec0  f7fffffe          BL       dmp_iic_write
000ec4  bbf0              CBNZ     r0,|L1.3908|
;;;2104           return -1;
;;;2105       if (hw_test)
000ec6  b117              CBZ      r7,|L1.3790|
;;;2106           delay_ms(200);
000ec8  20c8              MOVS     r0,#0xc8
000eca  f7fffffe          BL       vTaskDelay
                  |L1.3790|
;;;2107   
;;;2108       /* Fill FIFO for test.wait_ms milliseconds. */
;;;2109       data[0] = BIT_FIFO_EN;
000ece  2040              MOVS     r0,#0x40
000ed0  f88d0000          STRB     r0,[sp,#0]
;;;2110       if (i2c_write(st.hw->addr, st.reg->user_ctrl, 1, data))
000ed4  6830              LDR      r0,[r6,#0]  ; st
000ed6  466b              MOV      r3,sp
000ed8  2201              MOVS     r2,#1
000eda  7901              LDRB     r1,[r0,#4]
000edc  6870              LDR      r0,[r6,#4]  ; st
000ede  7800              LDRB     r0,[r0,#0]
000ee0  f7fffffe          BL       dmp_iic_write
000ee4  bb70              CBNZ     r0,|L1.3908|
;;;2111           return -1;
;;;2112   
;;;2113       data[0] = INV_XYZ_GYRO | INV_XYZ_ACCEL;
000ee6  2078              MOVS     r0,#0x78
000ee8  f88d0000          STRB     r0,[sp,#0]
;;;2114       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
000eec  6830              LDR      r0,[r6,#0]  ; st
000eee  466b              MOV      r3,sp
000ef0  2201              MOVS     r2,#1
000ef2  7941              LDRB     r1,[r0,#5]
000ef4  6870              LDR      r0,[r6,#4]  ; st
000ef6  7800              LDRB     r0,[r0,#0]
000ef8  f7fffffe          BL       dmp_iic_write
000efc  bb10              CBNZ     r0,|L1.3908|
;;;2115           return -1;
;;;2116       delay_ms(test.wait_ms);
000efe  2032              MOVS     r0,#0x32
000f00  f7fffffe          BL       vTaskDelay
;;;2117       data[0] = 0;
000f04  f88d8000          STRB     r8,[sp,#0]
;;;2118       if (i2c_write(st.hw->addr, st.reg->fifo_en, 1, data))
000f08  6830              LDR      r0,[r6,#0]  ; st
000f0a  4647              MOV      r7,r8                 ;2117
000f0c  466b              MOV      r3,sp
000f0e  7941              LDRB     r1,[r0,#5]
000f10  6870              LDR      r0,[r6,#4]  ; st
000f12  2201              MOVS     r2,#1
000f14  7800              LDRB     r0,[r0,#0]
000f16  f7fffffe          BL       dmp_iic_write
000f1a  b998              CBNZ     r0,|L1.3908|
;;;2119           return -1;
;;;2120   
;;;2121       if (i2c_read(st.hw->addr, st.reg->fifo_count_h, 2, data))
000f1c  6831              LDR      r1,[r6,#0]  ; st
000f1e  6870              LDR      r0,[r6,#4]  ; st
000f20  46b0              MOV      r8,r6
000f22  7a89              LDRB     r1,[r1,#0xa]
000f24  7800              LDRB     r0,[r0,#0]
000f26  466b              MOV      r3,sp
000f28  2202              MOVS     r2,#2
000f2a  f7fffffe          BL       dmp_iic_read
000f2e  b948              CBNZ     r0,|L1.3908|
;;;2122           return -1;
;;;2123   
;;;2124       fifo_count = (data[0] << 8) | data[1];
000f30  f8bd0000          LDRH     r0,[sp,#0]
;;;2125       packet_count = fifo_count / MAX_PACKET_LENGTH;
;;;2126       gyro[0] = gyro[1] = gyro[2] = 0;
000f34  60af              STR      r7,[r5,#8]
000f36  ba40              REV16    r0,r0                 ;2124
000f38  fbb0f0f9          UDIV     r0,r0,r9              ;2125
000f3c  606f              STR      r7,[r5,#4]
000f3e  b2c6              UXTB     r6,r0                 ;2125
;;;2127       accel[0] = accel[1] = accel[2] = 0;
000f40  602f              STR      r7,[r5,#0]
000f42  e000              B        |L1.3910|
                  |L1.3908|
000f44  e00f              B        |L1.3942|
                  |L1.3910|
000f46  60a7              STR      r7,[r4,#8]
000f48  6067              STR      r7,[r4,#4]
;;;2128   
;;;2129       for (ii = 0; ii < packet_count; ii++) {
000f4a  6027              STR      r7,[r4,#0]
000f4c  2700              MOVS     r7,#0
000f4e  e038              B        |L1.4034|
                  |L1.3920|
;;;2130           short accel_cur[3], gyro_cur[3];
;;;2131           if (i2c_read(st.hw->addr, st.reg->fifo_r_w, MAX_PACKET_LENGTH, data))
000f50  f8d81000          LDR      r1,[r8,#0]  ; st
000f54  f8d80004          LDR      r0,[r8,#4]  ; st
000f58  466b              MOV      r3,sp
000f5a  7ac9              LDRB     r1,[r1,#0xb]
000f5c  7800              LDRB     r0,[r0,#0]
000f5e  220c              MOVS     r2,#0xc
000f60  f7fffffe          BL       dmp_iic_read
000f64  b108              CBZ      r0,|L1.3946|
                  |L1.3942|
;;;2132               return -1;
000f66  4650              MOV      r0,r10
;;;2133           accel_cur[0] = ((short)data[0] << 8) | data[1];
;;;2134           accel_cur[1] = ((short)data[2] << 8) | data[3];
;;;2135           accel_cur[2] = ((short)data[4] << 8) | data[5];
;;;2136           accel[0] += (long)accel_cur[0];
;;;2137           accel[1] += (long)accel_cur[1];
;;;2138           accel[2] += (long)accel_cur[2];
;;;2139           gyro_cur[0] = (((short)data[6] << 8) | data[7]);
;;;2140           gyro_cur[1] = (((short)data[8] << 8) | data[9]);
;;;2141           gyro_cur[2] = (((short)data[10] << 8) | data[11]);
;;;2142           gyro[0] += (long)gyro_cur[0];
;;;2143           gyro[1] += (long)gyro_cur[1];
;;;2144           gyro[2] += (long)gyro_cur[2];
;;;2145       }
;;;2146   #ifdef EMPL_NO_64BIT
;;;2147       gyro[0] = (long)(((float)gyro[0]*65536.f) / test.gyro_sens / packet_count);
;;;2148       gyro[1] = (long)(((float)gyro[1]*65536.f) / test.gyro_sens / packet_count);
;;;2149       gyro[2] = (long)(((float)gyro[2]*65536.f) / test.gyro_sens / packet_count);
;;;2150       if (has_accel) {
;;;2151           accel[0] = (long)(((float)accel[0]*65536.f) / test.accel_sens /
;;;2152               packet_count);
;;;2153           accel[1] = (long)(((float)accel[1]*65536.f) / test.accel_sens /
;;;2154               packet_count);
;;;2155           accel[2] = (long)(((float)accel[2]*65536.f) / test.accel_sens /
;;;2156               packet_count);
;;;2157           /* Don't remove gravity! */
;;;2158           accel[2] -= 65536L;
;;;2159       }
;;;2160   #else
;;;2161       gyro[0] = (long)(((long long)gyro[0]<<16) / test.gyro_sens / packet_count);
;;;2162       gyro[1] = (long)(((long long)gyro[1]<<16) / test.gyro_sens / packet_count);
;;;2163       gyro[2] = (long)(((long long)gyro[2]<<16) / test.gyro_sens / packet_count);
;;;2164       accel[0] = (long)(((long long)accel[0]<<16) / test.accel_sens /
;;;2165           packet_count);
;;;2166       accel[1] = (long)(((long long)accel[1]<<16) / test.accel_sens /
;;;2167           packet_count);
;;;2168       accel[2] = (long)(((long long)accel[2]<<16) / test.accel_sens /
;;;2169           packet_count);
;;;2170       /* Don't remove gravity! */
;;;2171       if (accel[2] > 0L)
;;;2172           accel[2] -= 65536L;
;;;2173       else
;;;2174           accel[2] += 65536L;
;;;2175   #endif
;;;2176   
;;;2177       return 0;
;;;2178   }
000f68  e653              B        |L1.3090|
                  |L1.3946|
000f6a  f8bd0000          LDRH     r0,[sp,#0]            ;2133
000f6e  6823              LDR      r3,[r4,#0]            ;2136
000f70  ba40              REV16    r0,r0                 ;2133
000f72  b202              SXTH     r2,r0                 ;2133
000f74  f8bd0002          LDRH     r0,[sp,#2]            ;2134
000f78  441a              ADD      r2,r2,r3              ;2136
000f7a  ba40              REV16    r0,r0                 ;2134
000f7c  b201              SXTH     r1,r0                 ;2134
000f7e  f8bd0004          LDRH     r0,[sp,#4]            ;2135
000f82  6022              STR      r2,[r4,#0]            ;2137
000f84  6862              LDR      r2,[r4,#4]            ;2137
000f86  ba40              REV16    r0,r0                 ;2135
000f88  4411              ADD      r1,r1,r2              ;2137
000f8a  6061              STR      r1,[r4,#4]            ;2138
000f8c  68a1              LDR      r1,[r4,#8]            ;2138
000f8e  b200              SXTH     r0,r0                 ;2135
000f90  4408              ADD      r0,r0,r1              ;2138
000f92  60a0              STR      r0,[r4,#8]            ;2139
000f94  f8bd0006          LDRH     r0,[sp,#6]            ;2139
000f98  682b              LDR      r3,[r5,#0]            ;2142
000f9a  ba40              REV16    r0,r0                 ;2139
000f9c  b202              SXTH     r2,r0                 ;2139
000f9e  f8bd0008          LDRH     r0,[sp,#8]            ;2140
000fa2  441a              ADD      r2,r2,r3              ;2142
000fa4  ba40              REV16    r0,r0                 ;2140
000fa6  b201              SXTH     r1,r0                 ;2140
000fa8  f8bd000a          LDRH     r0,[sp,#0xa]          ;2141
000fac  602a              STR      r2,[r5,#0]            ;2143
000fae  686a              LDR      r2,[r5,#4]            ;2143
000fb0  ba40              REV16    r0,r0                 ;2141
000fb2  4411              ADD      r1,r1,r2              ;2143
000fb4  6069              STR      r1,[r5,#4]            ;2144
000fb6  68a9              LDR      r1,[r5,#8]            ;2144
000fb8  b200              SXTH     r0,r0                 ;2141
000fba  4408              ADD      r0,r0,r1              ;2144
000fbc  1c7f              ADDS     r7,r7,#1              ;2144
000fbe  b2ff              UXTB     r7,r7                 ;2129
000fc0  60a8              STR      r0,[r5,#8]            ;2129
                  |L1.4034|
000fc2  42b7              CMP      r7,r6                 ;2129
000fc4  d3c4              BCC      |L1.3920|
000fc6  6828              LDR      r0,[r5,#0]            ;2161
000fc8  2283              MOVS     r2,#0x83              ;2161
000fca  17c1              ASRS     r1,r0,#31             ;2161
000fcc  0409              LSLS     r1,r1,#16             ;2161
000fce  ea414110          ORR      r1,r1,r0,LSR #16      ;2161
000fd2  0400              LSLS     r0,r0,#16             ;2161
000fd4  2300              MOVS     r3,#0                 ;2161
000fd6  f7fffffe          BL       __aeabi_ldivmod
000fda  4632              MOV      r2,r6                 ;2161
000fdc  2300              MOVS     r3,#0                 ;2161
000fde  f7fffffe          BL       __aeabi_ldivmod
000fe2  6028              STR      r0,[r5,#0]            ;2162
000fe4  6868              LDR      r0,[r5,#4]            ;2162
000fe6  2283              MOVS     r2,#0x83              ;2162
000fe8  17c1              ASRS     r1,r0,#31             ;2162
000fea  0409              LSLS     r1,r1,#16             ;2162
000fec  ea414110          ORR      r1,r1,r0,LSR #16      ;2162
000ff0  0400              LSLS     r0,r0,#16             ;2162
000ff2  2300              MOVS     r3,#0                 ;2162
000ff4  f7fffffe          BL       __aeabi_ldivmod
000ff8  4632              MOV      r2,r6                 ;2162
000ffa  2300              MOVS     r3,#0                 ;2162
000ffc  f7fffffe          BL       __aeabi_ldivmod
001000  6068              STR      r0,[r5,#4]            ;2163
001002  68a8              LDR      r0,[r5,#8]            ;2163
001004  2283              MOVS     r2,#0x83              ;2163
001006  17c1              ASRS     r1,r0,#31             ;2163
001008  0409              LSLS     r1,r1,#16             ;2163
00100a  ea414110          ORR      r1,r1,r0,LSR #16      ;2163
00100e  0400              LSLS     r0,r0,#16             ;2163
001010  2300              MOVS     r3,#0                 ;2163
001012  f7fffffe          BL       __aeabi_ldivmod
001016  4632              MOV      r2,r6                 ;2163
001018  2300              MOVS     r3,#0                 ;2163
00101a  f7fffffe          BL       __aeabi_ldivmod
00101e  60a8              STR      r0,[r5,#8]            ;2164
001020  6820              LDR      r0,[r4,#0]            ;2164
001022  f44f6500          MOV      r5,#0x800             ;2164
001026  17c1              ASRS     r1,r0,#31             ;2164
001028  0409              LSLS     r1,r1,#16             ;2164
00102a  ea414110          ORR      r1,r1,r0,LSR #16      ;2164
00102e  0400              LSLS     r0,r0,#16             ;2164
001030  462a              MOV      r2,r5                 ;2164
001032  2300              MOVS     r3,#0                 ;2164
001034  f7fffffe          BL       __aeabi_ldivmod
001038  4632              MOV      r2,r6                 ;2164
00103a  2300              MOVS     r3,#0                 ;2164
00103c  f7fffffe          BL       __aeabi_ldivmod
001040  6020              STR      r0,[r4,#0]            ;2166
001042  6860              LDR      r0,[r4,#4]            ;2166
001044  462a              MOV      r2,r5                 ;2166
001046  17c1              ASRS     r1,r0,#31             ;2166
001048  0409              LSLS     r1,r1,#16             ;2166
00104a  ea414110          ORR      r1,r1,r0,LSR #16      ;2166
00104e  0400              LSLS     r0,r0,#16             ;2166
001050  2300              MOVS     r3,#0                 ;2166
001052  f7fffffe          BL       __aeabi_ldivmod
001056  4632              MOV      r2,r6                 ;2166
001058  2300              MOVS     r3,#0                 ;2166
00105a  f7fffffe          BL       __aeabi_ldivmod
00105e  6060              STR      r0,[r4,#4]            ;2168
001060  68a0              LDR      r0,[r4,#8]            ;2168
001062  462a              MOV      r2,r5                 ;2168
001064  17c1              ASRS     r1,r0,#31             ;2168
001066  0409              LSLS     r1,r1,#16             ;2168
001068  ea414110          ORR      r1,r1,r0,LSR #16      ;2168
00106c  0400              LSLS     r0,r0,#16             ;2168
00106e  2300              MOVS     r3,#0                 ;2168
001070  f7fffffe          BL       __aeabi_ldivmod
001074  4632              MOV      r2,r6                 ;2168
001076  2300              MOVS     r3,#0                 ;2168
001078  f7fffffe          BL       __aeabi_ldivmod
00107c  60a0              STR      r0,[r4,#8]            ;2171
00107e  2800              CMP      r0,#0                 ;2171
001080  dd02              BLE      |L1.4232|
001082  f5a03080          SUB      r0,r0,#0x10000        ;2171
001086  e001              B        |L1.4236|
                  |L1.4232|
001088  f5003080          ADD      r0,r0,#0x10000        ;2172
                  |L1.4236|
00108c  60a0              STR      r0,[r4,#8]            ;2177
00108e  2000              MOVS     r0,#0                 ;2177
                  |L1.4240|
001090  e5bf              B        |L1.3090|
;;;2179   
                          ENDP

                  mpu_set_dmp_state PROC
;;;2407    */
;;;2408   int mpu_set_dmp_state(unsigned char enable)
001092  b538              PUSH     {r3-r5,lr}
;;;2409   {
;;;2410       unsigned char tmp;
;;;2411       if (st.chip_cfg.dmp_on == enable)
001094  4c12              LDR      r4,|L1.4320|
001096  f8941024          LDRB     r1,[r4,#0x24]  ; st
00109a  4281              CMP      r1,r0
00109c  d01d              BEQ      |L1.4314|
00109e  2500              MOVS     r5,#0                 ;2409
;;;2412           return 0;
;;;2413   
;;;2414       if (enable) {
0010a0  b1e8              CBZ      r0,|L1.4318|
;;;2415           if (!st.chip_cfg.dmp_loaded)
0010a2  f8940025          LDRB     r0,[r4,#0x25]  ; st
0010a6  b1e8              CBZ      r0,|L1.4324|
;;;2416               return -1;
;;;2417           /* Disable data ready interrupt. */
;;;2418           set_int_enable(0);
0010a8  2000              MOVS     r0,#0
0010aa  f7fffffe          BL       set_int_enable
;;;2419           /* Disable bypass mode. */
;;;2420           mpu_set_bypass(0);
0010ae  2000              MOVS     r0,#0
0010b0  f7fffffe          BL       mpu_set_bypass
;;;2421           /* Keep constant sample rate, FIFO rate controlled by DMP. */
;;;2422           mpu_set_sample_rate(st.chip_cfg.dmp_sample_rate);
0010b4  8ce0              LDRH     r0,[r4,#0x26]  ; st
0010b6  f7fffffe          BL       mpu_set_sample_rate
;;;2423           /* Remove FIFO elements. */
;;;2424           tmp = 0;
0010ba  f88d5000          STRB     r5,[sp,#0]
;;;2425           i2c_write(st.hw->addr, 0x23, 1, &tmp);
0010be  6860              LDR      r0,[r4,#4]  ; st
0010c0  466b              MOV      r3,sp
0010c2  2201              MOVS     r2,#1
0010c4  7800              LDRB     r0,[r0,#0]
0010c6  2123              MOVS     r1,#0x23
0010c8  f7fffffe          BL       dmp_iic_write
;;;2426           st.chip_cfg.dmp_on = 1;
0010cc  2001              MOVS     r0,#1
0010ce  f8840024          STRB     r0,[r4,#0x24]
;;;2427           /* Enable DMP interrupt. */
;;;2428           set_int_enable(1);
0010d2  f7fffffe          BL       set_int_enable
                  |L1.4310|
;;;2429           mpu_reset_fifo();
;;;2430       } else {
;;;2431           /* Disable DMP interrupt. */
;;;2432           set_int_enable(0);
;;;2433           /* Restore FIFO settings. */
;;;2434           tmp = st.chip_cfg.fifo_enable;
;;;2435           i2c_write(st.hw->addr, 0x23, 1, &tmp);
;;;2436           st.chip_cfg.dmp_on = 0;
;;;2437           mpu_reset_fifo();
0010d6  f7fffffe          BL       mpu_reset_fifo
                  |L1.4314|
;;;2438       }
;;;2439       return 0;
0010da  2000              MOVS     r0,#0
                  |L1.4316|
;;;2440   }
0010dc  bd38              POP      {r3-r5,pc}
                  |L1.4318|
0010de  e004              B        |L1.4330|
                  |L1.4320|
                          DCD      ||.data||
                  |L1.4324|
0010e4  f04f30ff          MOV      r0,#0xffffffff        ;2416
0010e8  e7f8              B        |L1.4316|
                  |L1.4330|
0010ea  2000              MOVS     r0,#0                 ;2432
0010ec  f7fffffe          BL       set_int_enable
0010f0  7c20              LDRB     r0,[r4,#0x10]         ;2434  ; st
0010f2  f88d0000          STRB     r0,[sp,#0]            ;2434
0010f6  6860              LDR      r0,[r4,#4]            ;2435  ; st
0010f8  466b              MOV      r3,sp                 ;2435
0010fa  2201              MOVS     r2,#1                 ;2435
0010fc  7800              LDRB     r0,[r0,#0]            ;2435
0010fe  2123              MOVS     r1,#0x23              ;2435
001100  f7fffffe          BL       dmp_iic_write
001104  f8845024          STRB     r5,[r4,#0x24]         ;2436
001108  e7e5              B        |L1.4310|
;;;2441   
                          ENDP

                  mpu_run_self_test PROC
;;;2199    */
;;;2200   int mpu_run_self_test(long *gyro, long *accel)
00110a  e92d47f0          PUSH     {r4-r10,lr}
;;;2201   {
;;;2202   #ifdef MPU6050
;;;2203       const unsigned char tries = 2;
;;;2204       long gyro_st[3], accel_st[3];
;;;2205       unsigned char accel_result, gyro_result;
;;;2206   #ifdef AK89xx_SECONDARY
;;;2207       unsigned char compass_result;
;;;2208   #endif
;;;2209       int ii;
;;;2210   #endif
;;;2211       int result;
;;;2212       unsigned char accel_fsr, fifo_sensors, sensors_on;
;;;2213       unsigned short gyro_fsr, sample_rate, lpf;
;;;2214       unsigned char dmp_was_on;
;;;2215   
;;;2216       if (st.chip_cfg.dmp_on) {
00110e  4ef9              LDR      r6,|L1.5364|
001110  4682              MOV      r10,r0                ;2201
001112  b08a              SUB      sp,sp,#0x28           ;2201
001114  f8960024          LDRB     r0,[r6,#0x24]  ; st
001118  460f              MOV      r7,r1                 ;2201
00111a  b120              CBZ      r0,|L1.4390|
;;;2217           mpu_set_dmp_state(0);
00111c  2000              MOVS     r0,#0
00111e  f7fffffe          BL       mpu_set_dmp_state
;;;2218           dmp_was_on = 1;
001122  2501              MOVS     r5,#1
001124  e000              B        |L1.4392|
                  |L1.4390|
;;;2219       } else
;;;2220           dmp_was_on = 0;
001126  2500              MOVS     r5,#0
                  |L1.4392|
;;;2221   
;;;2222       /* Get initial settings. */
;;;2223       mpu_get_gyro_fsr(&gyro_fsr);
001128  a807              ADD      r0,sp,#0x1c
00112a  f7fffffe          BL       mpu_get_gyro_fsr
;;;2224       mpu_get_accel_fsr(&accel_fsr);
00112e  a806              ADD      r0,sp,#0x18
001130  f7fffffe          BL       mpu_get_accel_fsr
;;;2225       mpu_get_lpf(&lpf);
001134  a809              ADD      r0,sp,#0x24
001136  f7fffffe          BL       mpu_get_lpf
;;;2226       mpu_get_sample_rate(&sample_rate);
00113a  a808              ADD      r0,sp,#0x20
00113c  f7fffffe          BL       mpu_get_sample_rate
;;;2227       sensors_on = st.chip_cfg.sensors;
001140  f896900a          LDRB     r9,[r6,#0xa]  ; st
001144  f8968010          LDRB     r8,[r6,#0x10]  ; st
;;;2228       mpu_get_fifo_config(&fifo_sensors);
;;;2229   
;;;2230       /* For older chips, the self-test will be different. */
;;;2231   #if defined MPU6050
;;;2232       for (ii = 0; ii < tries; ii++)
001148  2400              MOVS     r4,#0
                  |L1.4426|
;;;2233           if (!get_st_biases(gyro, accel, 0))
00114a  2200              MOVS     r2,#0
00114c  4639              MOV      r1,r7
00114e  4650              MOV      r0,r10
001150  f7fffffe          BL       get_st_biases
001154  b110              CBZ      r0,|L1.4444|
001156  1c64              ADDS     r4,r4,#1
001158  2c02              CMP      r4,#2                 ;2232
00115a  dbf6              BLT      |L1.4426|
                  |L1.4444|
;;;2234               break;
;;;2235       if (ii == tries) {
00115c  2c02              CMP      r4,#2
00115e  d01a              BEQ      |L1.4502|
;;;2236           /* If we reach this point, we most likely encountered an I2C error.
;;;2237            * We'll just report an error for all three sensors.
;;;2238            */
;;;2239           result = 0;
;;;2240           goto restore;
;;;2241       }
;;;2242       for (ii = 0; ii < tries; ii++)
001160  2400              MOVS     r4,#0
                  |L1.4450|
;;;2243           if (!get_st_biases(gyro_st, accel_st, 1))
001162  2201              MOVS     r2,#1
001164  a903              ADD      r1,sp,#0xc
001166  4668              MOV      r0,sp
001168  f7fffffe          BL       get_st_biases
00116c  b110              CBZ      r0,|L1.4468|
00116e  1c64              ADDS     r4,r4,#1
001170  2c02              CMP      r4,#2                 ;2242
001172  dbf6              BLT      |L1.4450|
                  |L1.4468|
;;;2244               break;
;;;2245       if (ii == tries) {
001174  2c02              CMP      r4,#2
001176  d00e              BEQ      |L1.4502|
;;;2246           /* Again, probably an I2C error. */
;;;2247           result = 0;
;;;2248           goto restore;
;;;2249       }
;;;2250       accel_result = accel_self_test(accel, accel_st);
001178  a903              ADD      r1,sp,#0xc
00117a  4638              MOV      r0,r7
00117c  f7fffffe          BL       accel_self_test
001180  b2c7              UXTB     r7,r0
;;;2251       gyro_result = gyro_self_test(gyro, gyro_st);
001182  4669              MOV      r1,sp
001184  4650              MOV      r0,r10
001186  f7fffffe          BL       gyro_self_test
00118a  f0100fff          TST      r0,#0xff
;;;2252   
;;;2253       result = 0;
00118e  f04f0400          MOV      r4,#0
;;;2254       if (!gyro_result)
001192  d002              BEQ      |L1.4506|
001194  e002              B        |L1.4508|
                  |L1.4502|
001196  2400              MOVS     r4,#0                 ;2247
001198  e003              B        |L1.4514|
                  |L1.4506|
;;;2255           result |= 0x01;
00119a  2401              MOVS     r4,#1
                  |L1.4508|
;;;2256       if (!accel_result)
00119c  b90f              CBNZ     r7,|L1.4514|
;;;2257           result |= 0x02;
00119e  f0440402          ORR      r4,r4,#2
                  |L1.4514|
;;;2258   
;;;2259   #ifdef AK89xx_SECONDARY
;;;2260       compass_result = compass_self_test();
;;;2261       if (!compass_result)
;;;2262           result |= 0x04;
;;;2263   #endif
;;;2264   restore:
;;;2265   #elif defined MPU6500
;;;2266       /* For now, this function will return a "pass" result for all three sensors
;;;2267        * for compatibility with current test applications.
;;;2268        */
;;;2269       get_st_biases(gyro, accel, 0);
;;;2270       result = 0x7;
;;;2271   #endif
;;;2272       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2273       st.chip_cfg.gyro_fsr = 0xFF;
0011a2  20ff              MOVS     r0,#0xff
0011a4  7230              STRB     r0,[r6,#8]
;;;2274       st.chip_cfg.accel_fsr = 0xFF;
0011a6  7270              STRB     r0,[r6,#9]
;;;2275       st.chip_cfg.lpf = 0xFF;
0011a8  72f0              STRB     r0,[r6,#0xb]
;;;2276       st.chip_cfg.sample_rate = 0xFFFF;
0011aa  f64f71ff          MOV      r1,#0xffff
0011ae  81f1              STRH     r1,[r6,#0xe]
;;;2277       st.chip_cfg.sensors = 0xFF;
0011b0  72b0              STRB     r0,[r6,#0xa]
;;;2278       st.chip_cfg.fifo_enable = 0xFF;
0011b2  7430              STRB     r0,[r6,#0x10]
;;;2279       st.chip_cfg.clk_src = INV_CLK_PLL;
0011b4  2001              MOVS     r0,#1
0011b6  7330              STRB     r0,[r6,#0xc]
;;;2280       mpu_set_gyro_fsr(gyro_fsr);
0011b8  f8bd001c          LDRH     r0,[sp,#0x1c]
0011bc  f7fffffe          BL       mpu_set_gyro_fsr
;;;2281       mpu_set_accel_fsr(accel_fsr);
0011c0  f89d0018          LDRB     r0,[sp,#0x18]
0011c4  f7fffffe          BL       mpu_set_accel_fsr
;;;2282       mpu_set_lpf(lpf);
0011c8  f8bd0024          LDRH     r0,[sp,#0x24]
0011cc  f7fffffe          BL       mpu_set_lpf
;;;2283       mpu_set_sample_rate(sample_rate);
0011d0  f8bd0020          LDRH     r0,[sp,#0x20]
0011d4  f7fffffe          BL       mpu_set_sample_rate
;;;2284       mpu_set_sensors(sensors_on);
0011d8  4648              MOV      r0,r9
0011da  f7fffffe          BL       mpu_set_sensors
0011de  4640              MOV      r0,r8
;;;2285       mpu_configure_fifo(fifo_sensors);
0011e0  f7fffffe          BL       mpu_configure_fifo
;;;2286   
;;;2287       if (dmp_was_on)
0011e4  b115              CBZ      r5,|L1.4588|
;;;2288           mpu_set_dmp_state(1);
0011e6  2001              MOVS     r0,#1
0011e8  f7fffffe          BL       mpu_set_dmp_state
                  |L1.4588|
;;;2289   
;;;2290       return result;
;;;2291   }
0011ec  b00a              ADD      sp,sp,#0x28
0011ee  4620              MOV      r0,r4                 ;2290
0011f0  e8bd87f0          POP      {r4-r10,pc}
;;;2292   
                          ENDP

                  mpu_write_mem PROC
;;;2301    */
;;;2302   int mpu_write_mem(unsigned short mem_addr, unsigned short length,
0011f4  b5f8              PUSH     {r3-r7,lr}
;;;2303           unsigned char *data)
;;;2304   {
0011f6  0017              MOVS     r7,r2
0011f8  460d              MOV      r5,r1
;;;2305       unsigned char tmp[2];
;;;2306   
;;;2307       if (!data)
;;;2308           return -1;
0011fa  f04f34ff          MOV      r4,#0xffffffff
0011fe  d01f              BEQ      |L1.4672|
;;;2309       if (!st.chip_cfg.sensors)
001200  4ebc              LDR      r6,|L1.5364|
001202  7ab1              LDRB     r1,[r6,#0xa]  ; st
001204  b1e1              CBZ      r1,|L1.4672|
;;;2310           return -1;
;;;2311   
;;;2312       tmp[0] = (unsigned char)(mem_addr >> 8);
001206  0a01              LSRS     r1,r0,#8
001208  f88d1000          STRB     r1,[sp,#0]
;;;2313       tmp[1] = (unsigned char)(mem_addr & 0xFF);
00120c  b2c0              UXTB     r0,r0
00120e  f88d0001          STRB     r0,[sp,#1]
;;;2314   
;;;2315       /* Check bank boundaries. */
;;;2316       if (tmp[1] + length > st.hw->bank_size)
001212  1941              ADDS     r1,r0,r5
001214  6870              LDR      r0,[r6,#4]  ; st
001216  8942              LDRH     r2,[r0,#0xa]
001218  4291              CMP      r1,r2
00121a  d811              BHI      |L1.4672|
;;;2317           return -1;
;;;2318   
;;;2319       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
00121c  6831              LDR      r1,[r6,#0]  ; st
00121e  7800              LDRB     r0,[r0,#0]
001220  466b              MOV      r3,sp
001222  7e09              LDRB     r1,[r1,#0x18]
001224  2202              MOVS     r2,#2
001226  f7fffffe          BL       dmp_iic_write
00122a  b948              CBNZ     r0,|L1.4672|
;;;2320           return -1;
;;;2321       if (i2c_write(st.hw->addr, st.reg->mem_r_w, length, data))
00122c  6830              LDR      r0,[r6,#0]  ; st
00122e  b2ea              UXTB     r2,r5
001230  463b              MOV      r3,r7
001232  7d41              LDRB     r1,[r0,#0x15]
001234  6870              LDR      r0,[r6,#4]  ; st
001236  7800              LDRB     r0,[r0,#0]
001238  f7fffffe          BL       dmp_iic_write
00123c  2800              CMP      r0,#0
00123e  d000              BEQ      |L1.4674|
                  |L1.4672|
;;;2322           return -1;
001240  4620              MOV      r0,r4
                  |L1.4674|
;;;2323       return 0;
;;;2324   }
001242  bdf8              POP      {r3-r7,pc}
;;;2325   
                          ENDP

                  mpu_read_mem PROC
;;;2334    */
;;;2335   int mpu_read_mem(unsigned short mem_addr, unsigned short length,
001244  b5f8              PUSH     {r3-r7,lr}
;;;2336           unsigned char *data)
;;;2337   {
001246  0017              MOVS     r7,r2
001248  460d              MOV      r5,r1
;;;2338       unsigned char tmp[2];
;;;2339   
;;;2340       if (!data)
;;;2341           return -1;
00124a  f04f34ff          MOV      r4,#0xffffffff
00124e  d01f              BEQ      |L1.4752|
;;;2342       if (!st.chip_cfg.sensors)
001250  4ea8              LDR      r6,|L1.5364|
001252  7ab1              LDRB     r1,[r6,#0xa]  ; st
001254  b1e1              CBZ      r1,|L1.4752|
;;;2343           return -1;
;;;2344   
;;;2345       tmp[0] = (unsigned char)(mem_addr >> 8);
001256  0a01              LSRS     r1,r0,#8
001258  f88d1000          STRB     r1,[sp,#0]
;;;2346       tmp[1] = (unsigned char)(mem_addr & 0xFF);
00125c  b2c0              UXTB     r0,r0
00125e  f88d0001          STRB     r0,[sp,#1]
;;;2347   
;;;2348       /* Check bank boundaries. */
;;;2349       if (tmp[1] + length > st.hw->bank_size)
001262  1941              ADDS     r1,r0,r5
001264  6870              LDR      r0,[r6,#4]  ; st
001266  8942              LDRH     r2,[r0,#0xa]
001268  4291              CMP      r1,r2
00126a  d811              BHI      |L1.4752|
;;;2350           return -1;
;;;2351   
;;;2352       if (i2c_write(st.hw->addr, st.reg->bank_sel, 2, tmp))
00126c  6831              LDR      r1,[r6,#0]  ; st
00126e  7800              LDRB     r0,[r0,#0]
001270  466b              MOV      r3,sp
001272  7e09              LDRB     r1,[r1,#0x18]
001274  2202              MOVS     r2,#2
001276  f7fffffe          BL       dmp_iic_write
00127a  b948              CBNZ     r0,|L1.4752|
;;;2353           return -1;
;;;2354       if (i2c_read(st.hw->addr, st.reg->mem_r_w, length, data))
00127c  6830              LDR      r0,[r6,#0]  ; st
00127e  b2ea              UXTB     r2,r5
001280  463b              MOV      r3,r7
001282  7d41              LDRB     r1,[r0,#0x15]
001284  6870              LDR      r0,[r6,#4]  ; st
001286  7800              LDRB     r0,[r0,#0]
001288  f7fffffe          BL       dmp_iic_read
00128c  2800              CMP      r0,#0
00128e  d000              BEQ      |L1.4754|
                  |L1.4752|
;;;2355           return -1;
001290  4620              MOV      r0,r4
                  |L1.4754|
;;;2356       return 0;
;;;2357   }
001292  bdf8              POP      {r3-r7,pc}
;;;2358   
                          ENDP

                  mpu_load_firmware PROC
;;;2366    */
;;;2367   int mpu_load_firmware(unsigned short length, const unsigned char *firmware,
001294  e92d4fff          PUSH     {r0-r11,lr}
;;;2368       unsigned short start_addr, unsigned short sample_rate)
;;;2369   {
;;;2370       unsigned short ii;
;;;2371       unsigned short this_write;
;;;2372       /* Must divide evenly into st.hw->bank_size to avoid bank crossings. */
;;;2373   #define LOAD_CHUNK  (16)
;;;2374       unsigned char cur[LOAD_CHUNK], tmp[2];
;;;2375   
;;;2376       if (st.chip_cfg.dmp_loaded)
001298  f8dfa258          LDR      r10,|L1.5364|
00129c  4605              MOV      r5,r0                 ;2369
00129e  b085              SUB      sp,sp,#0x14           ;2369
0012a0  f89a0025          LDRB     r0,[r10,#0x25]  ; st
0012a4  4691              MOV      r9,r2                 ;2369
0012a6  4688              MOV      r8,r1                 ;2369
;;;2377           /* DMP should only be loaded once. */
;;;2378           return -1;
0012a8  f04f3bff          MOV      r11,#0xffffffff
0012ac  bbc0              CBNZ     r0,|L1.4896|
;;;2379   
;;;2380       if (!firmware)
0012ae  f1b80f00          CMP      r8,#0
0012b2  d035              BEQ      |L1.4896|
;;;2381           return -1;
;;;2382       for (ii = 0; ii < length; ii += this_write) {
0012b4  2400              MOVS     r4,#0
0012b6  e01f              B        |L1.4856|
                  |L1.4792|
;;;2383           this_write = min(LOAD_CHUNK, length - ii);
0012b8  1b28              SUBS     r0,r5,r4
0012ba  2810              CMP      r0,#0x10
0012bc  dd00              BLE      |L1.4800|
0012be  2010              MOVS     r0,#0x10
                  |L1.4800|
0012c0  b286              UXTH     r6,r0
;;;2384           if (mpu_write_mem(ii, this_write, (unsigned char*)&firmware[ii]))
0012c2  eb080704          ADD      r7,r8,r4
0012c6  463a              MOV      r2,r7
0012c8  4631              MOV      r1,r6
0012ca  4620              MOV      r0,r4
0012cc  f7fffffe          BL       mpu_write_mem
0012d0  bb30              CBNZ     r0,|L1.4896|
;;;2385               return -1;
;;;2386           if (mpu_read_mem(ii, this_write, cur))
0012d2  466a              MOV      r2,sp
0012d4  4631              MOV      r1,r6
0012d6  4620              MOV      r0,r4
0012d8  f7fffffe          BL       mpu_read_mem
0012dc  bb00              CBNZ     r0,|L1.4896|
0012de  4638              MOV      r0,r7
;;;2387               return -1;
;;;2388           if (memcmp(firmware+ii, cur, this_write))
0012e0  4632              MOV      r2,r6
0012e2  4669              MOV      r1,sp
0012e4  f7fffffe          BL       memcmp
0012e8  b120              CBZ      r0,|L1.4852|
;;;2389               return -2;
0012ea  f06f0001          MVN      r0,#1
                  |L1.4846|
;;;2390       }
;;;2391   
;;;2392       /* Set program start address. */
;;;2393       tmp[0] = start_addr >> 8;
;;;2394       tmp[1] = start_addr & 0xFF;
;;;2395       if (i2c_write(st.hw->addr, st.reg->prgm_start_h, 2, tmp))
;;;2396           return -1;
;;;2397   
;;;2398       st.chip_cfg.dmp_loaded = 1;
;;;2399       st.chip_cfg.dmp_sample_rate = sample_rate;
;;;2400       return 0;
;;;2401   }
0012ee  b009              ADD      sp,sp,#0x24
                  |L1.4848|
0012f0  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.4852|
0012f4  19a0              ADDS     r0,r4,r6              ;2382
0012f6  b284              UXTH     r4,r0                 ;2382
                  |L1.4856|
0012f8  42ac              CMP      r4,r5                 ;2382
0012fa  d3dd              BCC      |L1.4792|
0012fc  ea4f2019          LSR      r0,r9,#8              ;2393
001300  f88d0010          STRB     r0,[sp,#0x10]         ;2393
001304  f88d9011          STRB     r9,[sp,#0x11]         ;2394
001308  f8da0000          LDR      r0,[r10,#0]           ;2395  ; st
00130c  4654              MOV      r4,r10                ;2395
00130e  ab04              ADD      r3,sp,#0x10           ;2395
001310  7e81              LDRB     r1,[r0,#0x1a]         ;2395
001312  f8da0004          LDR      r0,[r10,#4]           ;2395  ; st
001316  2202              MOVS     r2,#2                 ;2395
001318  7800              LDRB     r0,[r0,#0]            ;2395
00131a  f7fffffe          BL       dmp_iic_write
00131e  b108              CBZ      r0,|L1.4900|
                  |L1.4896|
001320  4658              MOV      r0,r11                ;2396
001322  e7e4              B        |L1.4846|
                  |L1.4900|
001324  2001              MOVS     r0,#1                 ;2398
001326  f8840025          STRB     r0,[r4,#0x25]         ;2398
00132a  9808              LDR      r0,[sp,#0x20]         ;2399
00132c  84e0              STRH     r0,[r4,#0x26]         ;2399
00132e  2000              MOVS     r0,#0                 ;2400
001330  e7dd              B        |L1.4846|
;;;2402   
                          ENDP

                  mpu_get_dmp_state PROC
;;;2446    */
;;;2447   int mpu_get_dmp_state(unsigned char *enabled)
001332  4970              LDR      r1,|L1.5364|
;;;2448   {
;;;2449       enabled[0] = st.chip_cfg.dmp_on;
001334  f8911024          LDRB     r1,[r1,#0x24]  ; st
001338  7001              STRB     r1,[r0,#0]
;;;2450       return 0;
00133a  2000              MOVS     r0,#0
;;;2451   }
00133c  4770              BX       lr
;;;2452   
                          ENDP

                  setup_compass PROC
;;;2454   /* This initialization is similar to the one in ak8975.c. */
;;;2455   int setup_compass(void)
00133e  f04f30ff          MOV      r0,#0xffffffff
;;;2456   {
;;;2457   #ifdef AK89xx_SECONDARY
;;;2458       unsigned char data[4], akm_addr;
;;;2459   
;;;2460       mpu_set_bypass(1);
;;;2461   
;;;2462       /* Find compass. Possible addresses range from 0x0C to 0x0F. */
;;;2463       for (akm_addr = 0x0C; akm_addr <= 0x0F; akm_addr++) {
;;;2464           int result;
;;;2465           result = i2c_read(akm_addr, AKM_REG_WHOAMI, 1, data);
;;;2466           if (!result && (data[0] == AKM_WHOAMI))
;;;2467               break;
;;;2468       }
;;;2469   
;;;2470       if (akm_addr > 0x0F) {
;;;2471           /* TODO: Handle this case in all compass-related functions. */
;;;2472           log_e("Compass not found.\n");
;;;2473           return -1;
;;;2474       }
;;;2475   
;;;2476       st.chip_cfg.compass_addr = akm_addr;
;;;2477   
;;;2478       data[0] = AKM_POWER_DOWN;
;;;2479       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2480           return -1;
;;;2481       delay_ms(1);
;;;2482   
;;;2483       data[0] = AKM_FUSE_ROM_ACCESS;
;;;2484       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2485           return -1;
;;;2486       delay_ms(1);
;;;2487   
;;;2488       /* Get sensitivity adjustment data from fuse ROM. */
;;;2489       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ASAX, 3, data))
;;;2490           return -1;
;;;2491       st.chip_cfg.mag_sens_adj[0] = (long)data[0] + 128;
;;;2492       st.chip_cfg.mag_sens_adj[1] = (long)data[1] + 128;
;;;2493       st.chip_cfg.mag_sens_adj[2] = (long)data[2] + 128;
;;;2494   
;;;2495       data[0] = AKM_POWER_DOWN;
;;;2496       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, data))
;;;2497           return -1;
;;;2498       delay_ms(1);
;;;2499   
;;;2500       mpu_set_bypass(0);
;;;2501   
;;;2502       /* Set up master mode, master clock, and ES bit. */
;;;2503       data[0] = 0x40;
;;;2504       if (i2c_write(st.hw->addr, st.reg->i2c_mst, 1, data))
;;;2505           return -1;
;;;2506   
;;;2507       /* Slave 0 reads from AKM data registers. */
;;;2508       data[0] = BIT_I2C_READ | st.chip_cfg.compass_addr;
;;;2509       if (i2c_write(st.hw->addr, st.reg->s0_addr, 1, data))
;;;2510           return -1;
;;;2511   
;;;2512       /* Compass reads start at this register. */
;;;2513       data[0] = AKM_REG_ST1;
;;;2514       if (i2c_write(st.hw->addr, st.reg->s0_reg, 1, data))
;;;2515           return -1;
;;;2516   
;;;2517       /* Enable slave 0, 8-byte reads. */
;;;2518       data[0] = BIT_SLAVE_EN | 8;
;;;2519       if (i2c_write(st.hw->addr, st.reg->s0_ctrl, 1, data))
;;;2520           return -1;
;;;2521   
;;;2522       /* Slave 1 changes AKM measurement mode. */
;;;2523       data[0] = st.chip_cfg.compass_addr;
;;;2524       if (i2c_write(st.hw->addr, st.reg->s1_addr, 1, data))
;;;2525           return -1;
;;;2526   
;;;2527       /* AKM measurement mode register. */
;;;2528       data[0] = AKM_REG_CNTL;
;;;2529       if (i2c_write(st.hw->addr, st.reg->s1_reg, 1, data))
;;;2530           return -1;
;;;2531   
;;;2532       /* Enable slave 1, 1-byte writes. */
;;;2533       data[0] = BIT_SLAVE_EN | 1;
;;;2534       if (i2c_write(st.hw->addr, st.reg->s1_ctrl, 1, data))
;;;2535           return -1;
;;;2536   
;;;2537       /* Set slave 1 data. */
;;;2538       data[0] = AKM_SINGLE_MEASUREMENT;
;;;2539       if (i2c_write(st.hw->addr, st.reg->s1_do, 1, data))
;;;2540           return -1;
;;;2541   
;;;2542       /* Trigger slave 0 and slave 1 actions at each sample. */
;;;2543       data[0] = 0x03;
;;;2544       if (i2c_write(st.hw->addr, st.reg->i2c_delay_ctrl, 1, data))
;;;2545           return -1;
;;;2546   
;;;2547   #ifdef MPU9150
;;;2548       /* For the MPU9150, the auxiliary I2C bus needs to be set to VDD. */
;;;2549       data[0] = BIT_I2C_MST_VDDIO;
;;;2550       if (i2c_write(st.hw->addr, st.reg->yg_offs_tc, 1, data))
;;;2551           return -1;
;;;2552   #endif
;;;2553   
;;;2554       return 0;
;;;2555   #else
;;;2556       return -1;
;;;2557   #endif
;;;2558   }
001342  4770              BX       lr
;;;2559   
                          ENDP

                  mpu_get_compass_reg PROC
;;;2565    */
;;;2566   int mpu_get_compass_reg(short *data, unsigned long *timestamp)
001344  f04f30ff          MOV      r0,#0xffffffff
;;;2567   {
;;;2568   #ifdef AK89xx_SECONDARY
;;;2569       unsigned char tmp[9];
;;;2570   
;;;2571       if (!(st.chip_cfg.sensors & INV_XYZ_COMPASS))
;;;2572           return -1;
;;;2573   
;;;2574   #ifdef AK89xx_BYPASS
;;;2575       if (i2c_read(st.chip_cfg.compass_addr, AKM_REG_ST1, 8, tmp))
;;;2576           return -1;
;;;2577       tmp[8] = AKM_SINGLE_MEASUREMENT;
;;;2578       if (i2c_write(st.chip_cfg.compass_addr, AKM_REG_CNTL, 1, tmp+8))
;;;2579           return -1;
;;;2580   #else
;;;2581       if (i2c_read(st.hw->addr, st.reg->raw_compass, 8, tmp))
;;;2582           return -1;
;;;2583   #endif
;;;2584   
;;;2585   #if defined AK8975_SECONDARY
;;;2586       /* AK8975 doesn't have the overrun error bit. */
;;;2587       if (!(tmp[0] & AKM_DATA_READY))
;;;2588           return -2;
;;;2589       if ((tmp[7] & AKM_OVERFLOW) || (tmp[7] & AKM_DATA_ERROR))
;;;2590           return -3;
;;;2591   #elif defined AK8963_SECONDARY
;;;2592       /* AK8963 doesn't have the data read error bit. */
;;;2593       if (!(tmp[0] & AKM_DATA_READY) || (tmp[0] & AKM_DATA_OVERRUN))
;;;2594           return -2;
;;;2595       if (tmp[7] & AKM_OVERFLOW)
;;;2596           return -3;
;;;2597   #endif
;;;2598       data[0] = (tmp[2] << 8) | tmp[1];
;;;2599       data[1] = (tmp[4] << 8) | tmp[3];
;;;2600       data[2] = (tmp[6] << 8) | tmp[5];
;;;2601   
;;;2602       data[0] = ((long)data[0] * st.chip_cfg.mag_sens_adj[0]) >> 8;
;;;2603       data[1] = ((long)data[1] * st.chip_cfg.mag_sens_adj[1]) >> 8;
;;;2604       data[2] = ((long)data[2] * st.chip_cfg.mag_sens_adj[2]) >> 8;
;;;2605   
;;;2606       if (timestamp)
;;;2607           get_ms(timestamp);
;;;2608       return 0;
;;;2609   #else
;;;2610       return -1;
;;;2611   #endif
;;;2612   }
001348  4770              BX       lr
;;;2613   
                          ENDP

                  mpu_get_compass_fsr PROC
;;;2618    */
;;;2619   int mpu_get_compass_fsr(unsigned short *fsr)
00134a  f04f30ff          MOV      r0,#0xffffffff
;;;2620   {
;;;2621   #ifdef AK89xx_SECONDARY
;;;2622       fsr[0] = st.hw->compass_fsr;
;;;2623       return 0;
;;;2624   #else
;;;2625       return -1;
;;;2626   #endif
;;;2627   }
00134e  4770              BX       lr
;;;2628   
                          ENDP

                  mpu_lp_motion_interrupt PROC
;;;2672    */
;;;2673   int mpu_lp_motion_interrupt(unsigned short thresh, unsigned char time,
001350  e92d4ff8          PUSH     {r3-r11,lr}
;;;2674       unsigned char lpa_freq)
;;;2675   {
;;;2676       unsigned char data[3];
;;;2677   
;;;2678       if (lpa_freq) {
;;;2679           unsigned char thresh_hw;
;;;2680   
;;;2681   #if defined MPU6050
;;;2682           /* TODO: Make these const/#defines. */
;;;2683           /* 1LSb = 32mg. */
;;;2684           if (thresh > 8160)
;;;2685               thresh_hw = 255;
;;;2686           else if (thresh < 32)
;;;2687               thresh_hw = 1;
;;;2688           else
;;;2689               thresh_hw = thresh >> 5;
;;;2690   #elif defined MPU6500
;;;2691           /* 1LSb = 4mg. */
;;;2692           if (thresh > 1020)
;;;2693               thresh_hw = 255;
;;;2694           else if (thresh < 4)
;;;2695               thresh_hw = 1;
;;;2696           else
;;;2697               thresh_hw = thresh >> 2;
;;;2698   #endif
;;;2699   
;;;2700           if (!time)
;;;2701               /* Minimum duration must be 1ms. */
;;;2702               time = 1;
;;;2703   
;;;2704   #if defined MPU6050
;;;2705           if (lpa_freq > 40)
;;;2706   #elif defined MPU6500
;;;2707           if (lpa_freq > 640)
;;;2708   #endif
;;;2709               /* At this point, the chip has not been re-configured, so the
;;;2710                * function can safely exit.
;;;2711                */
;;;2712               return -1;
;;;2713   
;;;2714           if (!st.chip_cfg.int_motion_only) {
001354  4c67              LDR      r4,|L1.5364|
001356  460f              MOV      r7,r1                 ;2675
;;;2715               /* Store current settings for later. */
;;;2716               if (st.chip_cfg.dmp_on) {
;;;2717                   mpu_set_dmp_state(0);
;;;2718                   st.chip_cfg.cache.dmp_on = 1;
;;;2719               } else
;;;2720                   st.chip_cfg.cache.dmp_on = 0;
;;;2721               mpu_get_gyro_fsr(&st.chip_cfg.cache.gyro_fsr);
001358  f1040116          ADD      r1,r4,#0x16
00135c  0015              MOVS     r5,r2                 ;2675
00135e  f04f3bff          MOV      r11,#0xffffffff       ;2712
001362  468a              MOV      r10,r1
001364  f04f0900          MOV      r9,#0
001368  f04f0801          MOV      r8,#1                 ;2687
00136c  d077              BEQ      |L1.5214|
00136e  f5b05fff          CMP      r0,#0x1fe0            ;2684
001372  d901              BLS      |L1.4984|
001374  26ff              MOVS     r6,#0xff              ;2685
001376  e005              B        |L1.4996|
                  |L1.4984|
001378  2820              CMP      r0,#0x20              ;2686
00137a  d201              BCS      |L1.4992|
00137c  2601              MOVS     r6,#1                 ;2687
00137e  e001              B        |L1.4996|
                  |L1.4992|
001380  f3c01647          UBFX     r6,r0,#5,#8           ;2689
                  |L1.4996|
001384  b907              CBNZ     r7,|L1.5000|
001386  2701              MOVS     r7,#1                 ;2702
                  |L1.5000|
001388  2d28              CMP      r5,#0x28              ;2705
00138a  d86a              BHI      |L1.5218|
00138c  7d60              LDRB     r0,[r4,#0x15]         ;2714  ; st
00138e  b9f0              CBNZ     r0,|L1.5070|
001390  f8940024          LDRB     r0,[r4,#0x24]         ;2716  ; st
001394  b128              CBZ      r0,|L1.5026|
001396  2000              MOVS     r0,#0                 ;2717
001398  f7fffffe          BL       mpu_set_dmp_state
00139c  f8848020          STRB     r8,[r4,#0x20]         ;2718
0013a0  e001              B        |L1.5030|
                  |L1.5026|
0013a2  f8849020          STRB     r9,[r4,#0x20]         ;2720
                  |L1.5030|
0013a6  4650              MOV      r0,r10                ;2720
0013a8  f7fffffe          BL       mpu_get_gyro_fsr
;;;2722               mpu_get_accel_fsr(&st.chip_cfg.cache.accel_fsr);
0013ac  4851              LDR      r0,|L1.5364|
0013ae  3018              ADDS     r0,r0,#0x18
0013b0  f7fffffe          BL       mpu_get_accel_fsr
;;;2723               mpu_get_lpf(&st.chip_cfg.cache.lpf);
0013b4  484f              LDR      r0,|L1.5364|
0013b6  301a              ADDS     r0,r0,#0x1a
0013b8  f7fffffe          BL       mpu_get_lpf
;;;2724               mpu_get_sample_rate(&st.chip_cfg.cache.sample_rate);
0013bc  484d              LDR      r0,|L1.5364|
0013be  301c              ADDS     r0,r0,#0x1c
0013c0  f7fffffe          BL       mpu_get_sample_rate
;;;2725               st.chip_cfg.cache.sensors_on = st.chip_cfg.sensors;
0013c4  7aa0              LDRB     r0,[r4,#0xa]  ; st
0013c6  77a0              STRB     r0,[r4,#0x1e]
;;;2726               mpu_get_fifo_config(&st.chip_cfg.cache.fifo_sensors);
0013c8  484a              LDR      r0,|L1.5364|
0013ca  7c21              LDRB     r1,[r4,#0x10]  ; st
0013cc  77c1              STRB     r1,[r0,#0x1f]
                  |L1.5070|
;;;2727           }
;;;2728   
;;;2729   #ifdef MPU6050
;;;2730           /* Disable hardware interrupts for now. */
;;;2731           set_int_enable(0);
0013ce  2000              MOVS     r0,#0
0013d0  f7fffffe          BL       set_int_enable
;;;2732   
;;;2733           /* Enter full-power accel-only mode. */
;;;2734           mpu_lp_accel_mode(0);
0013d4  2000              MOVS     r0,#0
0013d6  f7fffffe          BL       mpu_lp_accel_mode
;;;2735   
;;;2736           /* Override current LPF (and HPF) settings to obtain a valid accel
;;;2737            * reading.
;;;2738            */
;;;2739           data[0] = INV_FILTER_256HZ_NOLPF2;
0013da  f88d9000          STRB     r9,[sp,#0]
;;;2740           if (i2c_write(st.hw->addr, st.reg->lpf, 1, data))
0013de  6820              LDR      r0,[r4,#0]  ; st
0013e0  466b              MOV      r3,sp
0013e2  2201              MOVS     r2,#1
0013e4  7881              LDRB     r1,[r0,#2]
0013e6  6860              LDR      r0,[r4,#4]  ; st
0013e8  7800              LDRB     r0,[r0,#0]
0013ea  f7fffffe          BL       dmp_iic_write
0013ee  2800              CMP      r0,#0
0013f0  d137              BNE      |L1.5218|
;;;2741               return -1;
;;;2742   
;;;2743           /* NOTE: Digital high pass filter should be configured here. Since this
;;;2744            * driver doesn't modify those bits anywhere, they should already be
;;;2745            * cleared by default.
;;;2746            */
;;;2747   
;;;2748           /* Configure the device to send motion interrupts. */
;;;2749           /* Enable motion interrupt. */
;;;2750           data[0] = BIT_MOT_INT_EN;
0013f2  2040              MOVS     r0,#0x40
0013f4  f88d0000          STRB     r0,[sp,#0]
;;;2751           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
0013f8  6820              LDR      r0,[r4,#0]  ; st
0013fa  466b              MOV      r3,sp
0013fc  2201              MOVS     r2,#1
0013fe  7bc1              LDRB     r1,[r0,#0xf]
001400  6860              LDR      r0,[r4,#4]  ; st
001402  7800              LDRB     r0,[r0,#0]
001404  f7fffffe          BL       dmp_iic_write
001408  bb50              CBNZ     r0,|L1.5216|
;;;2752               goto lp_int_restore;
;;;2753   
;;;2754           /* Set motion interrupt parameters. */
;;;2755           data[0] = thresh_hw;
00140a  f88d6000          STRB     r6,[sp,#0]
;;;2756           data[1] = time;
00140e  f88d7001          STRB     r7,[sp,#1]
;;;2757           if (i2c_write(st.hw->addr, st.reg->motion_thr, 2, data))
001412  6820              LDR      r0,[r4,#0]  ; st
001414  466b              MOV      r3,sp
001416  2202              MOVS     r2,#2
001418  7a01              LDRB     r1,[r0,#8]
00141a  6860              LDR      r0,[r4,#4]  ; st
00141c  7800              LDRB     r0,[r0,#0]
00141e  f7fffffe          BL       dmp_iic_write
001422  b9e8              CBNZ     r0,|L1.5216|
;;;2758               goto lp_int_restore;
;;;2759   
;;;2760           /* Force hardware to "lock" current accel sample. */
;;;2761           delay_ms(5);
001424  2005              MOVS     r0,#5
001426  f7fffffe          BL       vTaskDelay
;;;2762           data[0] = (st.chip_cfg.accel_fsr << 3) | BITS_HPF;
00142a  7a60              LDRB     r0,[r4,#9]  ; st
00142c  2607              MOVS     r6,#7
00142e  eb0600c0          ADD      r0,r6,r0,LSL #3
001432  f88d0000          STRB     r0,[sp,#0]
;;;2763           if (i2c_write(st.hw->addr, st.reg->accel_cfg, 1, data))
001436  6820              LDR      r0,[r4,#0]  ; st
001438  466b              MOV      r3,sp
00143a  2201              MOVS     r2,#1
00143c  79c1              LDRB     r1,[r0,#7]
00143e  6860              LDR      r0,[r4,#4]  ; st
001440  7800              LDRB     r0,[r0,#0]
001442  f7fffffe          BL       dmp_iic_write
001446  b958              CBNZ     r0,|L1.5216|
;;;2764               goto lp_int_restore;
;;;2765   
;;;2766           /* Set up LP accel mode. */
;;;2767           data[0] = BIT_LPA_CYCLE;
001448  2020              MOVS     r0,#0x20
00144a  f88d0000          STRB     r0,[sp,#0]
;;;2768           if (lpa_freq == 1)
00144e  2d01              CMP      r5,#1
001450  d008              BEQ      |L1.5220|
;;;2769               data[1] = INV_LPA_1_25HZ;
;;;2770           else if (lpa_freq <= 5)
001452  2d05              CMP      r5,#5
001454  d80a              BHI      |L1.5228|
;;;2771               data[1] = INV_LPA_5HZ;
001456  4640              MOV      r0,r8
001458  f88d8001          STRB     r8,[sp,#1]
00145c  e00d              B        |L1.5242|
                  |L1.5214|
00145e  e01d              B        |L1.5276|
                  |L1.5216|
001460  e01f              B        |L1.5282|
                  |L1.5218|
001462  e04c              B        |L1.5374|
                  |L1.5220|
001464  4648              MOV      r0,r9                 ;2769
001466  f88d9001          STRB     r9,[sp,#1]            ;2769
00146a  e006              B        |L1.5242|
                  |L1.5228|
;;;2772           else if (lpa_freq <= 20)
00146c  2d14              CMP      r5,#0x14
00146e  d801              BHI      |L1.5236|
;;;2773               data[1] = INV_LPA_20HZ;
001470  2002              MOVS     r0,#2
001472  e000              B        |L1.5238|
                  |L1.5236|
;;;2774           else
;;;2775               data[1] = INV_LPA_40HZ;
001474  2003              MOVS     r0,#3
                  |L1.5238|
001476  f88d0001          STRB     r0,[sp,#1]            ;2773
                  |L1.5242|
;;;2776           data[1] = (data[1] << 6) | BIT_STBY_XYZG;
00147a  b2c0              UXTB     r0,r0
00147c  eb061080          ADD      r0,r6,r0,LSL #6
001480  f88d0001          STRB     r0,[sp,#1]
;;;2777           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 2, data))
001484  6820              LDR      r0,[r4,#0]  ; st
001486  466b              MOV      r3,sp
001488  2202              MOVS     r2,#2
00148a  7c81              LDRB     r1,[r0,#0x12]
00148c  6860              LDR      r0,[r4,#4]  ; st
00148e  7800              LDRB     r0,[r0,#0]
001490  f7fffffe          BL       dmp_iic_write
001494  b928              CBNZ     r0,|L1.5282|
;;;2778               goto lp_int_restore;
;;;2779   
;;;2780           st.chip_cfg.int_motion_only = 1;
001496  f8848015          STRB     r8,[r4,#0x15]
;;;2781           return 0;
00149a  e027              B        |L1.5356|
                  |L1.5276|
;;;2782   #elif defined MPU6500
;;;2783           /* Disable hardware interrupts. */
;;;2784           set_int_enable(0);
;;;2785   
;;;2786           /* Enter full-power accel-only mode, no FIFO/DMP. */
;;;2787           data[0] = 0;
;;;2788           data[1] = 0;
;;;2789           data[2] = BIT_STBY_XYZG;
;;;2790           if (i2c_write(st.hw->addr, st.reg->user_ctrl, 3, data))
;;;2791               goto lp_int_restore;
;;;2792   
;;;2793           /* Set motion threshold. */
;;;2794           data[0] = thresh_hw;
;;;2795           if (i2c_write(st.hw->addr, st.reg->motion_thr, 1, data))
;;;2796               goto lp_int_restore;
;;;2797   
;;;2798           /* Set wake frequency. */
;;;2799           if (lpa_freq == 1)
;;;2800               data[0] = INV_LPA_1_25HZ;
;;;2801           else if (lpa_freq == 2)
;;;2802               data[0] = INV_LPA_2_5HZ;
;;;2803           else if (lpa_freq <= 5)
;;;2804               data[0] = INV_LPA_5HZ;
;;;2805           else if (lpa_freq <= 10)
;;;2806               data[0] = INV_LPA_10HZ;
;;;2807           else if (lpa_freq <= 20)
;;;2808               data[0] = INV_LPA_20HZ;
;;;2809           else if (lpa_freq <= 40)
;;;2810               data[0] = INV_LPA_40HZ;
;;;2811           else if (lpa_freq <= 80)
;;;2812               data[0] = INV_LPA_80HZ;
;;;2813           else if (lpa_freq <= 160)
;;;2814               data[0] = INV_LPA_160HZ;
;;;2815           else if (lpa_freq <= 320)
;;;2816               data[0] = INV_LPA_320HZ;
;;;2817           else
;;;2818               data[0] = INV_LPA_640HZ;
;;;2819           if (i2c_write(st.hw->addr, st.reg->lp_accel_odr, 1, data))
;;;2820               goto lp_int_restore;
;;;2821   
;;;2822           /* Enable motion interrupt (MPU6500 version). */
;;;2823           data[0] = BITS_WOM_EN;
;;;2824           if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2825               goto lp_int_restore;
;;;2826   
;;;2827           /* Enable cycle mode. */
;;;2828           data[0] = BIT_LPA_CYCLE;
;;;2829           if (i2c_write(st.hw->addr, st.reg->pwr_mgmt_1, 1, data))
;;;2830               goto lp_int_restore;
;;;2831   
;;;2832           /* Enable interrupt. */
;;;2833           data[0] = BIT_MOT_INT_EN;
;;;2834           if (i2c_write(st.hw->addr, st.reg->int_enable, 1, data))
;;;2835               goto lp_int_restore;
;;;2836   
;;;2837           st.chip_cfg.int_motion_only = 1;
;;;2838           return 0;
;;;2839   #endif
;;;2840       } else {
;;;2841           /* Don't "restore" the previous state if no state has been saved. */
;;;2842           int ii;
;;;2843           char *cache_ptr = (char*)&st.chip_cfg.cache;
;;;2844           for (ii = 0; ii < sizeof(st.chip_cfg.cache); ii++) {
00149c  2000              MOVS     r0,#0
                  |L1.5278|
;;;2845               if (cache_ptr[ii] != 0)
00149e  5c0a              LDRB     r2,[r1,r0]
0014a0  b33a              CBZ      r2,|L1.5362|
                  |L1.5282|
;;;2846                   goto lp_int_restore;
;;;2847           }
;;;2848           /* If we reach this point, motion interrupt mode hasn't been used yet. */
;;;2849           return -1;
;;;2850       }
;;;2851   lp_int_restore:
;;;2852       /* Set to invalid values to ensure no I2C writes are skipped. */
;;;2853       st.chip_cfg.gyro_fsr = 0xFF;
0014a2  20ff              MOVS     r0,#0xff
0014a4  7220              STRB     r0,[r4,#8]
;;;2854       st.chip_cfg.accel_fsr = 0xFF;
0014a6  7260              STRB     r0,[r4,#9]
;;;2855       st.chip_cfg.lpf = 0xFF;
0014a8  72e0              STRB     r0,[r4,#0xb]
;;;2856       st.chip_cfg.sample_rate = 0xFFFF;
0014aa  f64f71ff          MOV      r1,#0xffff
0014ae  81e1              STRH     r1,[r4,#0xe]
;;;2857       st.chip_cfg.sensors = 0xFF;
0014b0  72a0              STRB     r0,[r4,#0xa]
;;;2858       st.chip_cfg.fifo_enable = 0xFF;
0014b2  7420              STRB     r0,[r4,#0x10]
;;;2859       st.chip_cfg.clk_src = INV_CLK_PLL;
0014b4  f884800c          STRB     r8,[r4,#0xc]
;;;2860       mpu_set_sensors(st.chip_cfg.cache.sensors_on);
0014b8  7fa0              LDRB     r0,[r4,#0x1e]  ; st
0014ba  f7fffffe          BL       mpu_set_sensors
;;;2861       mpu_set_gyro_fsr(st.chip_cfg.cache.gyro_fsr);
0014be  8ae0              LDRH     r0,[r4,#0x16]  ; st
0014c0  f7fffffe          BL       mpu_set_gyro_fsr
;;;2862       mpu_set_accel_fsr(st.chip_cfg.cache.accel_fsr);
0014c4  7e20              LDRB     r0,[r4,#0x18]  ; st
0014c6  f7fffffe          BL       mpu_set_accel_fsr
;;;2863       mpu_set_lpf(st.chip_cfg.cache.lpf);
0014ca  8b60              LDRH     r0,[r4,#0x1a]  ; st
0014cc  f7fffffe          BL       mpu_set_lpf
;;;2864       mpu_set_sample_rate(st.chip_cfg.cache.sample_rate);
0014d0  8ba0              LDRH     r0,[r4,#0x1c]  ; st
0014d2  f7fffffe          BL       mpu_set_sample_rate
;;;2865       mpu_configure_fifo(st.chip_cfg.cache.fifo_sensors);
0014d6  7fe0              LDRB     r0,[r4,#0x1f]  ; st
0014d8  f7fffffe          BL       mpu_configure_fifo
;;;2866   
;;;2867       if (st.chip_cfg.cache.dmp_on)
0014dc  f8940020          LDRB     r0,[r4,#0x20]  ; st
0014e0  b110              CBZ      r0,|L1.5352|
;;;2868           mpu_set_dmp_state(1);
0014e2  2001              MOVS     r0,#1
0014e4  f7fffffe          BL       mpu_set_dmp_state
                  |L1.5352|
;;;2869   
;;;2870   #ifdef MPU6500
;;;2871       /* Disable motion interrupt (MPU6500 version). */
;;;2872       data[0] = 0;
;;;2873       if (i2c_write(st.hw->addr, st.reg->accel_intel, 1, data))
;;;2874           goto lp_int_restore;
;;;2875   #endif
;;;2876   
;;;2877       st.chip_cfg.int_motion_only = 0;
0014e8  f8849015          STRB     r9,[r4,#0x15]
                  |L1.5356|
;;;2878       return 0;
0014ec  2000              MOVS     r0,#0
                  |L1.5358|
;;;2879   }
0014ee  e8bd8ff8          POP      {r3-r11,pc}
                  |L1.5362|
0014f2  e001              B        |L1.5368|
                  |L1.5364|
                          DCD      ||.data||
                  |L1.5368|
0014f8  1c40              ADDS     r0,r0,#1
0014fa  280c              CMP      r0,#0xc               ;2844
0014fc  d3cf              BCC      |L1.5278|
                  |L1.5374|
0014fe  4658              MOV      r0,r11                ;2849
001500  e7f5              B        |L1.5358|
;;;2880   //////////////////////////////////////////////////////////////////////////////////
                          ENDP

                  run_self_test PROC
;;;2904   //    其他,失败
;;;2905   u8 run_self_test(void)
001502  b510              PUSH     {r4,lr}
;;;2906   {
001504  b088              SUB      sp,sp,#0x20
;;;2907   	int result;
;;;2908   	//char test_packet[4] = {0};
;;;2909   	long gyro[3], accel[3]; 
;;;2910   	result = mpu_run_self_test(gyro, accel);
001506  a902              ADD      r1,sp,#8
001508  a805              ADD      r0,sp,#0x14
00150a  f7fffffe          BL       mpu_run_self_test
;;;2911   	if (result == 0x7) 
00150e  2807              CMP      r0,#7
001510  d002              BEQ      |L1.5400|
;;;2912   	{
;;;2913   		/* Test passed. We can trust the gyro data here, so let's push it down
;;;2914   		* to the DMP.
;;;2915   		*/
;;;2916   		float sens;
;;;2917   		unsigned short accel_sens;
;;;2918   		mpu_get_gyro_sens(&sens);
;;;2919   		gyro[0] = (long)(gyro[0] * sens);
;;;2920   		gyro[1] = (long)(gyro[1] * sens);
;;;2921   		gyro[2] = (long)(gyro[2] * sens);
;;;2922   		dmp_set_gyro_bias(gyro);
;;;2923   		mpu_get_accel_sens(&accel_sens);
;;;2924   		accel[0] *= accel_sens;
;;;2925   		accel[1] *= accel_sens;
;;;2926   		accel[2] *= accel_sens;
;;;2927   		dmp_set_accel_bias(accel);
;;;2928   		return 0;
;;;2929   	}else return 1;
001512  2001              MOVS     r0,#1
                  |L1.5396|
;;;2930   }
001514  b008              ADD      sp,sp,#0x20
001516  bd10              POP      {r4,pc}
                  |L1.5400|
001518  4668              MOV      r0,sp                 ;2918
00151a  f7fffffe          BL       mpu_get_gyro_sens
00151e  9805              LDR      r0,[sp,#0x14]         ;2919
001520  f7fffffe          BL       __aeabi_i2f
001524  9900              LDR      r1,[sp,#0]            ;2919
001526  460c              MOV      r4,r1                 ;2919
001528  f7fffffe          BL       __aeabi_fmul
00152c  f7fffffe          BL       __aeabi_f2iz
001530  9005              STR      r0,[sp,#0x14]         ;2920
001532  9806              LDR      r0,[sp,#0x18]         ;2920
001534  f7fffffe          BL       __aeabi_i2f
001538  4621              MOV      r1,r4                 ;2920
00153a  f7fffffe          BL       __aeabi_fmul
00153e  f7fffffe          BL       __aeabi_f2iz
001542  9006              STR      r0,[sp,#0x18]         ;2921
001544  9807              LDR      r0,[sp,#0x1c]         ;2921
001546  f7fffffe          BL       __aeabi_i2f
00154a  4621              MOV      r1,r4                 ;2921
00154c  f7fffffe          BL       __aeabi_fmul
001550  f7fffffe          BL       __aeabi_f2iz
001554  9007              STR      r0,[sp,#0x1c]         ;2922
001556  a805              ADD      r0,sp,#0x14           ;2922
001558  f7fffffe          BL       dmp_set_gyro_bias
00155c  a801              ADD      r0,sp,#4              ;2923
00155e  f7fffffe          BL       mpu_get_accel_sens
001562  f8bd0004          LDRH     r0,[sp,#4]            ;2924
001566  9902              LDR      r1,[sp,#8]            ;2924
001568  4341              MULS     r1,r0,r1              ;2924
00156a  9102              STR      r1,[sp,#8]            ;2925
00156c  9903              LDR      r1,[sp,#0xc]          ;2925
00156e  4341              MULS     r1,r0,r1              ;2925
001570  9103              STR      r1,[sp,#0xc]          ;2926
001572  9904              LDR      r1,[sp,#0x10]         ;2926
001574  4341              MULS     r1,r0,r1              ;2926
001576  a802              ADD      r0,sp,#8              ;2927
001578  9104              STR      r1,[sp,#0x10]         ;2927
00157a  f7fffffe          BL       dmp_set_accel_bias
00157e  2000              MOVS     r0,#0                 ;2928
001580  e7c8              B        |L1.5396|
;;;2931   //陀螺仪方向控制
                          ENDP

                  inv_row_2_scale PROC
;;;2952   //方向转换
;;;2953   unsigned short inv_row_2_scale(const signed char *row)
001582  f9901000          LDRSB    r1,[r0,#0]
;;;2954   {
;;;2955       unsigned short b;
;;;2956   
;;;2957       if (row[0] > 0)
001586  2900              CMP      r1,#0
001588  dd02              BLE      |L1.5520|
;;;2958           b = 0;
00158a  f04f0000          MOV      r0,#0
;;;2959       else if (row[0] < 0)
;;;2960           b = 4;
;;;2961       else if (row[1] > 0)
;;;2962           b = 1;
;;;2963       else if (row[1] < 0)
;;;2964           b = 5;
;;;2965       else if (row[2] > 0)
;;;2966           b = 2;
;;;2967       else if (row[2] < 0)
;;;2968           b = 6;
;;;2969       else
;;;2970           b = 7;      // error
;;;2971       return b;
;;;2972   }
00158e  4770              BX       lr
                  |L1.5520|
001590  da02              BGE      |L1.5528|
001592  f04f0004          MOV      r0,#4                 ;2960
001596  4770              BX       lr
                  |L1.5528|
001598  f9901001          LDRSB    r1,[r0,#1]            ;2961
00159c  2900              CMP      r1,#0                 ;2961
00159e  dd02              BLE      |L1.5542|
0015a0  f04f0001          MOV      r0,#1                 ;2962
0015a4  4770              BX       lr
                  |L1.5542|
0015a6  da02              BGE      |L1.5550|
0015a8  f04f0005          MOV      r0,#5                 ;2964
0015ac  4770              BX       lr
                  |L1.5550|
0015ae  f9900002          LDRSB    r0,[r0,#2]            ;2965
0015b2  2800              CMP      r0,#0                 ;2965
0015b4  dd02              BLE      |L1.5564|
0015b6  f04f0002          MOV      r0,#2                 ;2966
0015ba  4770              BX       lr
                  |L1.5564|
0015bc  da02              BGE      |L1.5572|
0015be  f04f0006          MOV      r0,#6                 ;2968
0015c2  4770              BX       lr
                  |L1.5572|
0015c4  f04f0007          MOV      r0,#7                 ;2970
0015c8  4770              BX       lr
;;;2973   //空函数,未用到.
                          ENDP

                  inv_orientation_matrix_to_scalar PROC
;;;2931   //陀螺仪方向控制
;;;2932   unsigned short inv_orientation_matrix_to_scalar(
0015ca  b500              PUSH     {lr}
;;;2933       const signed char *mtx)
;;;2934   {
0015cc  4602              MOV      r2,r0
;;;2935       unsigned short scalar; 
;;;2936       /*
;;;2937          XYZ  010_001_000 Identity Matrix
;;;2938          XZY  001_010_000
;;;2939          YXZ  010_000_001
;;;2940          YZX  000_010_001
;;;2941          ZXY  001_000_010
;;;2942          ZYX  000_001_010
;;;2943        */
;;;2944   
;;;2945       scalar = inv_row_2_scale(mtx);
0015ce  f7fffffe          BL       inv_row_2_scale
0015d2  4603              MOV      r3,r0
;;;2946       scalar |= inv_row_2_scale(mtx + 3) << 3;
0015d4  1cd0              ADDS     r0,r2,#3
0015d6  f7fffffe          BL       inv_row_2_scale
0015da  ea4303c0          ORR      r3,r3,r0,LSL #3
;;;2947       scalar |= inv_row_2_scale(mtx + 6) << 6;
0015de  1d90              ADDS     r0,r2,#6
0015e0  f7fffffe          BL       inv_row_2_scale
0015e4  ea431080          ORR      r0,r3,r0,LSL #6
0015e8  b280              UXTH     r0,r0
;;;2948   
;;;2949   
;;;2950       return scalar;
;;;2951   }
0015ea  bd00              POP      {pc}
;;;2952   //方向转换
                          ENDP

                  mpu_dmp_init PROC
;;;2980   //    其他,失败
;;;2981   u8 mpu_dmp_init(void)
0015ec  b510              PUSH     {r4,lr}
;;;2982   {
;;;2983   	u8 res=0;
;;;2984   	//MPU_IIC_Init(); 	//初始化IIC总线
;;;2985   	if(mpu_init()==0)	//初始化MPU6050
0015ee  f7fffffe          BL       mpu_init
0015f2  b108              CBZ      r0,|L1.5624|
;;;2986   	{	 
;;;2987   		res=mpu_set_sensors(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置所需要的传感器
;;;2988   		if(res)return 1; 
;;;2989   		res=mpu_configure_fifo(INV_XYZ_GYRO|INV_XYZ_ACCEL);//设置FIFO
;;;2990   		if(res)return 2; 
;;;2991   		res=mpu_set_sample_rate(DEFAULT_MPU_HZ);	//设置采样率
;;;2992   		if(res)return 3; 
;;;2993   		res=dmp_load_motion_driver_firmware();		//加载dmp固件
;;;2994   		if(res)return 4; 
;;;2995   		res=dmp_set_orientation(inv_orientation_matrix_to_scalar(gyro_orientation));//设置陀螺仪方向
;;;2996   		if(res)return 5; 
;;;2997   		res=dmp_enable_feature(DMP_FEATURE_6X_LP_QUAT|DMP_FEATURE_TAP|	//设置dmp功能
;;;2998   		    DMP_FEATURE_ANDROID_ORIENT|DMP_FEATURE_SEND_RAW_ACCEL|DMP_FEATURE_SEND_CAL_GYRO|
;;;2999   		    DMP_FEATURE_GYRO_CAL);
;;;3000   		if(res)return 6; 
;;;3001   		res=dmp_set_fifo_rate(DEFAULT_MPU_HZ);	//设置DMP输出速率(最大不超过200Hz)
;;;3002   		if(res)return 7;   
;;;3003   		res=run_self_test();		//自检
;;;3004   	//	if(res)return 8;    
;;;3005   		res=mpu_set_dmp_state(1);	//使能DMP
;;;3006   		if(res)return 9;     
;;;3007   	}else return 10;
0015f4  200a              MOVS     r0,#0xa
;;;3008   	return 0;
;;;3009   }
0015f6  bd10              POP      {r4,pc}
                  |L1.5624|
0015f8  2078              MOVS     r0,#0x78              ;2987
0015fa  f7fffffe          BL       mpu_set_sensors
0015fe  f0100fff          TST      r0,#0xff              ;2987
001602  d001              BEQ      |L1.5640|
001604  2001              MOVS     r0,#1                 ;2988
001606  bd10              POP      {r4,pc}
                  |L1.5640|
001608  2078              MOVS     r0,#0x78              ;2989
00160a  f7fffffe          BL       mpu_configure_fifo
00160e  f0100fff          TST      r0,#0xff              ;2989
001612  d001              BEQ      |L1.5656|
001614  2002              MOVS     r0,#2                 ;2990
001616  bd10              POP      {r4,pc}
                  |L1.5656|
001618  2064              MOVS     r0,#0x64              ;2991
00161a  f7fffffe          BL       mpu_set_sample_rate
00161e  f0100fff          TST      r0,#0xff              ;2991
001622  d001              BEQ      |L1.5672|
001624  2003              MOVS     r0,#3                 ;2992
001626  bd10              POP      {r4,pc}
                  |L1.5672|
001628  f7fffffe          BL       dmp_load_motion_driver_firmware
00162c  f0100fff          TST      r0,#0xff              ;2993
001630  d001              BEQ      |L1.5686|
001632  2004              MOVS     r0,#4                 ;2994
001634  bd10              POP      {r4,pc}
                  |L1.5686|
001636  48eb              LDR      r0,|L1.6628|
001638  f7fffffe          BL       inv_orientation_matrix_to_scalar
00163c  f7fffffe          BL       dmp_set_orientation
001640  f0100fff          TST      r0,#0xff              ;2995
001644  d001              BEQ      |L1.5706|
001646  2005              MOVS     r0,#5                 ;2996
001648  bd10              POP      {r4,pc}
                  |L1.5706|
00164a  f2401073          MOV      r0,#0x173             ;2997
00164e  f7fffffe          BL       dmp_enable_feature
001652  f0100fff          TST      r0,#0xff              ;2997
001656  d001              BEQ      |L1.5724|
001658  2006              MOVS     r0,#6                 ;3000
00165a  bd10              POP      {r4,pc}
                  |L1.5724|
00165c  2064              MOVS     r0,#0x64              ;3001
00165e  f7fffffe          BL       dmp_set_fifo_rate
001662  f0100fff          TST      r0,#0xff              ;3001
001666  d001              BEQ      |L1.5740|
001668  2007              MOVS     r0,#7                 ;3002
                  |L1.5738|
00166a  bd10              POP      {r4,pc}
                  |L1.5740|
00166c  f7fffffe          BL       run_self_test
001670  2001              MOVS     r0,#1                 ;3005
001672  f7fffffe          BL       mpu_set_dmp_state
001676  f01000ff          ANDS     r0,r0,#0xff           ;3005
00167a  d0f6              BEQ      |L1.5738|
00167c  2009              MOVS     r0,#9                 ;3006
00167e  bd10              POP      {r4,pc}
;;;3010   //得到dmp处理后的数据(注意,本函数需要比较多堆栈,局部变量有点多)
                          ENDP

                  mpu_dmp_get_data PROC
;;;3015   //    其他,失败
;;;3016   u8 mpu_dmp_get_data(float *pitch,float *roll,float *yaw)
001680  e92d4ff7          PUSH     {r0-r2,r4-r11,lr}
;;;3017   {
001684  b08e              SUB      sp,sp,#0x38
;;;3018   	float q0=1.0f,q1=0.0f,q2=0.0f,q3=0.0f;
;;;3019   	unsigned long sensor_timestamp;
;;;3020   	short gyro[3], accel[3], sensors;
;;;3021   	unsigned char more;
;;;3022   	long quat[4]; 
;;;3023   	if(dmp_read_fifo(gyro, accel, quat, &sensor_timestamp, &sensors,&more))return 1;	 
001686  a90c              ADD      r1,sp,#0x30
001688  a806              ADD      r0,sp,#0x18
00168a  e9cd0100          STRD     r0,r1,[sp,#0]
00168e  ab0b              ADD      r3,sp,#0x2c
001690  aa02              ADD      r2,sp,#8
001692  a909              ADD      r1,sp,#0x24
001694  a807              ADD      r0,sp,#0x1c
001696  f7fffffe          BL       dmp_read_fifo
00169a  b110              CBZ      r0,|L1.5794|
00169c  2001              MOVS     r0,#1
                  |L1.5790|
;;;3024   	/* Gyro and accel data are written to the FIFO by the DMP in chip frame and hardware units.
;;;3025   	 * This behavior is convenient because it keeps the gyro and accel outputs of dmp_read_fifo and mpu_read_fifo consistent.
;;;3026   	**/
;;;3027   	/*if (sensors & INV_XYZ_GYRO )
;;;3028   	send_packet(PACKET_TYPE_GYRO, gyro);
;;;3029   	if (sensors & INV_XYZ_ACCEL)
;;;3030   	send_packet(PACKET_TYPE_ACCEL, accel); */
;;;3031   	/* Unlike gyro and accel, quaternions are written to the FIFO in the body frame, q30.
;;;3032   	 * The orientation is set by the scalar passed to dmp_set_orientation during initialization. 
;;;3033   	**/
;;;3034   	if(sensors&INV_WXYZ_QUAT) 
;;;3035   	{
;;;3036   		q0 = quat[0] / q30;	//q30格式转换为浮点数
;;;3037   		q1 = quat[1] / q30;
;;;3038   		q2 = quat[2] / q30;
;;;3039   		q3 = quat[3] / q30; 
;;;3040   		//计算得到俯仰角/横滚角/航向角
;;;3041   		*pitch = asin(-2 * q1 * q3 + 2 * q0* q2)* 57.3;	// pitch
;;;3042   		*roll  = atan2(2 * q2 * q3 + 2 * q0 * q1, -2 * q1 * q1 - 2 * q2* q2 + 1)* 57.3;	// roll
;;;3043   		*yaw   = atan2(2*(q1*q2 + q0*q3),q0*q0+q1*q1-q2*q2-q3*q3) * 57.3;	//yaw
;;;3044   	}else return 2;
;;;3045   	return 0;
;;;3046   }
00169e  b011              ADD      sp,sp,#0x44
0016a0  e626              B        |L1.4848|
                  |L1.5794|
0016a2  f8bd0018          LDRH     r0,[sp,#0x18]         ;3034
0016a6  05c0              LSLS     r0,r0,#23             ;3034
0016a8  d57e              BPL      |L1.6056|
0016aa  9802              LDR      r0,[sp,#8]            ;3036
0016ac  f7fffffe          BL       __aeabi_i2f
0016b0  f06f041d          MVN      r4,#0x1d              ;3036
0016b4  4621              MOV      r1,r4                 ;3036
0016b6  f7fffffe          BL       __ARM_scalbnf
0016ba  4681              MOV      r9,r0                 ;3036
0016bc  9803              LDR      r0,[sp,#0xc]          ;3037
0016be  f7fffffe          BL       __aeabi_i2f
0016c2  4621              MOV      r1,r4                 ;3037
0016c4  f7fffffe          BL       __ARM_scalbnf
0016c8  4680              MOV      r8,r0                 ;3037
0016ca  9804              LDR      r0,[sp,#0x10]         ;3038
0016cc  f7fffffe          BL       __aeabi_i2f
0016d0  4621              MOV      r1,r4                 ;3038
0016d2  f7fffffe          BL       __ARM_scalbnf
0016d6  4606              MOV      r6,r0                 ;3038
0016d8  9805              LDR      r0,[sp,#0x14]         ;3039
0016da  f7fffffe          BL       __aeabi_i2f
0016de  4621              MOV      r1,r4                 ;3039
0016e0  f7fffffe          BL       __ARM_scalbnf
0016e4  4682              MOV      r10,r0                ;3039
0016e6  2101              MOVS     r1,#1                 ;3041
0016e8  4648              MOV      r0,r9                 ;3041
0016ea  f7fffffe          BL       __ARM_scalbnf
0016ee  4607              MOV      r7,r0                 ;3041
0016f0  4631              MOV      r1,r6                 ;3041
0016f2  f7fffffe          BL       __aeabi_fmul
0016f6  4604              MOV      r4,r0                 ;3041
0016f8  f04f4140          MOV      r1,#0xc0000000        ;3041
0016fc  4640              MOV      r0,r8                 ;3041
0016fe  f7fffffe          BL       __aeabi_fmul
001702  4605              MOV      r5,r0                 ;3041
001704  4651              MOV      r1,r10                ;3041
001706  f7fffffe          BL       __aeabi_fmul
00170a  4621              MOV      r1,r4                 ;3041
00170c  f7fffffe          BL       __aeabi_fadd
001710  f7fffffe          BL       __aeabi_f2d
001714  f7fffffe          BL       asin
001718  f04f3b66          MOV      r11,#0x66666666       ;3041
00171c  465a              MOV      r2,r11                ;3041
00171e  4bb2              LDR      r3,|L1.6632|
001720  f7fffffe          BL       __aeabi_dmul
001724  f7fffffe          BL       __aeabi_d2f
001728  990e              LDR      r1,[sp,#0x38]         ;3041
00172a  6008              STR      r0,[r1,#0]            ;3042
00172c  2101              MOVS     r1,#1                 ;3042
00172e  4630              MOV      r0,r6                 ;3042
001730  f7fffffe          BL       __ARM_scalbnf
001734  4631              MOV      r1,r6                 ;3042
001736  9000              STR      r0,[sp,#0]            ;3042
001738  f7fffffe          BL       __aeabi_fmul
00173c  4604              MOV      r4,r0                 ;3042
00173e  4628              MOV      r0,r5                 ;3042
001740  4641              MOV      r1,r8                 ;3042
001742  f7fffffe          BL       __aeabi_fmul
001746  4621              MOV      r1,r4                 ;3042
001748  f7fffffe          BL       __aeabi_fsub
00174c  f04f517e          MOV      r1,#0x3f800000        ;3042
001750  f7fffffe          BL       __aeabi_fadd
001754  f7fffffe          BL       __aeabi_f2d
001758  4604              MOV      r4,r0                 ;3042
00175a  460d              MOV      r5,r1                 ;3042
00175c  4638              MOV      r0,r7                 ;3042
00175e  4641              MOV      r1,r8                 ;3042
001760  f7fffffe          BL       __aeabi_fmul
001764  4607              MOV      r7,r0                 ;3042
001766  4651              MOV      r1,r10                ;3042
001768  9800              LDR      r0,[sp,#0]            ;3042
00176a  f7fffffe          BL       __aeabi_fmul
00176e  4639              MOV      r1,r7                 ;3042
001770  f7fffffe          BL       __aeabi_fadd
001774  f7fffffe          BL       __aeabi_f2d
001778  4622              MOV      r2,r4                 ;3042
00177a  462b              MOV      r3,r5                 ;3042
00177c  f7fffffe          BL       atan2
001780  465a              MOV      r2,r11                ;3042
001782  4b99              LDR      r3,|L1.6632|
001784  f7fffffe          BL       __aeabi_dmul
001788  f7fffffe          BL       __aeabi_d2f
00178c  990f              LDR      r1,[sp,#0x3c]         ;3042
00178e  6008              STR      r0,[r1,#0]            ;3043
001790  4651              MOV      r1,r10                ;3043
001792  4608              MOV      r0,r1                 ;3043
001794  f7fffffe          BL       __aeabi_fmul
001798  4607              MOV      r7,r0                 ;3043
00179a  4631              MOV      r1,r6                 ;3043
00179c  4608              MOV      r0,r1                 ;3043
00179e  f7fffffe          BL       __aeabi_fmul
0017a2  4605              MOV      r5,r0                 ;3043
0017a4  4641              MOV      r1,r8                 ;3043
0017a6  e000              B        |L1.6058|
                  |L1.6056|
0017a8  e033              B        |L1.6162|
                  |L1.6058|
0017aa  4608              MOV      r0,r1                 ;3043
0017ac  f7fffffe          BL       __aeabi_fmul
0017b0  4604              MOV      r4,r0                 ;3043
0017b2  4649              MOV      r1,r9                 ;3043
0017b4  4608              MOV      r0,r1                 ;3043
0017b6  f7fffffe          BL       __aeabi_fmul
0017ba  4621              MOV      r1,r4                 ;3043
0017bc  f7fffffe          BL       __aeabi_fadd
0017c0  4629              MOV      r1,r5                 ;3043
0017c2  f7fffffe          BL       __aeabi_fsub
0017c6  4639              MOV      r1,r7                 ;3043
0017c8  f7fffffe          BL       __aeabi_fsub
0017cc  f7fffffe          BL       __aeabi_f2d
0017d0  4604              MOV      r4,r0                 ;3043
0017d2  460d              MOV      r5,r1                 ;3043
0017d4  4651              MOV      r1,r10                ;3043
0017d6  4648              MOV      r0,r9                 ;3043
0017d8  f7fffffe          BL       __aeabi_fmul
0017dc  4607              MOV      r7,r0                 ;3043
0017de  4631              MOV      r1,r6                 ;3043
0017e0  4640              MOV      r0,r8                 ;3043
0017e2  f7fffffe          BL       __aeabi_fmul
0017e6  4639              MOV      r1,r7                 ;3043
0017e8  f7fffffe          BL       __aeabi_fadd
0017ec  2101              MOVS     r1,#1                 ;3043
0017ee  f7fffffe          BL       __ARM_scalbnf
0017f2  f7fffffe          BL       __aeabi_f2d
0017f6  4622              MOV      r2,r4                 ;3043
0017f8  462b              MOV      r3,r5                 ;3043
0017fa  f7fffffe          BL       atan2
0017fe  465a              MOV      r2,r11                ;3043
001800  4b79              LDR      r3,|L1.6632|
001802  f7fffffe          BL       __aeabi_dmul
001806  f7fffffe          BL       __aeabi_d2f
00180a  9910              LDR      r1,[sp,#0x40]         ;3043
00180c  6008              STR      r0,[r1,#0]            ;3045
00180e  2000              MOVS     r0,#0                 ;3045
001810  e745              B        |L1.5790|
                  |L1.6162|
001812  2002              MOVS     r0,#2                 ;3044
001814  e743              B        |L1.5790|
;;;3047   /*
                          ENDP

                  accel_self_test PROC
;;;1955   
;;;1956   static int accel_self_test(long *bias_regular, long *bias_st)
001816  e92d4ffe          PUSH     {r1-r11,lr}
;;;1957   {
00181a  4680              MOV      r8,r0
00181c  460f              MOV      r7,r1
;;;1958       int jj, result = 0;
00181e  2500              MOVS     r5,#0
;;;1959       float st_shift[3], st_shift_cust, st_shift_var;
;;;1960   
;;;1961       get_accel_prod_shift(st_shift);
001820  4668              MOV      r0,sp
001822  f7fffffe          BL       get_accel_prod_shift
;;;1962       for(jj = 0; jj < 3; jj++) {
001826  2400              MOVS     r4,#0
;;;1963           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
001828  f06f0a0f          MVN      r10,#0xf
00182c  46e9              MOV      r9,sp                 ;1959
;;;1964           if (st_shift[jj]) {
;;;1965               st_shift_var = st_shift_cust / st_shift[jj] - 1.f;
;;;1966               if (fabs(st_shift_var) > test.max_accel_var)
;;;1967                   result |= 1 << jj;
00182e  2601              MOVS     r6,#1
                  |L1.6192|
001830  f8580024          LDR      r0,[r8,r4,LSL #2]     ;1963
001834  f8571024          LDR      r1,[r7,r4,LSL #2]     ;1963
001838  1a40              SUBS     r0,r0,r1              ;1963
00183a  d500              BPL      |L1.6206|
00183c  4240              RSBS     r0,r0,#0              ;1963
                  |L1.6206|
00183e  f7fffffe          BL       __aeabi_i2f
001842  4651              MOV      r1,r10                ;1963
001844  f7fffffe          BL       __ARM_scalbnf
001848  f8591024          LDR      r1,[r9,r4,LSL #2]     ;1964
00184c  f0114fff          TST      r1,#0x7f800000        ;1964
001850  d00b              BEQ      |L1.6250|
001852  f7fffffe          BL       __aeabi_fdiv
001856  f04f517e          MOV      r1,#0x3f800000        ;1965
00185a  f7fffffe          BL       __aeabi_fsub
00185e  4963              LDR      r1,|L1.6636|
001860  f0204000          BIC      r0,r0,#0x80000000     ;1966
001864  4288              CMP      r0,r1                 ;1966
001866  dc05              BGT      |L1.6260|
001868  e007              B        |L1.6266|
                  |L1.6250|
;;;1968           } else if ((st_shift_cust < test.min_g) ||
00186a  4961              LDR      r1,|L1.6640|
00186c  4408              ADD      r0,r0,r1
00186e  4961              LDR      r1,|L1.6644|
001870  4288              CMP      r0,r1
001872  d302              BCC      |L1.6266|
                  |L1.6260|
;;;1969               (st_shift_cust > test.max_g))
;;;1970               result |= 1 << jj;
001874  fa06f004          LSL      r0,r6,r4
001878  4305              ORRS     r5,r5,r0
                  |L1.6266|
00187a  1c64              ADDS     r4,r4,#1
00187c  2c03              CMP      r4,#3                 ;1962
00187e  dbd7              BLT      |L1.6192|
;;;1971       }
;;;1972   
;;;1973       return result;
001880  4628              MOV      r0,r5
;;;1974   }
001882  e405              B        |L1.4240|
;;;1975   
                          ENDP

                  gyro_self_test PROC
;;;1976   static int gyro_self_test(long *bias_regular, long *bias_st)
001884  e92d4ff8          PUSH     {r3-r11,lr}
;;;1977   {
001888  4682              MOV      r10,r0
;;;1978       int jj, result = 0;
;;;1979       unsigned char tmp[3];
;;;1980       float st_shift, st_shift_cust, st_shift_var;
;;;1981   
;;;1982       if (i2c_read(st.hw->addr, 0x0D, 3, tmp))
00188a  4856              LDR      r0,|L1.6628|
00188c  4689              MOV      r9,r1                 ;1977
00188e  382c              SUBS     r0,r0,#0x2c
001890  2500              MOVS     r5,#0                 ;1978
001892  6840              LDR      r0,[r0,#4]  ; st
001894  466b              MOV      r3,sp
001896  2203              MOVS     r2,#3
001898  7800              LDRB     r0,[r0,#0]
00189a  210d              MOVS     r1,#0xd
00189c  f7fffffe          BL       dmp_iic_read
0018a0  b108              CBZ      r0,|L1.6310|
;;;1983           return 0x07;
0018a2  2007              MOVS     r0,#7
;;;1984   
;;;1985       tmp[0] &= 0x1F;
;;;1986       tmp[1] &= 0x1F;
;;;1987       tmp[2] &= 0x1F;
;;;1988   
;;;1989       for (jj = 0; jj < 3; jj++) {
;;;1990           st_shift_cust = labs(bias_regular[jj] - bias_st[jj]) / 65536.f;
;;;1991           if (tmp[jj]) {
;;;1992               st_shift = 3275.f / test.gyro_sens;
;;;1993               while (--tmp[jj])
;;;1994                   st_shift *= 1.046f;
;;;1995               st_shift_var = st_shift_cust / st_shift - 1.f;
;;;1996               if (fabs(st_shift_var) > test.max_gyro_var)
;;;1997                   result |= 1 << jj;
;;;1998           } else if ((st_shift_cust < test.min_dps) ||
;;;1999               (st_shift_cust > test.max_dps))
;;;2000               result |= 1 << jj;
;;;2001       }
;;;2002       return result;
;;;2003   }
0018a4  e623              B        |L1.5358|
                  |L1.6310|
0018a6  f89d0000          LDRB     r0,[sp,#0]            ;1985
0018aa  2400              MOVS     r4,#0                 ;1989
0018ac  f000001f          AND      r0,r0,#0x1f           ;1985
0018b0  f88d0000          STRB     r0,[sp,#0]            ;1985
0018b4  f89d0001          LDRB     r0,[sp,#1]            ;1986
0018b8  466f              MOV      r7,sp                 ;1979
0018ba  f000001f          AND      r0,r0,#0x1f           ;1986
0018be  f88d0001          STRB     r0,[sp,#1]            ;1986
0018c2  f89d0002          LDRB     r0,[sp,#2]            ;1987
0018c6  f04f0801          MOV      r8,#1                 ;1997
0018ca  f000001f          AND      r0,r0,#0x1f           ;1987
0018ce  f88d0002          STRB     r0,[sp,#2]            ;1987
                  |L1.6354|
0018d2  f85a1024          LDR      r1,[r10,r4,LSL #2]    ;1990
0018d6  f8590024          LDR      r0,[r9,r4,LSL #2]     ;1990
0018da  1a08              SUBS     r0,r1,r0              ;1990
0018dc  d500              BPL      |L1.6368|
0018de  4240              RSBS     r0,r0,#0              ;1990
                  |L1.6368|
0018e0  f7fffffe          BL       __aeabi_i2f
0018e4  f06f010f          MVN      r1,#0xf               ;1990
0018e8  f7fffffe          BL       __ARM_scalbnf
0018ec  4606              MOV      r6,r0                 ;1990
0018ee  5d38              LDRB     r0,[r7,r4]            ;1991
0018f0  b1e0              CBZ      r0,|L1.6444|
0018f2  4a41              LDR      r2,|L1.6648|
0018f4  f8dfb104          LDR      r11,|L1.6652|
0018f8  e004              B        |L1.6404|
                  |L1.6394|
0018fa  4659              MOV      r1,r11                ;1994
0018fc  4610              MOV      r0,r2                 ;1994
0018fe  f7fffffe          BL       __aeabi_fmul
001902  4602              MOV      r2,r0                 ;1994
                  |L1.6404|
001904  5d38              LDRB     r0,[r7,r4]            ;1993
001906  1e40              SUBS     r0,r0,#1              ;1993
001908  f01000ff          ANDS     r0,r0,#0xff           ;1993
00190c  5538              STRB     r0,[r7,r4]            ;1993
00190e  d1f4              BNE      |L1.6394|
001910  4611              MOV      r1,r2                 ;1995
001912  4630              MOV      r0,r6                 ;1995
001914  f7fffffe          BL       __aeabi_fdiv
001918  f04f517e          MOV      r1,#0x3f800000        ;1995
00191c  f7fffffe          BL       __aeabi_fsub
001920  4932              LDR      r1,|L1.6636|
001922  f0204000          BIC      r0,r0,#0x80000000     ;1996
001926  4288              CMP      r0,r1                 ;1996
001928  dc05              BGT      |L1.6454|
00192a  e007              B        |L1.6460|
                  |L1.6444|
00192c  4834              LDR      r0,|L1.6656|
00192e  4430              ADD      r0,r0,r6              ;1998
001930  f1b07fd9          CMP      r0,#0x1b20000         ;1998
001934  d902              BLS      |L1.6460|
                  |L1.6454|
001936  fa08f004          LSL      r0,r8,r4              ;2000
00193a  4305              ORRS     r5,r5,r0              ;2000
                  |L1.6460|
00193c  1c64              ADDS     r4,r4,#1              ;2000
00193e  2c03              CMP      r4,#3                 ;1989
001940  dbc7              BLT      |L1.6354|
001942  4628              MOV      r0,r5                 ;2002
001944  e5d3              B        |L1.5358|
;;;2004   
                          ENDP

                  get_accel_prod_shift PROC
;;;1930   #ifdef MPU6050
;;;1931   static int get_accel_prod_shift(float *st_shift)
001946  e92d47fc          PUSH     {r2-r10,lr}
;;;1932   {
00194a  4605              MOV      r5,r0
;;;1933       unsigned char tmp[4], shift_code[3], ii;
;;;1934   
;;;1935       if (i2c_read(st.hw->addr, 0x0D, 4, tmp))
00194c  4825              LDR      r0,|L1.6628|
00194e  466b              MOV      r3,sp
001950  382c              SUBS     r0,r0,#0x2c
001952  2204              MOVS     r2,#4
001954  6840              LDR      r0,[r0,#4]  ; st
001956  210d              MOVS     r1,#0xd
001958  7800              LDRB     r0,[r0,#0]
00195a  f7fffffe          BL       dmp_iic_read
00195e  b110              CBZ      r0,|L1.6502|
;;;1936           return 0x07;
001960  2007              MOVS     r0,#7
                  |L1.6498|
;;;1937   
;;;1938       shift_code[0] = ((tmp[0] & 0xE0) >> 3) | ((tmp[3] & 0x30) >> 4);
;;;1939       shift_code[1] = ((tmp[1] & 0xE0) >> 3) | ((tmp[3] & 0x0C) >> 2);
;;;1940       shift_code[2] = ((tmp[2] & 0xE0) >> 3) | (tmp[3] & 0x03);
;;;1941       for (ii = 0; ii < 3; ii++) {
;;;1942           if (!shift_code[ii]) {
;;;1943               st_shift[ii] = 0.f;
;;;1944               continue;
;;;1945           }
;;;1946           /* Equivalent to..
;;;1947            * st_shift[ii] = 0.34f * powf(0.92f/0.34f, (shift_code[ii]-1) / 30.f)
;;;1948            */
;;;1949           st_shift[ii] = 0.34f;
;;;1950           while (--shift_code[ii])
;;;1951               st_shift[ii] *= 1.034f;
;;;1952       }
;;;1953       return 0;
;;;1954   }
001962  e8bd87fc          POP      {r2-r10,pc}
                  |L1.6502|
001966  f89d0000          LDRB     r0,[sp,#0]            ;1938
00196a  211c              MOVS     r1,#0x1c              ;1938
00196c  ea0102d0          AND      r2,r1,r0,LSR #3       ;1938
001970  f89d0003          LDRB     r0,[sp,#3]            ;1938
001974  f8df908c          LDR      r9,|L1.6660|
001978  f3c01301          UBFX     r3,r0,#4,#2           ;1938
00197c  431a              ORRS     r2,r2,r3              ;1938
00197e  f88d2004          STRB     r2,[sp,#4]            ;1938
001982  f89d2001          LDRB     r2,[sp,#1]            ;1939
001986  f3c00381          UBFX     r3,r0,#2,#2           ;1939
00198a  ea0102d2          AND      r2,r1,r2,LSR #3       ;1939
00198e  431a              ORRS     r2,r2,r3              ;1939
001990  f88d2005          STRB     r2,[sp,#5]            ;1939
001994  f89d2002          LDRB     r2,[sp,#2]            ;1940
001998  f0000003          AND      r0,r0,#3              ;1940
00199c  ea0101d2          AND      r1,r1,r2,LSR #3       ;1940
0019a0  4301              ORRS     r1,r1,r0              ;1940
0019a2  2400              MOVS     r4,#0                 ;1941
0019a4  4f18              LDR      r7,|L1.6664|
0019a6  f88d1006          STRB     r1,[sp,#6]            ;1940
0019aa  46a0              MOV      r8,r4                 ;1941
0019ac  ae01              ADD      r6,sp,#4              ;1933
                  |L1.6574|
0019ae  5d30              LDRB     r0,[r6,r4]            ;1942
0019b0  b110              CBZ      r0,|L1.6584|
0019b2  f8459024          STR      r9,[r5,r4,LSL #2]     ;1949
0019b6  e009              B        |L1.6604|
                  |L1.6584|
0019b8  f8458024          STR      r8,[r5,r4,LSL #2]     ;1943
0019bc  e00c              B        |L1.6616|
                  |L1.6590|
0019be  f8550024          LDR      r0,[r5,r4,LSL #2]     ;1951
0019c2  4639              MOV      r1,r7                 ;1951
0019c4  f7fffffe          BL       __aeabi_fmul
0019c8  f8450024          STR      r0,[r5,r4,LSL #2]     ;1951
                  |L1.6604|
0019cc  5d30              LDRB     r0,[r6,r4]            ;1950
0019ce  1e40              SUBS     r0,r0,#1              ;1950
0019d0  f01000ff          ANDS     r0,r0,#0xff           ;1950
0019d4  5530              STRB     r0,[r6,r4]            ;1950
0019d6  d1f2              BNE      |L1.6590|
                  |L1.6616|
0019d8  1c64              ADDS     r4,r4,#1              ;1950
0019da  b2e4              UXTB     r4,r4                 ;1941
0019dc  2c03              CMP      r4,#3                 ;1941
0019de  d3e6              BCC      |L1.6574|
0019e0  2000              MOVS     r0,#0                 ;1953
0019e2  e7be              B        |L1.6498|
;;;1955   
                          ENDP

                  |L1.6628|
                          DCD      ||.data||+0x2c
                  |L1.6632|
                          DCD      0x404ca666
                  |L1.6636|
                          DCD      0x3e0f5c29
                  |L1.6640|
                          DCD      0xc1666666
                  |L1.6644|
                          DCD      0x00d9999a
                  |L1.6648|
                          DCD      0x41c80000
                  |L1.6652|
                          DCD      0x3f85e354
                  |L1.6656|
                          DCD      0xbee00000
                  |L1.6660|
                          DCD      0x3eae147b
                  |L1.6664|
                          DCD      0x3f845a1d

                          AREA ||.constdata||, DATA, READONLY, ALIGN=0

                  ||reg||
000000  75191a0c          DCB      0x75,0x19,0x1a,0x0c
000004  6a231b1c          DCB      0x6a,0x23,0x1b,0x1c
000008  1f207274          DCB      0x1f,0x20,0x72,0x74
00000c  433b4138          DCB      0x43,0x3b,0x41,0x38
000010  393a6b6c          DCB      0x39,0x3a,0x6b,0x6c
000014  376f0624          DCB      0x37,0x6f,0x06,0x24
000018  6d6e70            DCB      0x6d,0x6e,0x70

                          AREA ||area_number.5||, DATA, READONLY, ALIGN=1

                          EXPORTAS ||area_number.5||, ||.constdata||
                  ||hw||
000000  6800              DCB      0x68,0x00
000002  0400              DCW      0x0400
000004  7600              DCB      0x76,0x00
000006  0154              DCW      0x0154
000008  fdf70100          DCW      0xfdf7,0x0100

                          AREA ||area_number.6||, DATA, READONLY, ALIGN=2

                          EXPORTAS ||area_number.6||, ||.constdata||
                  test
                          DCD      0x00000083
                          DCD      0x00000800
000008  00010018          DCB      0x00,0x01,0x00,0x18
00000c  0032              DCW      0x0032
00000e  0500              DCB      0x05,0x00
000010  41200000          DCFS     0x41200000 ; 10
000014  42d20000          DCFS     0x42d20000 ; 105
000018  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645
00001c  3e99999a          DCFS     0x3e99999a ; 0.30000001192092896
000020  3f733333          DCFS     0x3f733333 ; 0.94999998807907104
000024  3e0f5c29          DCFS     0x3e0f5c29 ; 0.14000000059604645

                          AREA ||.conststring||, DATA, READONLY, MERGE=1, STRINGS, ALIGN=2

000000  50726f64          DCB      "Product ID read as 0 indicates device is either incompa"
000004  75637420
000008  49442072
00000c  65616420
000010  61732030
000014  20696e64
000018  69636174
00001c  65732064
000020  65766963
000024  65206973
000028  20656974
00002c  68657220
000030  696e636f
000034  6d7061  
000037  7469626c          DCB      "tible or an MPU3050.\n",0
00003b  65206f72
00003f  20616e20
000043  4d505533
000047  3035302e
00004b  0a00    

                          AREA ||.data||, DATA, ALIGN=2

                  ||st||
                          DCD      ||reg||
                          DCD      ||hw||
000008  00000000          DCB      0x00,0x00,0x00,0x00
00000c  0000              DCB      0x00,0x00
00000e  0000              DCW      0x0000
000010  00000000          DCB      0x00,0x00,0x00,0x00
000014  00000000          DCB      0x00,0x00,0x00,0x00
                          %        8
000020  00000000          DCB      0x00,0x00,0x00,0x00
000024  0000              DCB      0x00,0x00
000026  0000              DCW      0x0000
                          DCD      test
                  gyro_orientation
00002c  01000000          DCB      0x01,0x00,0x00,0x00
000030  01000000          DCB      0x01,0x00,0x00,0x00
000034  01                DCB      0x01
