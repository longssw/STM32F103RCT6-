; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\stm32f10x_rtc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f10x_rtc.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\stm32f10x_rtc.crf ..\..\Libraries\FWlib\src\stm32f10x_rtc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  RTC_ITConfig PROC
;;;89       */
;;;90     void RTC_ITConfig(uint16_t RTC_IT, FunctionalState NewState)
000000  4a42              LDR      r2,|L1.268|
;;;91     {
;;;92       /* Check the parameters */
;;;93       assert_param(IS_RTC_IT(RTC_IT));  
;;;94       assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;95       
;;;96       if (NewState != DISABLE)
000002  2900              CMP      r1,#0
;;;97       {
;;;98         RTC->CRH |= RTC_IT;
;;;99       }
;;;100      else
;;;101      {
;;;102        RTC->CRH &= (uint16_t)~RTC_IT;
000004  8811              LDRH     r1,[r2,#0]
000006  d001              BEQ      |L1.12|
000008  4301              ORRS     r1,r1,r0              ;98
00000a  e000              B        |L1.14|
                  |L1.12|
00000c  4381              BICS     r1,r1,r0
                  |L1.14|
00000e  8011              STRH     r1,[r2,#0]            ;98
;;;103      }
;;;104    }
000010  4770              BX       lr
;;;105    
                          ENDP

                  RTC_EnterConfigMode PROC
;;;110      */
;;;111    void RTC_EnterConfigMode(void)
000012  483e              LDR      r0,|L1.268|
;;;112    {
;;;113      /* Set the CNF flag to enter in the Configuration Mode */
;;;114      RTC->CRL |= RTC_CRL_CNF;
000014  1d00              ADDS     r0,r0,#4
000016  8801              LDRH     r1,[r0,#0]
000018  f0410110          ORR      r1,r1,#0x10
00001c  8001              STRH     r1,[r0,#0]
;;;115    }
00001e  4770              BX       lr
;;;116    
                          ENDP

                  RTC_ExitConfigMode PROC
;;;121      */
;;;122    void RTC_ExitConfigMode(void)
000020  483a              LDR      r0,|L1.268|
;;;123    {
;;;124      /* Reset the CNF flag to exit from the Configuration Mode */
;;;125      RTC->CRL &= (uint16_t)~((uint16_t)RTC_CRL_CNF); 
000022  1d00              ADDS     r0,r0,#4
000024  8801              LDRH     r1,[r0,#0]
000026  f0210110          BIC      r1,r1,#0x10
00002a  8001              STRH     r1,[r0,#0]
;;;126    }
00002c  4770              BX       lr
;;;127    
                          ENDP

                  RTC_GetCounter PROC
;;;132      */
;;;133    uint32_t RTC_GetCounter(void)
00002e  4837              LDR      r0,|L1.268|
;;;134    {
;;;135      uint16_t tmp = 0;
;;;136      tmp = RTC->CNTL;
000030  301c              ADDS     r0,r0,#0x1c
000032  8800              LDRH     r0,[r0,#0]
;;;137      return (((uint32_t)RTC->CNTH << 16 ) | tmp) ;
000034  4935              LDR      r1,|L1.268|
000036  3118              ADDS     r1,r1,#0x18
000038  8809              LDRH     r1,[r1,#0]
00003a  ea404001          ORR      r0,r0,r1,LSL #16
;;;138    }
00003e  4770              BX       lr
;;;139    
                          ENDP

                  RTC_SetCounter PROC
;;;144      */
;;;145    void RTC_SetCounter(uint32_t CounterValue)
000040  b500              PUSH     {lr}
;;;146    { 
000042  4602              MOV      r2,r0
;;;147      RTC_EnterConfigMode();
000044  f7fffffe          BL       RTC_EnterConfigMode
;;;148      /* Set RTC COUNTER MSB word */
;;;149      RTC->CNTH = CounterValue >> 16;
000048  4930              LDR      r1,|L1.268|
00004a  0c10              LSRS     r0,r2,#16
00004c  3118              ADDS     r1,r1,#0x18
00004e  8008              STRH     r0,[r1,#0]
;;;150      /* Set RTC COUNTER LSB word */
;;;151      RTC->CNTL = (CounterValue & RTC_LSB_MASK);
000050  1d08              ADDS     r0,r1,#4
000052  8002              STRH     r2,[r0,#0]
;;;152      RTC_ExitConfigMode();
000054  f85deb04          POP      {lr}
000058  e7fe              B        RTC_ExitConfigMode
;;;153    }
;;;154    
                          ENDP

                  RTC_SetPrescaler PROC
;;;159      */
;;;160    void RTC_SetPrescaler(uint32_t PrescalerValue)
00005a  b500              PUSH     {lr}
;;;161    {
00005c  4602              MOV      r2,r0
;;;162      /* Check the parameters */
;;;163      assert_param(IS_RTC_PRESCALER(PrescalerValue));
;;;164      
;;;165      RTC_EnterConfigMode();
00005e  f7fffffe          BL       RTC_EnterConfigMode
;;;166      /* Set RTC PRESCALER MSB word */
;;;167      RTC->PRLH = (PrescalerValue & PRLH_MSB_MASK) >> 16;
000062  492a              LDR      r1,|L1.268|
000064  f3c24003          UBFX     r0,r2,#16,#4
000068  3108              ADDS     r1,r1,#8
00006a  8008              STRH     r0,[r1,#0]
;;;168      /* Set RTC PRESCALER LSB word */
;;;169      RTC->PRLL = (PrescalerValue & RTC_LSB_MASK);
00006c  1d08              ADDS     r0,r1,#4
00006e  8002              STRH     r2,[r0,#0]
;;;170      RTC_ExitConfigMode();
000070  f85deb04          POP      {lr}
000074  e7fe              B        RTC_ExitConfigMode
;;;171    }
;;;172    
                          ENDP

                  RTC_SetAlarm PROC
;;;177      */
;;;178    void RTC_SetAlarm(uint32_t AlarmValue)
000076  b500              PUSH     {lr}
;;;179    {  
000078  4602              MOV      r2,r0
;;;180      RTC_EnterConfigMode();
00007a  f7fffffe          BL       RTC_EnterConfigMode
;;;181      /* Set the ALARM MSB word */
;;;182      RTC->ALRH = AlarmValue >> 16;
00007e  4923              LDR      r1,|L1.268|
000080  0c10              LSRS     r0,r2,#16
000082  3120              ADDS     r1,r1,#0x20
000084  8008              STRH     r0,[r1,#0]
;;;183      /* Set the ALARM LSB word */
;;;184      RTC->ALRL = (AlarmValue & RTC_LSB_MASK);
000086  1d08              ADDS     r0,r1,#4
000088  8002              STRH     r2,[r0,#0]
;;;185      RTC_ExitConfigMode();
00008a  f85deb04          POP      {lr}
00008e  e7fe              B        RTC_ExitConfigMode
;;;186    }
;;;187    
                          ENDP

                  RTC_GetDivider PROC
;;;192      */
;;;193    uint32_t RTC_GetDivider(void)
000090  481e              LDR      r0,|L1.268|
;;;194    {
;;;195      uint32_t tmp = 0x00;
;;;196      tmp = ((uint32_t)RTC->DIVH & (uint32_t)0x000F) << 16;
000092  3010              ADDS     r0,r0,#0x10
000094  8800              LDRH     r0,[r0,#0]
000096  0700              LSLS     r0,r0,#28
000098  0b01              LSRS     r1,r0,#12
;;;197      tmp |= RTC->DIVL;
00009a  481c              LDR      r0,|L1.268|
00009c  3014              ADDS     r0,r0,#0x14
00009e  8800              LDRH     r0,[r0,#0]
0000a0  4308              ORRS     r0,r0,r1
;;;198      return tmp;
;;;199    }
0000a2  4770              BX       lr
;;;200    
                          ENDP

                  RTC_WaitForLastTask PROC
;;;206      */
;;;207    void RTC_WaitForLastTask(void)
0000a4  4819              LDR      r0,|L1.268|
;;;208    {
;;;209      /* Loop until RTOFF flag is set */
;;;210      while ((RTC->CRL & RTC_FLAG_RTOFF) == (uint16_t)RESET)
0000a6  1d00              ADDS     r0,r0,#4
                  |L1.168|
0000a8  8801              LDRH     r1,[r0,#0]
0000aa  0689              LSLS     r1,r1,#26
0000ac  d5fc              BPL      |L1.168|
;;;211      {
;;;212      }
;;;213    }
0000ae  4770              BX       lr
;;;214    
                          ENDP

                  RTC_WaitForSynchro PROC
;;;222      */
;;;223    void RTC_WaitForSynchro(void)
0000b0  4816              LDR      r0,|L1.268|
;;;224    {
;;;225      /* Clear RSF flag */
;;;226      RTC->CRL &= (uint16_t)~RTC_FLAG_RSF;
0000b2  1d00              ADDS     r0,r0,#4
0000b4  8801              LDRH     r1,[r0,#0]
0000b6  f0210108          BIC      r1,r1,#8
0000ba  8001              STRH     r1,[r0,#0]
                  |L1.188|
;;;227      /* Loop until RSF flag is set */
;;;228      while ((RTC->CRL & RTC_FLAG_RSF) == (uint16_t)RESET)
0000bc  8801              LDRH     r1,[r0,#0]
0000be  0709              LSLS     r1,r1,#28
0000c0  d5fc              BPL      |L1.188|
;;;229      {
;;;230      }
;;;231    }
0000c2  4770              BX       lr
;;;232    
                          ENDP

                  RTC_GetFlagStatus PROC
;;;243      */
;;;244    FlagStatus RTC_GetFlagStatus(uint16_t RTC_FLAG)
0000c4  4601              MOV      r1,r0
;;;245    {
;;;246      FlagStatus bitstatus = RESET;
;;;247      
;;;248      /* Check the parameters */
;;;249      assert_param(IS_RTC_GET_FLAG(RTC_FLAG)); 
;;;250      
;;;251      if ((RTC->CRL & RTC_FLAG) != (uint16_t)RESET)
0000c6  4a11              LDR      r2,|L1.268|
0000c8  2000              MOVS     r0,#0                 ;246
0000ca  1d12              ADDS     r2,r2,#4
0000cc  8812              LDRH     r2,[r2,#0]
0000ce  420a              TST      r2,r1
0000d0  d000              BEQ      |L1.212|
;;;252      {
;;;253        bitstatus = SET;
0000d2  2001              MOVS     r0,#1
                  |L1.212|
;;;254      }
;;;255      else
;;;256      {
;;;257        bitstatus = RESET;
;;;258      }
;;;259      return bitstatus;
;;;260    }
0000d4  4770              BX       lr
;;;261    
                          ENDP

                  RTC_ClearFlag PROC
;;;272      */
;;;273    void RTC_ClearFlag(uint16_t RTC_FLAG)
0000d6  490d              LDR      r1,|L1.268|
;;;274    {
;;;275      /* Check the parameters */
;;;276      assert_param(IS_RTC_CLEAR_FLAG(RTC_FLAG)); 
;;;277        
;;;278      /* Clear the corresponding RTC flag */
;;;279      RTC->CRL &= (uint16_t)~RTC_FLAG;
0000d8  1d09              ADDS     r1,r1,#4
0000da  880a              LDRH     r2,[r1,#0]
0000dc  4382              BICS     r2,r2,r0
0000de  800a              STRH     r2,[r1,#0]
;;;280    }
0000e0  4770              BX       lr
;;;281    
                          ENDP

                  RTC_GetITStatus PROC
;;;290      */
;;;291    ITStatus RTC_GetITStatus(uint16_t RTC_IT)
0000e2  490a              LDR      r1,|L1.268|
;;;292    {
;;;293      ITStatus bitstatus = RESET;
;;;294      /* Check the parameters */
;;;295      assert_param(IS_RTC_GET_IT(RTC_IT)); 
;;;296      
;;;297      bitstatus = (ITStatus)(RTC->CRL & RTC_IT);
0000e4  1d09              ADDS     r1,r1,#4
0000e6  8809              LDRH     r1,[r1,#0]
0000e8  b2c2              UXTB     r2,r0
0000ea  4011              ANDS     r1,r1,r2
;;;298      if (((RTC->CRH & RTC_IT) != (uint16_t)RESET) && (bitstatus != (uint16_t)RESET))
0000ec  4a07              LDR      r2,|L1.268|
0000ee  8812              LDRH     r2,[r2,#0]
0000f0  4202              TST      r2,r0
0000f2  d002              BEQ      |L1.250|
0000f4  b109              CBZ      r1,|L1.250|
;;;299      {
;;;300        bitstatus = SET;
0000f6  2001              MOVS     r0,#1
;;;301      }
;;;302      else
;;;303      {
;;;304        bitstatus = RESET;
;;;305      }
;;;306      return bitstatus;
;;;307    }
0000f8  4770              BX       lr
                  |L1.250|
0000fa  2000              MOVS     r0,#0                 ;304
0000fc  4770              BX       lr
;;;308    
                          ENDP

                  RTC_ClearITPendingBit PROC
;;;317      */
;;;318    void RTC_ClearITPendingBit(uint16_t RTC_IT)
0000fe  4903              LDR      r1,|L1.268|
;;;319    {
;;;320      /* Check the parameters */
;;;321      assert_param(IS_RTC_IT(RTC_IT));  
;;;322      
;;;323      /* Clear the corresponding RTC pending bit */
;;;324      RTC->CRL &= (uint16_t)~RTC_IT;
000100  1d09              ADDS     r1,r1,#4
000102  880a              LDRH     r2,[r1,#0]
000104  4382              BICS     r2,r2,r0
000106  800a              STRH     r2,[r1,#0]
;;;325    }
000108  4770              BX       lr
;;;326    
                          ENDP

00010a  0000              DCW      0x0000
                  |L1.268|
                          DCD      0x40002800
