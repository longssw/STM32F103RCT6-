; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_adc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_adc.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_adc.crf ..\..\BSP\bsp_adc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  adc_init PROC
;;;74     
;;;75     void adc_init(void)
000000  b510              PUSH     {r4,lr}
;;;76     {
000002  b08c              SUB      sp,sp,#0x30
;;;77         Adc_Init();
000004  f7fffffe          BL       Adc_Init
000008  2101              MOVS     r1,#1
00000a  4608              MOV      r0,r1
00000c  f7fffffe          BL       RCC_AHBPeriphClockCmd
000010  4c36              LDR      r4,|L1.236|
000012  4620              MOV      r0,r4
000014  f7fffffe          BL       DMA_DeInit
000018  4835              LDR      r0,|L1.240|
00001a  9000              STR      r0,[sp,#0]
00001c  4835              LDR      r0,|L1.244|
00001e  2100              MOVS     r1,#0
000020  e9cd0101          STRD     r0,r1,[sp,#4]
000024  2001              MOVS     r0,#1
000026  e9cd0103          STRD     r0,r1,[sp,#0xc]
00002a  2080              MOVS     r0,#0x80
00002c  9005              STR      r0,[sp,#0x14]
00002e  0040              LSLS     r0,r0,#1
000030  9006              STR      r0,[sp,#0x18]
000032  0080              LSLS     r0,r0,#2
000034  9007              STR      r0,[sp,#0x1c]
000036  2020              MOVS     r0,#0x20
000038  9008              STR      r0,[sp,#0x20]
00003a  0200              LSLS     r0,r0,#8
00003c  e9cd0109          STRD     r0,r1,[sp,#0x24]
000040  4669              MOV      r1,sp
000042  4620              MOV      r0,r4
000044  f7fffffe          BL       DMA_Init
000048  2101              MOVS     r1,#1
00004a  4620              MOV      r0,r4
00004c  f7fffffe          BL       DMA_Cmd
;;;78         DMA_Config();
;;;79     }
000050  b00c              ADD      sp,sp,#0x30
000052  bd10              POP      {r4,pc}
;;;80     
                          ENDP

                  Adc_Init PROC
;;;6      
;;;7      static void Adc_Init(void)
000054  b570              PUSH     {r4-r6,lr}
;;;8      {
;;;9          ADC_InitTypeDef ADC_InitStructure;
;;;10         GPIO_InitTypeDef GPIO_InitStructure;
;;;11     
;;;12         /* 使能ADC1时钟 */
;;;13         RCC_APB2PeriphClockCmd(RCC_APB2Periph_ADC1, ENABLE);
000056  2101              MOVS     r1,#1
000058  b086              SUB      sp,sp,#0x18           ;8
00005a  0248              LSLS     r0,r1,#9
00005c  f7fffffe          BL       RCC_APB2PeriphClockCmd
;;;14     
;;;15         RCC_ADCCLKConfig(RCC_PCLK2_Div6); // 设置ADC分频因子6 72M/6=12,ADC最大时间不能超过14M
000060  f44f4000          MOV      r0,#0x8000
000064  f7fffffe          BL       RCC_ADCCLKConfig
;;;16     
;;;17         GPIO_InitStructure.GPIO_Pin = GPIO_Pin_0;
000068  2501              MOVS     r5,#1
00006a  f8ad5014          STRH     r5,[sp,#0x14]
;;;18         GPIO_InitStructure.GPIO_Mode = GPIO_Mode_AIN; // 模拟输入
00006e  2400              MOVS     r4,#0
000070  f88d4017          STRB     r4,[sp,#0x17]
;;;19         GPIO_Init(GPIOB, &GPIO_InitStructure);
000074  a905              ADD      r1,sp,#0x14
000076  4820              LDR      r0,|L1.248|
000078  f7fffffe          BL       GPIO_Init
;;;20     
;;;21         // ADC配置
;;;22         ADC_DeInit(ADC1);                                                   // 复位ADC1
00007c  4e1c              LDR      r6,|L1.240|
00007e  3e4c              SUBS     r6,r6,#0x4c
000080  4630              MOV      r0,r6
000082  f7fffffe          BL       ADC_DeInit
;;;23         ADC_InitStructure.ADC_Mode = ADC_Mode_Independent;                  // 独立模式
;;;24         ADC_InitStructure.ADC_ScanConvMode = DISABLE;                       // 多通道模式
;;;25         ADC_InitStructure.ADC_ContinuousConvMode = ENABLE;                  // 多次转换
;;;26         ADC_InitStructure.ADC_ExternalTrigConv = ADC_ExternalTrigConv_None; // 不是外部触发启动
000086  f44f2060          MOV      r0,#0xe0000
00008a  e9cd0402          STRD     r0,r4,[sp,#8]
00008e  f88d4004          STRB     r4,[sp,#4]            ;24
000092  9400              STR      r4,[sp,#0]            ;24
000094  f88d5005          STRB     r5,[sp,#5]            ;25
;;;27         ADC_InitStructure.ADC_DataAlign = ADC_DataAlign_Right;              // 右对齐
;;;28         ADC_InitStructure.ADC_NbrOfChannel = 1;                             // ADC通道转换4
000098  f88d5010          STRB     r5,[sp,#0x10]
;;;29     
;;;30         // 初始化ADC
;;;31         ADC_Init(ADC1, &ADC_InitStructure);
00009c  4669              MOV      r1,sp
00009e  4630              MOV      r0,r6
0000a0  f7fffffe          BL       ADC_Init
;;;32         // 配置ADC 通道的转换顺序和采样时间
;;;33         ADC_RegularChannelConfig(ADC1, ADC_Channel_8, 1, ADC_SampleTime_55Cycles5);
0000a4  2305              MOVS     r3,#5
0000a6  2201              MOVS     r2,#1
0000a8  2108              MOVS     r1,#8
0000aa  4630              MOV      r0,r6
0000ac  f7fffffe          BL       ADC_RegularChannelConfig
;;;34     
;;;35         // 使能 DMA 通道
;;;36         ADC_DMACmd(ADC1, ENABLE);
0000b0  2101              MOVS     r1,#1
0000b2  4630              MOV      r0,r6
0000b4  f7fffffe          BL       ADC_DMACmd
;;;37         ADC_Cmd(ADC1, ENABLE);      // 使能指定的ADC1
0000b8  2101              MOVS     r1,#1
0000ba  4630              MOV      r0,r6
0000bc  f7fffffe          BL       ADC_Cmd
;;;38         ADC_ResetCalibration(ADC1); // 使能复位校准
0000c0  4630              MOV      r0,r6
0000c2  f7fffffe          BL       ADC_ResetCalibration
                  |L1.198|
;;;39     
;;;40         while (ADC_GetResetCalibrationStatus(ADC1))
0000c6  4630              MOV      r0,r6
0000c8  f7fffffe          BL       ADC_GetResetCalibrationStatus
0000cc  2800              CMP      r0,#0
0000ce  d1fa              BNE      |L1.198|
;;;41             ; // 等待复位校准结束
;;;42     
;;;43         ADC_StartCalibration(ADC1); // 开启AD校准
0000d0  4630              MOV      r0,r6
0000d2  f7fffffe          BL       ADC_StartCalibration
                  |L1.214|
;;;44     
;;;45         while (ADC_GetCalibrationStatus(ADC1))
0000d6  4630              MOV      r0,r6
0000d8  f7fffffe          BL       ADC_GetCalibrationStatus
0000dc  2800              CMP      r0,#0
0000de  d1fa              BNE      |L1.214|
;;;46             ; // 等待校准结束
;;;47     
;;;48         // 使能指定的ADC1的软件转换启动功能
;;;49         ADC_SoftwareStartConvCmd(ADC1, ENABLE);
0000e0  2101              MOVS     r1,#1
0000e2  4630              MOV      r0,r6
0000e4  f7fffffe          BL       ADC_SoftwareStartConvCmd
;;;50     }
0000e8  b006              ADD      sp,sp,#0x18
0000ea  bd70              POP      {r4-r6,pc}
;;;51     
                          ENDP

                  |L1.236|
                          DCD      0x40020008
                  |L1.240|
                          DCD      0x4001244c
                  |L1.244|
                          DCD      ||.data||
                  |L1.248|
                          DCD      0x40010c00

                          AREA ||.data||, DATA, ALIGN=1

                  AD_Value
000000  0000              DCB      0x00,0x00
