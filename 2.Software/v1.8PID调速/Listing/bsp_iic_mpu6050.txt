; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_iic_mpu6050.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_iic_mpu6050.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_iic_mpu6050.crf ..\..\BSP\bsp_iic_mpu6050.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  dmp_iic_write PROC
;;;6       */
;;;7      u8 dmp_iic_write(u8 addr, u8 reg, u8 len, u8 *buf)
000000  b538              PUSH     {r3-r5,lr}
;;;8      {
000002  460d              MOV      r5,r1
;;;9          return MPU6050.MPU_WriteLen(&MPU6050, addr, reg, len, buf);
000004  49dd              LDR      r1,|L1.892|
000006  9300              STR      r3,[sp,#0]
000008  4613              MOV      r3,r2
00000a  6e4c              LDR      r4,[r1,#0x64]  ; MPU6050
00000c  4601              MOV      r1,r0
00000e  462a              MOV      r2,r5
000010  48da              LDR      r0,|L1.892|
000012  47a0              BLX      r4
;;;10     }
000014  bd38              POP      {r3-r5,pc}
;;;11     
                          ENDP

                  dmp_iic_read PROC
;;;12     u8 dmp_iic_read(u8 addr, u8 reg, u8 len, u8 *buf)
000016  b538              PUSH     {r3-r5,lr}
;;;13     {
000018  460d              MOV      r5,r1
;;;14         return MPU6050.MPU_ReadLen(&MPU6050, addr, reg, len, buf);
00001a  49d8              LDR      r1,|L1.892|
00001c  9300              STR      r3,[sp,#0]
00001e  4613              MOV      r3,r2
000020  6e0c              LDR      r4,[r1,#0x60]  ; MPU6050
000022  4601              MOV      r1,r0
000024  462a              MOV      r2,r5
000026  48d5              LDR      r0,|L1.892|
000028  47a0              BLX      r4
;;;15     }
00002a  bd38              POP      {r3-r5,pc}
;;;16     
                          ENDP

                  MPU_ReadByte_t PROC
;;;22      */
;;;23     uint8_t MPU_ReadByte_t(const struct mpu6050 *mpuxx_type_t, uint8_t reg)
00002c  b570              PUSH     {r4-r6,lr}
;;;24     {
00002e  460d              MOV      r5,r1
;;;25         uint8_t data;
;;;26         /* 发送起始信号 */
;;;27         mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
000030  6941              LDR      r1,[r0,#0x14]
000032  4604              MOV      r4,r0                 ;24
000034  4788              BLX      r1
;;;28         /* 发送器件地址+写命令 */
;;;29         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 0);
000036  6aa2              LDR      r2,[r4,#0x28]
000038  21d0              MOVS     r1,#0xd0
00003a  4620              MOV      r0,r4
00003c  4790              BLX      r2
;;;30         /* 等待应答 */
;;;31         mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
00003e  69e1              LDR      r1,[r4,#0x1c]
000040  4620              MOV      r0,r4
000042  4788              BLX      r1
;;;32         /* 写寄存器地址 */
;;;33         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
000044  6aa2              LDR      r2,[r4,#0x28]
000046  4629              MOV      r1,r5
000048  4620              MOV      r0,r4
00004a  4790              BLX      r2
;;;34         /* 等待应答 */
;;;35         mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
00004c  69e1              LDR      r1,[r4,#0x1c]
00004e  4620              MOV      r0,r4
000050  4788              BLX      r1
;;;36         /* 发送起始信号 */
;;;37         mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
000052  6961              LDR      r1,[r4,#0x14]
000054  4620              MOV      r0,r4
000056  4788              BLX      r1
;;;38         /* 发送器件地址+读命令 */
;;;39         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 1);
000058  6aa2              LDR      r2,[r4,#0x28]
00005a  21d1              MOVS     r1,#0xd1
00005c  4620              MOV      r0,r4
00005e  4790              BLX      r2
;;;40         /* 等待应答 */
;;;41         mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
000060  69e1              LDR      r1,[r4,#0x1c]
000062  4620              MOV      r0,r4
000064  4788              BLX      r1
;;;42         /* 读取数据 发送NACK*/
;;;43         data = mpuxx_type_t->IIC.IIC_Read_Byte(&mpuxx_type_t->IIC, 0);
000066  6ae2              LDR      r2,[r4,#0x2c]
000068  2100              MOVS     r1,#0
00006a  4620              MOV      r0,r4
00006c  4790              BLX      r2
00006e  4605              MOV      r5,r0
;;;44         mpuxx_type_t->IIC.IIC_NAck(&mpuxx_type_t->IIC);
000070  6a61              LDR      r1,[r4,#0x24]
000072  4620              MOV      r0,r4
000074  4788              BLX      r1
;;;45         /* 发送停止信号 */
;;;46         mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
000076  69a1              LDR      r1,[r4,#0x18]
000078  4620              MOV      r0,r4
00007a  4788              BLX      r1
;;;47     
;;;48         return data;
00007c  4628              MOV      r0,r5
;;;49     }
00007e  bd70              POP      {r4-r6,pc}
;;;50     
                          ENDP

                  MPU_WriteByte_t PROC
;;;57      */
;;;58     uint8_t MPU_WriteByte_t(const struct mpu6050 *mpuxx_type_t, uint8_t reg, uint8_t data)
000080  b570              PUSH     {r4-r6,lr}
;;;59     {
000082  460e              MOV      r6,r1
;;;60         mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
000084  6941              LDR      r1,[r0,#0x14]
000086  4615              MOV      r5,r2                 ;59
000088  4604              MOV      r4,r0                 ;59
00008a  4788              BLX      r1
;;;61         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 0);
00008c  6aa2              LDR      r2,[r4,#0x28]
00008e  21d0              MOVS     r1,#0xd0
000090  4620              MOV      r0,r4
000092  4790              BLX      r2
;;;62     
;;;63         /* 等待应答 */
;;;64         if (mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))
000094  69e1              LDR      r1,[r4,#0x1c]
000096  4620              MOV      r0,r4
000098  4788              BLX      r1
00009a  b998              CBNZ     r0,|L1.196|
;;;65         {
;;;66             mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;67             return 1;
;;;68         }
;;;69         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
00009c  6aa3              LDR      r3,[r4,#0x28]
00009e  4631              MOV      r1,r6
0000a0  4620              MOV      r0,r4
0000a2  4798              BLX      r3
;;;70         mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
0000a4  69e1              LDR      r1,[r4,#0x1c]
0000a6  4620              MOV      r0,r4
0000a8  4788              BLX      r1
;;;71         /* 发送数据 */
;;;72         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, data);
0000aa  6aa2              LDR      r2,[r4,#0x28]
0000ac  4629              MOV      r1,r5
0000ae  4620              MOV      r0,r4
0000b0  4790              BLX      r2
;;;73         /* 等待应答 */
;;;74         if (!mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))
0000b2  69e1              LDR      r1,[r4,#0x1c]
0000b4  4620              MOV      r0,r4
0000b6  4788              BLX      r1
0000b8  b120              CBZ      r0,|L1.196|
;;;75         {
;;;76             mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;77             return 1;
;;;78         }
;;;79         mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
0000ba  69a1              LDR      r1,[r4,#0x18]
0000bc  4620              MOV      r0,r4
0000be  4788              BLX      r1
;;;80     
;;;81         return 0;
0000c0  2000              MOVS     r0,#0
;;;82     }
0000c2  bd70              POP      {r4-r6,pc}
                  |L1.196|
0000c4  69a1              LDR      r1,[r4,#0x18]         ;76
0000c6  4620              MOV      r0,r4                 ;76
0000c8  4788              BLX      r1                    ;76
0000ca  2001              MOVS     r0,#1                 ;77
0000cc  bd70              POP      {r4-r6,pc}
;;;83     
                          ENDP

                  MPU_ReadLen_t PROC
;;;92      */
;;;93     uint8_t MPU_ReadLen_t(const struct mpu6050 *mpuxx_type_t,
0000ce  e92d41f0          PUSH     {r4-r8,lr}
;;;94                           uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf)
;;;95     {
0000d2  460f              MOV      r7,r1
;;;96     #if 0
;;;97         mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
;;;98         /* 发送器件地址+写命令 */
;;;99         mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 0);
;;;100    
;;;101        /* 等待应答 */
;;;102        if (mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))
;;;103        {
;;;104            mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;105            return 1;
;;;106        }
;;;107        /* 写寄存器地址 */
;;;108        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
;;;109        /* 等待应答 */
;;;110        mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
;;;111    
;;;112        mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
;;;113        /* 发送器件地址+读命令 */
;;;114        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (addr << 1) | 1);
;;;115        /* 等待应答 */
;;;116        mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
;;;117    
;;;118        while (len)
;;;119        {
;;;120            if (len == 1)
;;;121            {
;;;122                /* 读数据,发送nACK  */
;;;123                mpuxx_type_t->IIC.IIC_Read_Byte(&mpuxx_type_t->IIC, 0);
;;;124                mpuxx_type_t->IIC.IIC_NAck(&mpuxx_type_t->IIC);
;;;125            }
;;;126    
;;;127            //*buf = MPU_IIC_Read_Byte(0); // 读数据,发送nACK
;;;128            else
;;;129            {
;;;130                /* 读数据,发送ACK  */
;;;131                mpuxx_type_t->IIC.IIC_Read_Byte(&mpuxx_type_t->IIC, 1);
;;;132                mpuxx_type_t->IIC.IIC_Ack(&mpuxx_type_t->IIC);
;;;133            }
;;;134    
;;;135            //*buf = MPU_IIC_Read_Byte(1); // 读数据,发送ACK
;;;136            len--;
;;;137            buf++;
;;;138        }
;;;139        /* 发送停止信号 */
;;;140        mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;141    
;;;142        return 0;
;;;143    #else
;;;144        // MPU_IIC_Start();
;;;145        mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
0000d4  6941              LDR      r1,[r0,#0x14]
0000d6  461d              MOV      r5,r3                 ;95
0000d8  4690              MOV      r8,r2                 ;95
0000da  4604              MOV      r4,r0                 ;95
0000dc  9e06              LDR      r6,[sp,#0x18]
0000de  4788              BLX      r1
;;;146        // MPU_IIC_Send_Byte((addr << 1) | 0); // 发送器件地址+写命令
;;;147        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 0);
0000e0  6aa2              LDR      r2,[r4,#0x28]
0000e2  21d0              MOVS     r1,#0xd0
0000e4  4620              MOV      r0,r4
0000e6  4790              BLX      r2
;;;148        // if (MPU_IIC_Wait_Ack())             // 等待应答
;;;149        //  {
;;;150        //      MPU_IIC_Stop();
;;;151        //      return 1;
;;;152        //  }
;;;153        if (mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))
0000e8  69e1              LDR      r1,[r4,#0x1c]
0000ea  4620              MOV      r0,r4
0000ec  4788              BLX      r1
0000ee  b128              CBZ      r0,|L1.252|
;;;154        {
;;;155            mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
0000f0  69a1              LDR      r1,[r4,#0x18]
0000f2  4620              MOV      r0,r4
0000f4  4788              BLX      r1
;;;156            // MPU_IIC_Stop();
;;;157            return 1;
0000f6  2001              MOVS     r0,#1
                  |L1.248|
;;;158        }
;;;159    
;;;160        // MPU_IIC_Send_Byte(reg); // 写寄存器地址
;;;161        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
;;;162        // mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
;;;163        // MPU_IIC_Wait_Ack(); // 等待应答
;;;164        mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
;;;165        // mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
;;;166        // MPU_IIC_Start();
;;;167        mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
;;;168        // MPU_IIC_Send_Byte((addr << 1) | 1); // 发送器件地址+读命令
;;;169        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (addr << 1) | 1);
;;;170        // MPU_IIC_Wait_Ack();                 // 等待应答
;;;171        mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
;;;172        while (len)
;;;173        {
;;;174            if (len == 1)
;;;175            {
;;;176                //*buf = MPU_IIC_Read_Byte(0); // 读数据,发送nACK
;;;177                *buf = mpuxx_type_t->IIC.IIC_Read_Byte(&mpuxx_type_t->IIC, 0);
;;;178                mpuxx_type_t->IIC.IIC_NAck(&mpuxx_type_t->IIC);
;;;179            }
;;;180    
;;;181            else
;;;182            {
;;;183                //*buf = MPU_IIC_Read_Byte(1); // 读数据,发送ACK
;;;184                *buf = mpuxx_type_t->IIC.IIC_Read_Byte(&mpuxx_type_t->IIC, 1);
;;;185                mpuxx_type_t->IIC.IIC_Ack(&mpuxx_type_t->IIC);
;;;186                // MPU_IIC_Ack();
;;;187            }
;;;188    
;;;189            len--;
;;;190            buf++;
;;;191        }
;;;192        // MPU_IIC_Stop(); // 产生一个停止条件
;;;193        mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;194        return 0;
;;;195    #endif
;;;196    }
0000f8  e8bd81f0          POP      {r4-r8,pc}
                  |L1.252|
0000fc  6aa2              LDR      r2,[r4,#0x28]         ;161
0000fe  4641              MOV      r1,r8                 ;161
000100  4620              MOV      r0,r4                 ;161
000102  4790              BLX      r2                    ;161
000104  69e1              LDR      r1,[r4,#0x1c]         ;164
000106  4620              MOV      r0,r4                 ;164
000108  4788              BLX      r1                    ;164
00010a  6961              LDR      r1,[r4,#0x14]         ;167
00010c  4620              MOV      r0,r4                 ;167
00010e  4788              BLX      r1                    ;167
000110  2001              MOVS     r0,#1                 ;169
000112  eb000047          ADD      r0,r0,r7,LSL #1       ;169
000116  b2c1              UXTB     r1,r0                 ;169
000118  6aa2              LDR      r2,[r4,#0x28]         ;169
00011a  4620              MOV      r0,r4                 ;169
00011c  4790              BLX      r2                    ;169
00011e  69e1              LDR      r1,[r4,#0x1c]         ;171
000120  4620              MOV      r0,r4                 ;171
000122  4788              BLX      r1                    ;171
000124  e00c              B        |L1.320|
                  |L1.294|
000126  6ae2              LDR      r2,[r4,#0x2c]         ;174
000128  2d01              CMP      r5,#1                 ;174
00012a  d010              BEQ      |L1.334|
00012c  2101              MOVS     r1,#1                 ;184
00012e  4620              MOV      r0,r4                 ;184
000130  4790              BLX      r2                    ;184
000132  7030              STRB     r0,[r6,#0]            ;184
000134  6a21              LDR      r1,[r4,#0x20]         ;185
                  |L1.310|
000136  4620              MOV      r0,r4                 ;185
000138  4788              BLX      r1                    ;185
00013a  1e6d              SUBS     r5,r5,#1              ;185
00013c  b2ed              UXTB     r5,r5                 ;189
00013e  1c76              ADDS     r6,r6,#1              ;189
                  |L1.320|
000140  2d00              CMP      r5,#0                 ;172
000142  d1f0              BNE      |L1.294|
000144  69a1              LDR      r1,[r4,#0x18]         ;193
000146  4620              MOV      r0,r4                 ;193
000148  4788              BLX      r1                    ;193
00014a  2000              MOVS     r0,#0                 ;194
00014c  e7d4              B        |L1.248|
                  |L1.334|
00014e  2100              MOVS     r1,#0                 ;177
000150  4620              MOV      r0,r4                 ;177
000152  4790              BLX      r2                    ;177
000154  7030              STRB     r0,[r6,#0]            ;177
000156  6a61              LDR      r1,[r4,#0x24]         ;178
000158  e7ed              B        |L1.310|
;;;197    
                          ENDP

                  MPU_WriteLen_t PROC
;;;206     */
;;;207    uint8_t MPU_WriteLen_t(const struct mpu6050 *mpuxx_type_t,
00015a  e92d41f0          PUSH     {r4-r8,lr}
;;;208                           uint8_t addr, uint8_t reg, uint8_t len, uint8_t *buf)
;;;209    {
;;;210        uint8_t i;
;;;211        mpuxx_type_t->IIC.IIC_Start(&mpuxx_type_t->IIC);
00015e  6941              LDR      r1,[r0,#0x14]
000160  461e              MOV      r6,r3                 ;209
000162  4615              MOV      r5,r2                 ;209
000164  4604              MOV      r4,r0                 ;209
000166  9f06              LDR      r7,[sp,#0x18]
000168  4788              BLX      r1
;;;212        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, (MPU_ADDR << 1) | 0);
00016a  6aa2              LDR      r2,[r4,#0x28]
00016c  21d0              MOVS     r1,#0xd0
00016e  4620              MOV      r0,r4
000170  4790              BLX      r2
;;;213    
;;;214        /* 等待应答 */
;;;215        if (mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))
000172  69e1              LDR      r1,[r4,#0x1c]
000174  4620              MOV      r0,r4
000176  4788              BLX      r1
000178  b980              CBNZ     r0,|L1.412|
;;;216        {
;;;217            mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;218            return 1;
;;;219        }
;;;220        mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, reg);
00017a  6aa2              LDR      r2,[r4,#0x28]
00017c  4629              MOV      r1,r5
00017e  4620              MOV      r0,r4
000180  4790              BLX      r2
;;;221        mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC);
000182  69e1              LDR      r1,[r4,#0x1c]
000184  4620              MOV      r0,r4
000186  4788              BLX      r1
;;;222    
;;;223        for (i = 0; i < len; i++)
000188  2500              MOVS     r5,#0
00018a  e00e              B        |L1.426|
                  |L1.396|
;;;224        {
;;;225            mpuxx_type_t->IIC.IIC_Send_Byte(&mpuxx_type_t->IIC, buf[i]); // 发送数据
00018c  6aa2              LDR      r2,[r4,#0x28]
00018e  5d79              LDRB     r1,[r7,r5]
000190  4620              MOV      r0,r4
000192  4790              BLX      r2
;;;226            if (mpuxx_type_t->IIC.IIC_Wait_Ack(&mpuxx_type_t->IIC))      // 等待ACK
000194  69e1              LDR      r1,[r4,#0x1c]
000196  4620              MOV      r0,r4
000198  4788              BLX      r1
00019a  b120              CBZ      r0,|L1.422|
                  |L1.412|
;;;227            {
;;;228                mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
00019c  69a1              LDR      r1,[r4,#0x18]
00019e  4620              MOV      r0,r4
0001a0  4788              BLX      r1
;;;229                return 1;
0001a2  2001              MOVS     r0,#1
;;;230            }
;;;231        }
;;;232        mpuxx_type_t->IIC.IIC_Stop(&mpuxx_type_t->IIC);
;;;233    
;;;234        return 0;
;;;235    }
0001a4  e7a8              B        |L1.248|
                  |L1.422|
0001a6  1c6d              ADDS     r5,r5,#1
0001a8  b2ed              UXTB     r5,r5                 ;223
                  |L1.426|
0001aa  42b5              CMP      r5,r6                 ;223
0001ac  d3ee              BCC      |L1.396|
0001ae  69a1              LDR      r1,[r4,#0x18]         ;232
0001b0  4620              MOV      r0,r4                 ;232
0001b2  4788              BLX      r1                    ;232
0001b4  2000              MOVS     r0,#0                 ;234
0001b6  e79f              B        |L1.248|
;;;236    
                          ENDP

                  MPU_SetGyroFsr_t PROC
;;;243     */
;;;244    uint8_t MPU_SetGyroFsr_t(const struct mpu6050 *mpuxx_type_t, uint8_t fsr)
0001b8  06c9              LSLS     r1,r1,#27
;;;245    {
;;;246        return mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_GYRO_CFG_REG, fsr << 3);
0001ba  0e0a              LSRS     r2,r1,#24
0001bc  6dc3              LDR      r3,[r0,#0x5c]
0001be  211b              MOVS     r1,#0x1b
0001c0  4718              BX       r3
;;;247    }
;;;248    
                          ENDP

                  MPU_SetAccelFsr_t PROC
;;;255     */
;;;256    uint8_t MPU_SetAccelFsr_t(const struct mpu6050 *mpuxx_type_t, uint8_t fsr)
0001c2  06c9              LSLS     r1,r1,#27
;;;257    {
;;;258        return mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_ACCEL_CFG_REG, fsr << 3);
0001c4  0e0a              LSRS     r2,r1,#24
0001c6  6dc3              LDR      r3,[r0,#0x5c]
0001c8  211c              MOVS     r1,#0x1c
0001ca  4718              BX       r3
;;;259    }
;;;260    
                          ENDP

                  MPU_SetLPF_t PROC
;;;267     */
;;;268    uint8_t MPU_SetLPF_t(const struct mpu6050 *mpuxx_type_t, uint16_t lpf)
0001cc  29bc              CMP      r1,#0xbc
;;;269    {
0001ce  d301              BCC      |L1.468|
;;;270        uint8_t data = 0;
;;;271        if (lpf >= 188)
;;;272            data = 1;
0001d0  2201              MOVS     r2,#1
0001d2  e010              B        |L1.502|
                  |L1.468|
;;;273        else if (lpf >= 98)
0001d4  2962              CMP      r1,#0x62
0001d6  d301              BCC      |L1.476|
;;;274            data = 2;
0001d8  2202              MOVS     r2,#2
0001da  e00c              B        |L1.502|
                  |L1.476|
;;;275        else if (lpf >= 42)
0001dc  292a              CMP      r1,#0x2a
0001de  d301              BCC      |L1.484|
;;;276            data = 3;
0001e0  2203              MOVS     r2,#3
0001e2  e008              B        |L1.502|
                  |L1.484|
;;;277        else if (lpf >= 20)
0001e4  2914              CMP      r1,#0x14
0001e6  d301              BCC      |L1.492|
;;;278            data = 4;
0001e8  2204              MOVS     r2,#4
0001ea  e004              B        |L1.502|
                  |L1.492|
;;;279        else if (lpf >= 10)
0001ec  290a              CMP      r1,#0xa
0001ee  d301              BCC      |L1.500|
;;;280            data = 5;
0001f0  2205              MOVS     r2,#5
0001f2  e000              B        |L1.502|
                  |L1.500|
;;;281        else
;;;282            data = 6;
0001f4  2206              MOVS     r2,#6
                  |L1.502|
;;;283        return mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_CFG_REG, data);
0001f6  6dc3              LDR      r3,[r0,#0x5c]
0001f8  211a              MOVS     r1,#0x1a
0001fa  4718              BX       r3
;;;284    }
;;;285    
                          ENDP

                  MPU_SetRate_t PROC
;;;292     */
;;;293    uint8_t MPU_SetRate_t(const struct mpu6050 *mpuxx_type_t, uint16_t rate)
0001fc  b570              PUSH     {r4-r6,lr}
;;;294    {
0001fe  4605              MOV      r5,r0
;;;295        uint8_t data = 0;
;;;296        if (rate > 1000)
000200  f44f707a          MOV      r0,#0x3e8
000204  460c              MOV      r4,r1                 ;294
000206  4281              CMP      r1,r0
000208  d901              BLS      |L1.526|
;;;297            rate = 1000;
00020a  4604              MOV      r4,r0
00020c  e002              B        |L1.532|
                  |L1.526|
;;;298        if (rate < 4)
00020e  2c04              CMP      r4,#4
000210  d200              BCS      |L1.532|
;;;299            rate = 4;
000212  2404              MOVS     r4,#4
                  |L1.532|
;;;300        data = 1000 / rate - 1;
000214  fbb0f0f4          UDIV     r0,r0,r4
000218  1e40              SUBS     r0,r0,#1
00021a  b2c2              UXTB     r2,r0
;;;301        /* 设置数字低通滤波器 */
;;;302        data = mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_SAMPLE_RATE_REG, data);
00021c  6deb              LDR      r3,[r5,#0x5c]
00021e  2119              MOVS     r1,#0x19
000220  4628              MOV      r0,r5
000222  4798              BLX      r3
;;;303        /* 自动设置LPF为采样率的一半 */
;;;304        return mpuxx_type_t->MPU_SetLPF(mpuxx_type_t, rate / 2);
000224  0861              LSRS     r1,r4,#1
000226  4628              MOV      r0,r5
000228  6f2a              LDR      r2,[r5,#0x70]
00022a  e8bd4070          POP      {r4-r6,lr}
00022e  4710              BX       r2
;;;305    }
;;;306    
                          ENDP

                  MPU_Init_t PROC
;;;307    uint8_t MPU_Init_t(const struct mpu6050 *mpuxx_type_t)
000230  b570              PUSH     {r4-r6,lr}
;;;308    {
;;;309        uint8_t mpu_id;
;;;310    
;;;311        /* 初始化IIC总线 */
;;;312        mpuxx_type_t->IIC.IIC_Init(&mpuxx_type_t->IIC);
000232  6901              LDR      r1,[r0,#0x10]
000234  4604              MOV      r4,r0                 ;308
000236  4788              BLX      r1
;;;313        /* 复位MPU6050 */
;;;314        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_PWR_MGMT1_REG, 0X80);
000238  2280              MOVS     r2,#0x80
00023a  6de3              LDR      r3,[r4,#0x5c]
00023c  216b              MOVS     r1,#0x6b
00023e  4620              MOV      r0,r4
000240  4798              BLX      r3
;;;315        /* 延时等待复位完成 */
;;;316        mpuxx_type_t->IIC.delay_us(100000);
000242  6b21              LDR      r1,[r4,#0x30]
000244  484e              LDR      r0,|L1.896|
000246  4788              BLX      r1
;;;317        /* 唤醒MPU6050 */
;;;318        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_PWR_MGMT1_REG, 0X00);
000248  2200              MOVS     r2,#0
00024a  6de3              LDR      r3,[r4,#0x5c]
00024c  216b              MOVS     r1,#0x6b
00024e  4620              MOV      r0,r4
000250  4798              BLX      r3
;;;319        /* 设置陀螺仪量程 ±2000dps */
;;;320        mpuxx_type_t->MPU_SetGyroFsr(mpuxx_type_t, 3);
000252  6ea2              LDR      r2,[r4,#0x68]
000254  2103              MOVS     r1,#3
000256  4620              MOV      r0,r4
000258  4790              BLX      r2
;;;321        /* 设置加速度量程 ±8g */
;;;322        mpuxx_type_t->MPU_SetAccelFsr(mpuxx_type_t, 2);
00025a  6ee2              LDR      r2,[r4,#0x6c]
00025c  2102              MOVS     r1,#2
00025e  4620              MOV      r0,r4
000260  4790              BLX      r2
;;;323        /* 设置采样率50Hz */
;;;324        mpuxx_type_t->MPU_SetRate(mpuxx_type_t, 200);
000262  6f62              LDR      r2,[r4,#0x74]
000264  21c8              MOVS     r1,#0xc8
000266  4620              MOV      r0,r4
000268  4790              BLX      r2
;;;325        /* 关闭所有中断 */
;;;326        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_INT_EN_REG, 0X00);
00026a  2200              MOVS     r2,#0
00026c  6de3              LDR      r3,[r4,#0x5c]
00026e  2138              MOVS     r1,#0x38
000270  4620              MOV      r0,r4
000272  4798              BLX      r3
;;;327        /* I2C主模式关闭 */
;;;328        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_USER_CTRL_REG, 0X00);
000274  2200              MOVS     r2,#0
000276  6de3              LDR      r3,[r4,#0x5c]
000278  216a              MOVS     r1,#0x6a
00027a  4620              MOV      r0,r4
00027c  4798              BLX      r3
;;;329        /* 关闭FIFO */
;;;330        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_FIFO_EN_REG, 0X00);
00027e  2200              MOVS     r2,#0
000280  6de3              LDR      r3,[r4,#0x5c]
000282  2123              MOVS     r1,#0x23
000284  4620              MOV      r0,r4
000286  4798              BLX      r3
;;;331        /* INT引脚低电平有效 */
;;;332        mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_INTBP_CFG_REG, 0X80);
000288  2280              MOVS     r2,#0x80
00028a  6de3              LDR      r3,[r4,#0x5c]
00028c  2137              MOVS     r1,#0x37
00028e  4620              MOV      r0,r4
000290  4798              BLX      r3
;;;333        /* 读取器件ID */
;;;334        mpu_id = mpuxx_type_t->MPU_ReadByte(mpuxx_type_t, MPU_DEVICE_ID_REG);
000292  6da2              LDR      r2,[r4,#0x58]
000294  2175              MOVS     r1,#0x75
000296  4620              MOV      r0,r4
000298  4790              BLX      r2
00029a  4605              MOV      r5,r0
;;;335    
;;;336        /* 器件ID正确 */
;;;337        if (mpu_id == MPU_ADDR)
00029c  2868              CMP      r0,#0x68
00029e  d10d              BNE      |L1.700|
;;;338        {
;;;339            /* 设置CLKSEL,PLL X轴为参考 */
;;;340            mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_PWR_MGMT1_REG, 0X01);
0002a0  2201              MOVS     r2,#1
0002a2  6de3              LDR      r3,[r4,#0x5c]
0002a4  216b              MOVS     r1,#0x6b
0002a6  4620              MOV      r0,r4
0002a8  4798              BLX      r3
;;;341            /* 加速度与陀螺仪都工作 */
;;;342            mpuxx_type_t->MPU_WriteByte(mpuxx_type_t, MPU_PWR_MGMT2_REG, 0X00);
0002aa  2200              MOVS     r2,#0
0002ac  6de3              LDR      r3,[r4,#0x5c]
0002ae  216c              MOVS     r1,#0x6c
0002b0  4620              MOV      r0,r4
0002b2  4798              BLX      r3
;;;343            /* 设置采样率为50Hz ps:此处代码存疑 */
;;;344            mpuxx_type_t->MPU_SetRate(mpuxx_type_t, 100);
0002b4  6f62              LDR      r2,[r4,#0x74]
0002b6  2164              MOVS     r1,#0x64
0002b8  4620              MOV      r0,r4
0002ba  4790              BLX      r2
                  |L1.700|
;;;345        }
;;;346        return mpu_id;
0002bc  4628              MOV      r0,r5
;;;347    }
0002be  bd70              POP      {r4-r6,pc}
;;;348    
                          ENDP

                  MPU_GetGyroscope_t PROC
;;;349    uint8_t MPU_GetGyroscope_t(const struct mpu6050 *mpuxx_type_t, short *gx, short *gy, short *gz)
0002c0  b5fe              PUSH     {r1-r7,lr}
;;;350    {
0002c2  460e              MOV      r6,r1
;;;351        uint8_t buf[6], res;
;;;352        res = mpuxx_type_t->MPU_ReadLen(mpuxx_type_t, MPU_ADDR, MPU_GYRO_XOUTH_REG, 6, buf);
0002c4  a901              ADD      r1,sp,#4
0002c6  461c              MOV      r4,r3                 ;350
0002c8  4615              MOV      r5,r2                 ;350
0002ca  9100              STR      r1,[sp,#0]
0002cc  2306              MOVS     r3,#6
0002ce  2243              MOVS     r2,#0x43
0002d0  6e07              LDR      r7,[r0,#0x60]
0002d2  2168              MOVS     r1,#0x68
0002d4  47b8              BLX      r7
;;;353        if (res == 0)
0002d6  2800              CMP      r0,#0
0002d8  d10b              BNE      |L1.754|
;;;354        {
;;;355            *gx = ((u16)buf[0] << 8) | buf[1];
0002da  f8bd1004          LDRH     r1,[sp,#4]
0002de  ba49              REV16    r1,r1
0002e0  8031              STRH     r1,[r6,#0]
;;;356            *gy = ((u16)buf[2] << 8) | buf[3];
0002e2  f8bd1006          LDRH     r1,[sp,#6]
0002e6  ba49              REV16    r1,r1
0002e8  8029              STRH     r1,[r5,#0]
;;;357            *gz = ((u16)buf[4] << 8) | buf[5];
0002ea  f8bd1008          LDRH     r1,[sp,#8]
0002ee  ba49              REV16    r1,r1
0002f0  8021              STRH     r1,[r4,#0]
                  |L1.754|
;;;358        }
;;;359        return res;
;;;360    }
0002f2  bdfe              POP      {r1-r7,pc}
;;;361    
                          ENDP

                  read_accel PROC
;;;362    uint8_t read_accel(const struct mpu6050 *mpuxx_type_t, short *ax, short *ay, short *az)
0002f4  b5fe              PUSH     {r1-r7,lr}
;;;363    {
0002f6  460e              MOV      r6,r1
;;;364        uint8_t buf[6], res;
;;;365        res = mpuxx_type_t->MPU_ReadLen(mpuxx_type_t, MPU_ADDR, MPU_ACCEL_XOUTH_REG, 6, buf);
0002f8  a901              ADD      r1,sp,#4
0002fa  461c              MOV      r4,r3                 ;363
0002fc  4615              MOV      r5,r2                 ;363
0002fe  9100              STR      r1,[sp,#0]
000300  2306              MOVS     r3,#6
000302  223b              MOVS     r2,#0x3b
000304  6e07              LDR      r7,[r0,#0x60]
000306  2168              MOVS     r1,#0x68
000308  47b8              BLX      r7
;;;366        if (res == 0)
00030a  2800              CMP      r0,#0
00030c  d10b              BNE      |L1.806|
;;;367        {
;;;368            *ax = ((u16)buf[0] << 8) | buf[1];
00030e  f8bd1004          LDRH     r1,[sp,#4]
000312  ba49              REV16    r1,r1
000314  8031              STRH     r1,[r6,#0]
;;;369            *ay = ((u16)buf[2] << 8) | buf[3];
000316  f8bd1006          LDRH     r1,[sp,#6]
00031a  ba49              REV16    r1,r1
00031c  8029              STRH     r1,[r5,#0]
;;;370            *az = ((u16)buf[4] << 8) | buf[5];
00031e  f8bd1008          LDRH     r1,[sp,#8]
000322  ba49              REV16    r1,r1
000324  8021              STRH     r1,[r4,#0]
                  |L1.806|
;;;371        }
;;;372        return res;
;;;373    }
000326  bdfe              POP      {r1-r7,pc}
;;;374    
                          ENDP

                  mpu6050_init PROC
;;;375    uint8_t mpu6050_init(struct mpu6050 *mpuxx_type_t)
000328  b510              PUSH     {r4,lr}
;;;376    {
00032a  4604              MOV      r4,r0
;;;377        create_iic(&mpuxx_type_t->IIC);
00032c  f7fffffe          BL       create_iic
;;;378    
;;;379        mpuxx_type_t->MPU_ReadByte = MPU_ReadByte_t;
000330  f2af3007          ADR      r0,MPU_ReadByte_t + 1
;;;380        mpuxx_type_t->MPU_WriteByte = MPU_WriteByte_t;
000334  65a0              STR      r0,[r4,#0x58]
000336  f2af20b7          ADR      r0,MPU_WriteByte_t + 1
;;;381        mpuxx_type_t->MPU_ReadLen = MPU_ReadLen_t;
00033a  65e0              STR      r0,[r4,#0x5c]
00033c  f2af2071          ADR      r0,MPU_ReadLen_t + 1
;;;382        mpuxx_type_t->MPU_WriteLen = MPU_WriteLen_t;
000340  6620              STR      r0,[r4,#0x60]
000342  f2af10e9          ADR      r0,MPU_WriteLen_t + 1
;;;383    
;;;384        mpuxx_type_t->MPU_SetGyroFsr = MPU_SetGyroFsr_t;
000346  6660              STR      r0,[r4,#0x64]
000348  f2af1093          ADR      r0,MPU_SetGyroFsr_t + 1
;;;385        mpuxx_type_t->MPU_SetAccelFsr = MPU_SetAccelFsr_t;
00034c  66a0              STR      r0,[r4,#0x68]
00034e  f2af108d          ADR      r0,MPU_SetAccelFsr_t + 1
;;;386        mpuxx_type_t->MPU_SetLPF = MPU_SetLPF_t;
000352  66e0              STR      r0,[r4,#0x6c]
000354  f2af108b          ADR      r0,MPU_SetLPF_t + 1
;;;387        mpuxx_type_t->MPU_SetRate = MPU_SetRate_t;
000358  6720              STR      r0,[r4,#0x70]
00035a  f2af105f          ADR      r0,MPU_SetRate_t + 1
;;;388    
;;;389        mpuxx_type_t->init = MPU_Init_t;
00035e  6760              STR      r0,[r4,#0x74]
000360  f2af1033          ADR      r0,MPU_Init_t + 1
;;;390        mpuxx_type_t->read_gyro = MPU_GetGyroscope_t;
000364  67a0              STR      r0,[r4,#0x78]
000366  f2af00a7          ADR      r0,MPU_GetGyroscope_t + 1
;;;391        mpuxx_type_t->read_accel = read_accel;
00036a  67e0              STR      r0,[r4,#0x7c]
00036c  f2af007b          ADR      r0,read_accel + 1
;;;392        /* 初始化陀螺仪 */
;;;393        return mpuxx_type_t->init(mpuxx_type_t);
000370  f8c40080          STR      r0,[r4,#0x80]
000374  4620              MOV      r0,r4
000376  e8bd4010          POP      {r4,lr}
00037a  e7fe              B        MPU_Init_t
;;;394    }
                          ENDP

                  |L1.892|
                          DCD      ||.bss||
                  |L1.896|
                          DCD      0x000186a0

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  MPU6050
                          %        132
