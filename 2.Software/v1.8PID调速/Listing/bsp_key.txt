; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\bsp_key.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\bsp_key.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\bsp_key.crf ..\..\User\key\bsp_key.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  key_proc PROC
;;;68      */
;;;69     void key_proc(struct key *key)
000000  b510              PUSH     {r4,lr}
;;;70     {
000002  4604              MOV      r4,r0
000004  8880              LDRH     r0,[r0,#4]
000006  b281              UXTH     r1,r0
000008  6820              LDR      r0,[r4,#0]
00000a  f7fffffe          BL       GPIO_ReadInputDataBit
;;;71     	uint8_t key_level;
;;;72     	enum key_trigger_event event;
;;;73     
;;;74     	key_level = read_io(key);
;;;75     	event = KEY_EVENT_IDLE; /* 按键空闲 */
;;;76     
;;;77     	/* 检测按键 */
;;;78     	switch (key->step)
00000e  7a21              LDRB     r1,[r4,#8]
000010  2201              MOVS     r2,#1
000012  b189              CBZ      r1,|L1.56|
000014  2300              MOVS     r3,#0
000016  2901              CMP      r1,#1
000018  d012              BEQ      |L1.64|
00001a  2902              CMP      r1,#2
00001c  d01e              BEQ      |L1.92|
00001e  2903              CMP      r1,#3
000020  d10d              BNE      |L1.62|
;;;79     	{
;;;80     	case KEY_STEP_WAIT: /* 按键等待 */
;;;81     		if (key_level == KEY_PRESS_LEVEL)
;;;82     		{
;;;83     			KEY_LOG(DEBUG, "[KEY_STEP_WAIT]");
;;;84     			key->step = KEY_STEP_CLICK; /* [状态机]:按键???? */
;;;85     		}
;;;86     		break;
;;;87     	case KEY_STEP_CLICK: /* 按键单击 */
;;;88     		if (key_level == KEY_PRESS_LEVEL)
;;;89     		{
;;;90     			if (!(--key->click_time)) /* 达到消抖时间 */
;;;91     			{
;;;92     				KEY_LOG(DEBUG, "[KEY_CLICK] success!");
;;;93     				key->click_time = KEY_SHAKE_TIME; /* [重置]:消抖时间 */
;;;94     				event = KEY_EVENT_CLICK;		  /* [按键事件]:单击按下 */
;;;95     				key->step = KEY_STEP_LONG_PRESS;  /* [状态机]:按键长按 */
;;;96     			}
;;;97     		}
;;;98     		else /* 未达到消抖时间 */
;;;99     		{
;;;100    			key->click_time = KEY_SHAKE_TIME; /* [重置]:消抖时间 */
;;;101    			key->step = KEY_STEP_WAIT;		  /* [状态机]:按键等待 */
;;;102    		}
;;;103    		break;
;;;104    	case KEY_STEP_LONG_PRESS: /* 按键长按 */
;;;105    		if (key_level == KEY_PRESS_LEVEL)
;;;106    		{
;;;107    			if (!(--key->long_press_time)) /* 达到长按时间 */
;;;108    			{
;;;109    				KEY_LOG(DEBUG, "[KEY_LONG_PRESS] success!");
;;;110    				key->long_press_time = KEY_PRESS_LONG_TIME; /* [重置]:长按时间 */
;;;111    				event = KEY_EVENT_LONG_PRESS;				/* [按键事件]:按键长按 */
;;;112    				key->step = KEY_STEP_CONTINUOUS_PRESS;		/* [状态机]:按键持续长按 */
;;;113    			}
;;;114    		}
;;;115    		else
;;;116    		{
;;;117    			KEY_LOG(DEBUG, "[KEY_LONG_PRESS] fail! the time remaining is [%d]", key->long_press_time);
;;;118    			key->long_press_time = KEY_PRESS_LONG_TIME; /* [重置]:长按时间 */
;;;119    			key->step = KEY_STEP_WAIT;					/* [状态机]:按键等待 */
;;;120    			event = KEY_EVENT_CLICK_RELEASE;			/* [按键事件]:单击释放 */
;;;121    		}
;;;122    		break;
;;;123    	case KEY_STEP_CONTINUOUS_PRESS: /* 按键持续长按 */
;;;124    		if (key_level == KEY_PRESS_LEVEL)
;;;125    		{
;;;126    			if (!(--key->continue_press_time)) /* 达到持续长按间隔时间 */
;;;127    			{
;;;128    				KEY_LOG(DEBUG, "[KEY_STEP_CONTINUOUS_PRESS] success!");
;;;129    				event = KEY_EVENT_LONG_PRESS_CONTINUOUS; /* [按键事件]:持续长按 */
;;;130    				/*!
;;;131    				 * \brief   这里由于一直在重置时间所以长按持续事件只会调度一次?
;;;132    				 */
;;;133    				key->continue_press_time = KEY_PRESS_CONTINUE_TIME; /* [重置]:持续长按时间 */
000022  2105              MOVS     r1,#5
000024  b358              CBZ      r0,|L1.126|
;;;134    			}
;;;135    		}
;;;136    		else
;;;137    		{
;;;138    			KEY_LOG(DEBUG, "[KEY_STEP_CONTINUOUS_PRESS] fail! TIME == %d", key->continue_press_time);
;;;139    			key->step = KEY_STEP_WAIT;							/* [状态机]:按键等待 */
000026  7223              STRB     r3,[r4,#8]
;;;140    			key->continue_press_time = KEY_PRESS_CONTINUE_TIME; /* [重置]:持续长按时间 */
000028  81e1              STRH     r1,[r4,#0xe]
;;;141    			event = KEY_EVENT_LONG_PRESS_RELEASE;				/* [按键事件]:长按释放 */
00002a  2005              MOVS     r0,#5
                  |L1.44|
;;;142    		}
;;;143    		break;
;;;144    	}
;;;145    
;;;146    	if (event)
;;;147    	{
;;;148    		KEY_LOG(INFO, "event = %d", event);
;;;149    		if (key->func != NULL)
00002c  6921              LDR      r1,[r4,#0x10]
00002e  2900              CMP      r1,#0
000030  d005              BEQ      |L1.62|
;;;150    		{
;;;151    			key->func(event);
000032  e8bd4010          POP      {r4,lr}
000036  4708              BX       r1
                  |L1.56|
000038  2800              CMP      r0,#0                 ;81
00003a  d100              BNE      |L1.62|
00003c  7222              STRB     r2,[r4,#8]            ;84
                  |L1.62|
;;;152    		}
;;;153    		else
;;;154    		{
;;;155    			KEY_LOG(ERROR, "the func is unregistered");
;;;156    		}
;;;157    	}
;;;158    }
00003e  bd10              POP      {r4,pc}
                  |L1.64|
000040  b110              CBZ      r0,|L1.72|
000042  8162              STRH     r2,[r4,#0xa]          ;100
000044  7223              STRB     r3,[r4,#8]            ;101
                  |L1.70|
000046  bd10              POP      {r4,pc}
                  |L1.72|
000048  8960              LDRH     r0,[r4,#0xa]          ;90
00004a  1e40              SUBS     r0,r0,#1              ;90
00004c  0400              LSLS     r0,r0,#16             ;90
00004e  0c00              LSRS     r0,r0,#16             ;90
000050  8160              STRH     r0,[r4,#0xa]          ;90
000052  d1f8              BNE      |L1.70|
000054  2001              MOVS     r0,#1                 ;94
000056  8162              STRH     r2,[r4,#0xa]          ;93
000058  2102              MOVS     r1,#2                 ;95
00005a  e00e              B        |L1.122|
                  |L1.92|
00005c  210a              MOVS     r1,#0xa               ;110
00005e  b118              CBZ      r0,|L1.104|
000060  81a1              STRH     r1,[r4,#0xc]          ;118
000062  7223              STRB     r3,[r4,#8]            ;119
000064  2002              MOVS     r0,#2                 ;120
000066  e7e1              B        |L1.44|
                  |L1.104|
000068  89a0              LDRH     r0,[r4,#0xc]          ;107
00006a  1e40              SUBS     r0,r0,#1              ;107
00006c  0400              LSLS     r0,r0,#16             ;107
00006e  0c00              LSRS     r0,r0,#16             ;107
000070  81a0              STRH     r0,[r4,#0xc]          ;107
000072  d1e8              BNE      |L1.70|
000074  81a1              STRH     r1,[r4,#0xc]          ;110
000076  2003              MOVS     r0,#3                 ;111
000078  4601              MOV      r1,r0                 ;112
                  |L1.122|
00007a  7221              STRB     r1,[r4,#8]            ;95
00007c  e7d6              B        |L1.44|
                  |L1.126|
00007e  89e0              LDRH     r0,[r4,#0xe]          ;126
000080  1e40              SUBS     r0,r0,#1              ;126
000082  0400              LSLS     r0,r0,#16             ;126
000084  0c00              LSRS     r0,r0,#16             ;126
000086  81e0              STRH     r0,[r4,#0xe]          ;126
000088  d1dd              BNE      |L1.70|
00008a  2004              MOVS     r0,#4                 ;129
00008c  81e1              STRH     r1,[r4,#0xe]          ;133
00008e  e7cd              B        |L1.44|
;;;159    
                          ENDP

                  key_init PROC
;;;160    void key_init(struct key *key)
000090  2100              MOVS     r1,#0
;;;161    {
;;;162    	key->step = KEY_STEP_WAIT;							/* 等待按键按下 */
000092  7201              STRB     r1,[r0,#8]
;;;163    	key->click_time = KEY_SHAKE_TIME;					/* 消抖时间 */
000094  2101              MOVS     r1,#1
000096  8141              STRH     r1,[r0,#0xa]
;;;164    	key->long_press_time = KEY_PRESS_LONG_TIME;			/* 按键长按时间 */
000098  210a              MOVS     r1,#0xa
00009a  8181              STRH     r1,[r0,#0xc]
;;;165    	key->continue_press_time = KEY_PRESS_CONTINUE_TIME; /* 持续长按间隔时间 */
00009c  2105              MOVS     r1,#5
00009e  81c1              STRH     r1,[r0,#0xe]
;;;166    
;;;167    	init(key);
0000a0  f7ffbffe          B.W      init
;;;168    }
                          ENDP

                  init PROC
;;;31      */
;;;32     static void init(const struct key *key)
0000a4  b538              PUSH     {r3-r5,lr}
;;;33     {
0000a6  4604              MOV      r4,r0
;;;34     	GPIO_InitTypeDef GPIO_Initure;
;;;35     
;;;36     	// 根据GPIO组初始化GPIO时钟
;;;37     	if (key->GPIOx == GPIOA)
0000a8  6800              LDR      r0,[r0,#0]
0000aa  491a              LDR      r1,|L1.276|
0000ac  4288              CMP      r0,r1
0000ae  d103              BNE      |L1.184|
;;;38     	{
;;;39     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOA, ENABLE); // 使能GPIOA时钟
0000b0  2101              MOVS     r1,#1
0000b2  2004              MOVS     r0,#4
0000b4  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.184|
;;;40     	}
;;;41     	if (key->GPIOx == GPIOB)
0000b8  4917              LDR      r1,|L1.280|
0000ba  6820              LDR      r0,[r4,#0]
0000bc  4288              CMP      r0,r1
0000be  d103              BNE      |L1.200|
;;;42     	{
;;;43     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOB, ENABLE); // 使能GPIOB时钟
0000c0  2101              MOVS     r1,#1
0000c2  2008              MOVS     r0,#8
0000c4  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.200|
;;;44     	}
;;;45     	if (key->GPIOx == GPIOC)
0000c8  4914              LDR      r1,|L1.284|
0000ca  6820              LDR      r0,[r4,#0]
0000cc  4288              CMP      r0,r1
0000ce  d103              BNE      |L1.216|
;;;46     	{
;;;47     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOC, ENABLE); // 使能GPIOC时钟
0000d0  2101              MOVS     r1,#1
0000d2  2010              MOVS     r0,#0x10
0000d4  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.216|
;;;48     	}
;;;49     	if (key->GPIOx == GPIOD)
0000d8  4911              LDR      r1,|L1.288|
0000da  6820              LDR      r0,[r4,#0]
0000dc  4288              CMP      r0,r1
0000de  d103              BNE      |L1.232|
;;;50     	{
;;;51     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOD, ENABLE); // 使能GPIOD时钟
0000e0  2101              MOVS     r1,#1
0000e2  2020              MOVS     r0,#0x20
0000e4  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.232|
;;;52     	}
;;;53     	if (key->GPIOx == GPIOE)
0000e8  490e              LDR      r1,|L1.292|
0000ea  6820              LDR      r0,[r4,#0]
0000ec  4288              CMP      r0,r1
0000ee  d103              BNE      |L1.248|
;;;54     	{
;;;55     		RCC_APB2PeriphClockCmd(RCC_APB2Periph_GPIOE, ENABLE); // 使能GPIOE时钟
0000f0  2101              MOVS     r1,#1
0000f2  2040              MOVS     r0,#0x40
0000f4  f7fffffe          BL       RCC_APB2PeriphClockCmd
                  |L1.248|
;;;56     	}
;;;57     
;;;58     	GPIO_Initure.GPIO_Pin = key->GPIO;
0000f8  88a0              LDRH     r0,[r4,#4]
0000fa  f8ad0000          STRH     r0,[sp,#0]
;;;59     	GPIO_Initure.GPIO_Speed = GPIO_Speed_50MHz;
0000fe  2003              MOVS     r0,#3
000100  f88d0002          STRB     r0,[sp,#2]
;;;60     	GPIO_Initure.GPIO_Mode = KEY_INPUT_MODE; // 上拉输入
000104  2048              MOVS     r0,#0x48
000106  f88d0003          STRB     r0,[sp,#3]
;;;61     	GPIO_Init(key->GPIOx, &GPIO_Initure);
00010a  4669              MOV      r1,sp
00010c  6820              LDR      r0,[r4,#0]
00010e  f7fffffe          BL       GPIO_Init
;;;62     }
000112  bd38              POP      {r3-r5,pc}
;;;63     
                          ENDP

                  |L1.276|
                          DCD      0x40010800
                  |L1.280|
                          DCD      0x40010c00
                  |L1.284|
                          DCD      0x40011000
                  |L1.288|
                          DCD      0x40011400
                  |L1.292|
                          DCD      0x40011800
