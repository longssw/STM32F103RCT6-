; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\stm32f10x_fsmc.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\stm32f10x_fsmc.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\stm32f10x_fsmc.crf ..\..\Libraries\FWlib\src\stm32f10x_fsmc.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                  FSMC_NORSRAMDeInit PROC
;;;101      */
;;;102    void FSMC_NORSRAMDeInit(uint32_t FSMC_Bank)
000000  0081              LSLS     r1,r0,#2
;;;103    {
;;;104      /* Check the parameter */
;;;105      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;106      
;;;107      /* FSMC_Bank1_NORSRAM1 */
;;;108      if(FSMC_Bank == FSMC_Bank1_NORSRAM1)
;;;109      {
;;;110        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030DB;    
;;;111      }
;;;112      /* FSMC_Bank1_NORSRAM2,  FSMC_Bank1_NORSRAM3 or FSMC_Bank1_NORSRAM4 */
;;;113      else
;;;114      {   
;;;115        FSMC_Bank1->BTCR[FSMC_Bank] = 0x000030D2; 
000002  f1a141c0          SUB      r1,r1,#0x60000000
000006  b140              CBZ      r0,|L1.26|
000008  f24300d2          MOV      r0,#0x30d2
00000c  6008              STR      r0,[r1,#0]
                  |L1.14|
;;;116      }
;;;117      FSMC_Bank1->BTCR[FSMC_Bank + 1] = 0x0FFFFFFF;
00000e  f06f4070          MVN      r0,#0xf0000000
000012  6048              STR      r0,[r1,#4]
;;;118      FSMC_Bank1E->BWTR[FSMC_Bank] = 0x0FFFFFFF;  
000014  f8c10104          STR      r0,[r1,#0x104]
;;;119    }
000018  4770              BX       lr
                  |L1.26|
00001a  f04f4220          MOV      r2,#0xa0000000        ;110
00001e  f24300db          MOV      r0,#0x30db            ;110
000022  6010              STR      r0,[r2,#0]            ;110
000024  e7f3              B        |L1.14|
;;;120    
                          ENDP

                  FSMC_NANDDeInit PROC
;;;128      */
;;;129    void FSMC_NANDDeInit(uint32_t FSMC_Bank)
000026  b510              PUSH     {r4,lr}
;;;130    {
;;;131      /* Check the parameter */
;;;132      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;133      
;;;134      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;135      {
;;;136        /* Set the FSMC_Bank2 registers to their reset values */
;;;137        FSMC_Bank2->PCR2 = 0x00000018;
000028  2318              MOVS     r3,#0x18
;;;138        FSMC_Bank2->SR2 = 0x00000040;
00002a  2440              MOVS     r4,#0x40
00002c  f04f4120          MOV      r1,#0xa0000000        ;137
;;;139        FSMC_Bank2->PMEM2 = 0xFCFCFCFC;
000030  f04f32fc          MOV      r2,#0xfcfcfcfc
000034  2810              CMP      r0,#0x10              ;134
000036  d005              BEQ      |L1.68|
;;;140        FSMC_Bank2->PATT2 = 0xFCFCFCFC;  
;;;141      }
;;;142      /* FSMC_Bank3_NAND */  
;;;143      else
;;;144      {
;;;145        /* Set the FSMC_Bank3 registers to their reset values */
;;;146        FSMC_Bank3->PCR3 = 0x00000018;
000038  f8413f80          STR      r3,[r1,#0x80]!
;;;147        FSMC_Bank3->SR3 = 0x00000040;
00003c  604c              STR      r4,[r1,#4]
;;;148        FSMC_Bank3->PMEM3 = 0xFCFCFCFC;
00003e  608a              STR      r2,[r1,#8]
;;;149        FSMC_Bank3->PATT3 = 0xFCFCFCFC; 
000040  60ca              STR      r2,[r1,#0xc]
;;;150      }  
;;;151    }
000042  bd10              POP      {r4,pc}
                  |L1.68|
000044  660b              STR      r3,[r1,#0x60]         ;137
000046  664c              STR      r4,[r1,#0x64]         ;138
000048  668a              STR      r2,[r1,#0x68]         ;139
00004a  66ca              STR      r2,[r1,#0x6c]         ;140
00004c  bd10              POP      {r4,pc}
;;;152    
                          ENDP

                  FSMC_PCCARDDeInit PROC
;;;157      */
;;;158    void FSMC_PCCARDDeInit(void)
00004e  f04f4020          MOV      r0,#0xa0000000
;;;159    {
;;;160      /* Set the FSMC_Bank4 registers to their reset values */
;;;161      FSMC_Bank4->PCR4 = 0x00000018; 
000052  2118              MOVS     r1,#0x18
000054  f8401fa0          STR      r1,[r0,#0xa0]!
;;;162      FSMC_Bank4->SR4 = 0x00000000;	
000058  2100              MOVS     r1,#0
00005a  6041              STR      r1,[r0,#4]
;;;163      FSMC_Bank4->PMEM4 = 0xFCFCFCFC;
00005c  f04f31fc          MOV      r1,#0xfcfcfcfc
000060  6081              STR      r1,[r0,#8]
;;;164      FSMC_Bank4->PATT4 = 0xFCFCFCFC;
000062  60c1              STR      r1,[r0,#0xc]
;;;165      FSMC_Bank4->PIO4 = 0xFCFCFCFC;
000064  6101              STR      r1,[r0,#0x10]
;;;166    }
000066  4770              BX       lr
;;;167    
                          ENDP

                  FSMC_NORSRAMInit PROC
;;;175      */
;;;176    void FSMC_NORSRAMInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
000068  b510              PUSH     {r4,lr}
;;;177    { 
00006a  e9d01201          LDRD     r1,r2,[r0,#4]
;;;178      /* Check the parameters */
;;;179      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_NORSRAMInitStruct->FSMC_Bank));
;;;180      assert_param(IS_FSMC_MUX(FSMC_NORSRAMInitStruct->FSMC_DataAddressMux));
;;;181      assert_param(IS_FSMC_MEMORY(FSMC_NORSRAMInitStruct->FSMC_MemoryType));
;;;182      assert_param(IS_FSMC_MEMORY_WIDTH(FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth));
;;;183      assert_param(IS_FSMC_BURSTMODE(FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode));
;;;184      assert_param(IS_FSMC_ASYNWAIT(FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait));
;;;185      assert_param(IS_FSMC_WAIT_POLARITY(FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity));
;;;186      assert_param(IS_FSMC_WRAP_MODE(FSMC_NORSRAMInitStruct->FSMC_WrapMode));
;;;187      assert_param(IS_FSMC_WAIT_SIGNAL_ACTIVE(FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive));
;;;188      assert_param(IS_FSMC_WRITE_OPERATION(FSMC_NORSRAMInitStruct->FSMC_WriteOperation));
;;;189      assert_param(IS_FSMC_WAITE_SIGNAL(FSMC_NORSRAMInitStruct->FSMC_WaitSignal));
;;;190      assert_param(IS_FSMC_EXTENDED_MODE(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode));
;;;191      assert_param(IS_FSMC_WRITE_BURST(FSMC_NORSRAMInitStruct->FSMC_WriteBurst));  
;;;192      assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime));
;;;193      assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime));
;;;194      assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime));
;;;195      assert_param(IS_FSMC_TURNAROUND_TIME(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration));
;;;196      assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision));
;;;197      assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency));
;;;198      assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode)); 
;;;199      
;;;200      /* Bank1 NOR/SRAM control register configuration */ 
;;;201      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
00006e  4311              ORRS     r1,r1,r2
000070  e9d02303          LDRD     r2,r3,[r0,#0xc]
000074  431a              ORRS     r2,r2,r3
000076  4311              ORRS     r1,r1,r2
000078  6942              LDR      r2,[r0,#0x14]
00007a  4311              ORRS     r1,r1,r2
00007c  6982              LDR      r2,[r0,#0x18]
00007e  4311              ORRS     r1,r1,r2
000080  69c2              LDR      r2,[r0,#0x1c]
000082  4311              ORRS     r1,r1,r2
000084  6a02              LDR      r2,[r0,#0x20]
000086  4311              ORRS     r1,r1,r2
000088  6a42              LDR      r2,[r0,#0x24]
00008a  4311              ORRS     r1,r1,r2
00008c  6a82              LDR      r2,[r0,#0x28]
00008e  4311              ORRS     r1,r1,r2
000090  6ac2              LDR      r2,[r0,#0x2c]
000092  4311              ORRS     r1,r1,r2
000094  6b02              LDR      r2,[r0,#0x30]
000096  4311              ORRS     r1,r1,r2
000098  6802              LDR      r2,[r0,#0]
00009a  0092              LSLS     r2,r2,#2
00009c  f1a242c0          SUB      r2,r2,#0x60000000
0000a0  6011              STR      r1,[r2,#0]
;;;202                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_DataAddressMux |
;;;203                FSMC_NORSRAMInitStruct->FSMC_MemoryType |
;;;204                FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth |
;;;205                FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode |
;;;206                FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait |
;;;207                FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity |
;;;208                FSMC_NORSRAMInitStruct->FSMC_WrapMode |
;;;209                FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive |
;;;210                FSMC_NORSRAMInitStruct->FSMC_WriteOperation |
;;;211                FSMC_NORSRAMInitStruct->FSMC_WaitSignal |
;;;212                FSMC_NORSRAMInitStruct->FSMC_ExtendedMode |
;;;213                FSMC_NORSRAMInitStruct->FSMC_WriteBurst;
;;;214    
;;;215      if(FSMC_NORSRAMInitStruct->FSMC_MemoryType == FSMC_MemoryType_NOR)
0000a2  6881              LDR      r1,[r0,#8]
0000a4  2908              CMP      r1,#8
0000a6  d107              BNE      |L1.184|
;;;216      {
;;;217        FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank] |= (uint32_t)BCR_FACCEN_Set;
0000a8  6801              LDR      r1,[r0,#0]
0000aa  0089              LSLS     r1,r1,#2
0000ac  f1a141c0          SUB      r1,r1,#0x60000000
0000b0  680a              LDR      r2,[r1,#0]
0000b2  f0420240          ORR      r2,r2,#0x40
0000b6  600a              STR      r2,[r1,#0]
                  |L1.184|
;;;218      }
;;;219      
;;;220      /* Bank1 NOR/SRAM timing register configuration */
;;;221      FSMC_Bank1->BTCR[FSMC_NORSRAMInitStruct->FSMC_Bank+1] = 
0000b8  6b41              LDR      r1,[r0,#0x34]
0000ba  e9d12300          LDRD     r2,r3,[r1,#0]
0000be  ea421203          ORR      r2,r2,r3,LSL #4
0000c2  688b              LDR      r3,[r1,#8]
0000c4  898c              LDRH     r4,[r1,#0xc]
0000c6  021b              LSLS     r3,r3,#8
0000c8  ea434304          ORR      r3,r3,r4,LSL #16
0000cc  431a              ORRS     r2,r2,r3
0000ce  8a0b              LDRH     r3,[r1,#0x10]
0000d0  ea425203          ORR      r2,r2,r3,LSL #20
0000d4  7d0b              LDRB     r3,[r1,#0x14]
0000d6  6989              LDR      r1,[r1,#0x18]
0000d8  ea426203          ORR      r2,r2,r3,LSL #24
0000dc  430a              ORRS     r2,r2,r1
0000de  6801              LDR      r1,[r0,#0]
0000e0  0089              LSLS     r1,r1,#2
0000e2  f1a141c0          SUB      r1,r1,#0x60000000
0000e6  604a              STR      r2,[r1,#4]
;;;222                (uint32_t)FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime |
;;;223                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime << 4) |
;;;224                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;225                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration << 16) |
;;;226                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision << 20) |
;;;227                (FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency << 24) |
;;;228                 FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode;
;;;229                
;;;230        
;;;231      /* Bank1 NOR/SRAM timing register for write configuration, if extended mode is used */
;;;232      if(FSMC_NORSRAMInitStruct->FSMC_ExtendedMode == FSMC_ExtendedMode_Enable)
0000e8  6ac1              LDR      r1,[r0,#0x2c]
0000ea  f5b14f80          CMP      r1,#0x4000
0000ee  d008              BEQ      |L1.258|
;;;233      {
;;;234        assert_param(IS_FSMC_ADDRESS_SETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime));
;;;235        assert_param(IS_FSMC_ADDRESS_HOLD_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime));
;;;236        assert_param(IS_FSMC_DATASETUP_TIME(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime));
;;;237        assert_param(IS_FSMC_CLK_DIV(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision));
;;;238        assert_param(IS_FSMC_DATA_LATENCY(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency));
;;;239        assert_param(IS_FSMC_ACCESS_MODE(FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode));
;;;240        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 
;;;241                  (uint32_t)FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime |
;;;242                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime << 4 )|
;;;243                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime << 8) |
;;;244                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision << 20) |
;;;245                  (FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency << 24) |
;;;246                   FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode;
;;;247      }
;;;248      else
;;;249      {
;;;250        FSMC_Bank1E->BWTR[FSMC_NORSRAMInitStruct->FSMC_Bank] = 0x0FFFFFFF;
0000f0  6800              LDR      r0,[r0,#0]
0000f2  f06f4170          MVN      r1,#0xf0000000
0000f6  0080              LSLS     r0,r0,#2
0000f8  f1a040c0          SUB      r0,r0,#0x60000000
0000fc  f8c01104          STR      r1,[r0,#0x104]
;;;251      }
;;;252    }
000100  bd10              POP      {r4,pc}
                  |L1.258|
000102  6b81              LDR      r1,[r0,#0x38]         ;240
000104  e9d12300          LDRD     r2,r3,[r1,#0]         ;240
000108  ea421203          ORR      r2,r2,r3,LSL #4       ;240
00010c  688b              LDR      r3,[r1,#8]            ;240
00010e  8a0c              LDRH     r4,[r1,#0x10]         ;240
000110  021b              LSLS     r3,r3,#8              ;240
000112  ea435304          ORR      r3,r3,r4,LSL #20      ;240
000116  431a              ORRS     r2,r2,r3              ;240
000118  7d0b              LDRB     r3,[r1,#0x14]         ;240
00011a  6989              LDR      r1,[r1,#0x18]         ;240
00011c  ea426203          ORR      r2,r2,r3,LSL #24      ;240
000120  6800              LDR      r0,[r0,#0]            ;240
000122  430a              ORRS     r2,r2,r1              ;240
000124  0080              LSLS     r0,r0,#2              ;240
000126  f1a040c0          SUB      r0,r0,#0x60000000     ;240
00012a  f8c02104          STR      r2,[r0,#0x104]        ;240
00012e  bd10              POP      {r4,pc}
;;;253    
                          ENDP

                  FSMC_NANDInit PROC
;;;261      */
;;;262    void FSMC_NANDInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000130  b530              PUSH     {r4,r5,lr}
;;;263    {
000132  e9d01201          LDRD     r1,r2,[r0,#4]
;;;264      uint32_t tmppcr = 0x00000000, tmppmem = 0x00000000, tmppatt = 0x00000000; 
;;;265        
;;;266      /* Check the parameters */
;;;267      assert_param( IS_FSMC_NAND_BANK(FSMC_NANDInitStruct->FSMC_Bank));
;;;268      assert_param( IS_FSMC_WAIT_FEATURE(FSMC_NANDInitStruct->FSMC_Waitfeature));
;;;269      assert_param( IS_FSMC_MEMORY_WIDTH(FSMC_NANDInitStruct->FSMC_MemoryDataWidth));
;;;270      assert_param( IS_FSMC_ECC_STATE(FSMC_NANDInitStruct->FSMC_ECC));
;;;271      assert_param( IS_FSMC_ECCPAGE_SIZE(FSMC_NANDInitStruct->FSMC_ECCPageSize));
;;;272      assert_param( IS_FSMC_TCLR_TIME(FSMC_NANDInitStruct->FSMC_TCLRSetupTime));
;;;273      assert_param( IS_FSMC_TAR_TIME(FSMC_NANDInitStruct->FSMC_TARSetupTime));
;;;274      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;275      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;276      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;277      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;278      assert_param(IS_FSMC_SETUP_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;279      assert_param(IS_FSMC_WAIT_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;280      assert_param(IS_FSMC_HOLD_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;281      assert_param(IS_FSMC_HIZ_TIME(FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;282      
;;;283      /* Set the tmppcr value according to FSMC_NANDInitStruct parameters */
;;;284      tmppcr = (uint32_t)FSMC_NANDInitStruct->FSMC_Waitfeature |
000136  4311              ORRS     r1,r1,r2
000138  e9d02303          LDRD     r2,r3,[r0,#0xc]
00013c  431a              ORRS     r2,r2,r3
00013e  4311              ORRS     r1,r1,r2
000140  6942              LDR      r2,[r0,#0x14]
000142  ea412142          ORR      r1,r1,r2,LSL #9
000146  6982              LDR      r2,[r0,#0x18]
000148  ea413142          ORR      r1,r1,r2,LSL #13
00014c  f0410408          ORR      r4,r1,#8
;;;285                PCR_MemoryType_NAND |
;;;286                FSMC_NANDInitStruct->FSMC_MemoryDataWidth |
;;;287                FSMC_NANDInitStruct->FSMC_ECC |
;;;288                FSMC_NANDInitStruct->FSMC_ECCPageSize |
;;;289                (FSMC_NANDInitStruct->FSMC_TCLRSetupTime << 9 )|
;;;290                (FSMC_NANDInitStruct->FSMC_TARSetupTime << 13);
;;;291                
;;;292      /* Set tmppmem value according to FSMC_CommonSpaceTimingStructure parameters */
;;;293      tmppmem = (uint32_t)FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
000150  69c1              LDR      r1,[r0,#0x1c]
000152  e9d12300          LDRD     r2,r3,[r1,#0]
000156  ea422203          ORR      r2,r2,r3,LSL #8
00015a  890b              LDRH     r3,[r1,#8]
00015c  7b09              LDRB     r1,[r1,#0xc]
00015e  041b              LSLS     r3,r3,#16
000160  ea436101          ORR      r1,r3,r1,LSL #24
000164  430a              ORRS     r2,r2,r1
;;;294                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;295                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;296                (FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;297                
;;;298      /* Set tmppatt value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;299      tmppatt = (uint32_t)FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
000166  6a01              LDR      r1,[r0,#0x20]
000168  e9d13500          LDRD     r3,r5,[r1,#0]
00016c  ea432305          ORR      r3,r3,r5,LSL #8
000170  890d              LDRH     r5,[r1,#8]
000172  7b09              LDRB     r1,[r1,#0xc]
000174  042d              LSLS     r5,r5,#16
000176  ea456101          ORR      r1,r5,r1,LSL #24
00017a  430b              ORRS     r3,r3,r1
;;;300                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;301                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;302                (FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);
;;;303      
;;;304      if(FSMC_NANDInitStruct->FSMC_Bank == FSMC_Bank2_NAND)
;;;305      {
;;;306        /* FSMC_Bank2_NAND registers configuration */
;;;307        FSMC_Bank2->PCR2 = tmppcr;
00017c  6801              LDR      r1,[r0,#0]
00017e  f04f4020          MOV      r0,#0xa0000000
000182  2910              CMP      r1,#0x10              ;304
000184  d004              BEQ      |L1.400|
;;;308        FSMC_Bank2->PMEM2 = tmppmem;
;;;309        FSMC_Bank2->PATT2 = tmppatt;
;;;310      }
;;;311      else
;;;312      {
;;;313        /* FSMC_Bank3_NAND registers configuration */
;;;314        FSMC_Bank3->PCR3 = tmppcr;
000186  f8404f80          STR      r4,[r0,#0x80]!
;;;315        FSMC_Bank3->PMEM3 = tmppmem;
00018a  6082              STR      r2,[r0,#8]
;;;316        FSMC_Bank3->PATT3 = tmppatt;
00018c  60c3              STR      r3,[r0,#0xc]
;;;317      }
;;;318    }
00018e  bd30              POP      {r4,r5,pc}
                  |L1.400|
000190  6604              STR      r4,[r0,#0x60]         ;307
000192  6682              STR      r2,[r0,#0x68]         ;308
000194  66c3              STR      r3,[r0,#0x6c]         ;309
000196  bd30              POP      {r4,r5,pc}
;;;319    
                          ENDP

                  FSMC_PCCARDInit PROC
;;;327      */
;;;328    void FSMC_PCCARDInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000198  b510              PUSH     {r4,lr}
;;;329    {
00019a  e9d01200          LDRD     r1,r2,[r0,#0]
;;;330      /* Check the parameters */
;;;331      assert_param(IS_FSMC_WAIT_FEATURE(FSMC_PCCARDInitStruct->FSMC_Waitfeature));
;;;332      assert_param(IS_FSMC_TCLR_TIME(FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime));
;;;333      assert_param(IS_FSMC_TAR_TIME(FSMC_PCCARDInitStruct->FSMC_TARSetupTime));
;;;334     
;;;335      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime));
;;;336      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime));
;;;337      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime));
;;;338      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime));
;;;339      
;;;340      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime));
;;;341      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime));
;;;342      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime));
;;;343      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime));
;;;344      assert_param(IS_FSMC_SETUP_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime));
;;;345      assert_param(IS_FSMC_WAIT_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime));
;;;346      assert_param(IS_FSMC_HOLD_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime));
;;;347      assert_param(IS_FSMC_HIZ_TIME(FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime));
;;;348      
;;;349      /* Set the PCR4 register value according to FSMC_PCCARDInitStruct parameters */
;;;350      FSMC_Bank4->PCR4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_Waitfeature |
00019e  ea412142          ORR      r1,r1,r2,LSL #9
0001a2  6882              LDR      r2,[r0,#8]
0001a4  2310              MOVS     r3,#0x10
0001a6  ea433242          ORR      r2,r3,r2,LSL #13
0001aa  4311              ORRS     r1,r1,r2
0001ac  f04f4220          MOV      r2,#0xa0000000
0001b0  f8421fa0          STR      r1,[r2,#0xa0]!
;;;351                         FSMC_MemoryDataWidth_16b |  
;;;352                         (FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime << 9) |
;;;353                         (FSMC_PCCARDInitStruct->FSMC_TARSetupTime << 13);
;;;354                
;;;355      /* Set PMEM4 register value according to FSMC_CommonSpaceTimingStructure parameters */
;;;356      FSMC_Bank4->PMEM4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime |
0001b4  68c1              LDR      r1,[r0,#0xc]
0001b6  e9d13400          LDRD     r3,r4,[r1,#0]
0001ba  ea432304          ORR      r3,r3,r4,LSL #8
0001be  890c              LDRH     r4,[r1,#8]
0001c0  7b09              LDRB     r1,[r1,#0xc]
0001c2  0424              LSLS     r4,r4,#16
0001c4  ea446101          ORR      r1,r4,r1,LSL #24
0001c8  430b              ORRS     r3,r3,r1
0001ca  6093              STR      r3,[r2,#8]
;;;357                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;358                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;359                          (FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime << 24); 
;;;360                
;;;361      /* Set PATT4 register value according to FSMC_AttributeSpaceTimingStructure parameters */
;;;362      FSMC_Bank4->PATT4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime |
0001cc  6901              LDR      r1,[r0,#0x10]
0001ce  e9d13400          LDRD     r3,r4,[r1,#0]
0001d2  ea432304          ORR      r3,r3,r4,LSL #8
0001d6  890c              LDRH     r4,[r1,#8]
0001d8  7b09              LDRB     r1,[r1,#0xc]
0001da  0424              LSLS     r4,r4,#16
0001dc  ea446101          ORR      r1,r4,r1,LSL #24
0001e0  430b              ORRS     r3,r3,r1
0001e2  60d3              STR      r3,[r2,#0xc]
;;;363                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;364                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;365                          (FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime << 24);	
;;;366                
;;;367      /* Set PIO4 register value according to FSMC_IOSpaceTimingStructure parameters */
;;;368      FSMC_Bank4->PIO4 = (uint32_t)FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime |
0001e4  6940              LDR      r0,[r0,#0x14]
0001e6  e9d01300          LDRD     r1,r3,[r0,#0]
0001ea  ea412103          ORR      r1,r1,r3,LSL #8
0001ee  8903              LDRH     r3,[r0,#8]
0001f0  7b00              LDRB     r0,[r0,#0xc]
0001f2  041b              LSLS     r3,r3,#16
0001f4  ea436000          ORR      r0,r3,r0,LSL #24
0001f8  4301              ORRS     r1,r1,r0
0001fa  6111              STR      r1,[r2,#0x10]
;;;369                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime << 8) |
;;;370                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime << 16)|
;;;371                         (FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime << 24);             
;;;372    }
0001fc  bd10              POP      {r4,pc}
;;;373    
                          ENDP

                  FSMC_NORSRAMStructInit PROC
;;;379      */
;;;380    void FSMC_NORSRAMStructInit(FSMC_NORSRAMInitTypeDef* FSMC_NORSRAMInitStruct)
0001fe  b510              PUSH     {r4,lr}
;;;381    {  
;;;382      /* Reset NOR/SRAM Init structure parameters values */
;;;383      FSMC_NORSRAMInitStruct->FSMC_Bank = FSMC_Bank1_NORSRAM1;
000200  2100              MOVS     r1,#0
;;;384      FSMC_NORSRAMInitStruct->FSMC_DataAddressMux = FSMC_DataAddressMux_Enable;
000202  2202              MOVS     r2,#2
000204  e9c01200          STRD     r1,r2,[r0,#0]
;;;385      FSMC_NORSRAMInitStruct->FSMC_MemoryType = FSMC_MemoryType_SRAM;
;;;386      FSMC_NORSRAMInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000208  6081              STR      r1,[r0,#8]
;;;387      FSMC_NORSRAMInitStruct->FSMC_BurstAccessMode = FSMC_BurstAccessMode_Disable;
00020a  60c1              STR      r1,[r0,#0xc]
;;;388      FSMC_NORSRAMInitStruct->FSMC_AsynchronousWait = FSMC_AsynchronousWait_Disable;
00020c  6101              STR      r1,[r0,#0x10]
;;;389      FSMC_NORSRAMInitStruct->FSMC_WaitSignalPolarity = FSMC_WaitSignalPolarity_Low;
00020e  6141              STR      r1,[r0,#0x14]
;;;390      FSMC_NORSRAMInitStruct->FSMC_WrapMode = FSMC_WrapMode_Disable;
000210  6181              STR      r1,[r0,#0x18]
;;;391      FSMC_NORSRAMInitStruct->FSMC_WaitSignalActive = FSMC_WaitSignalActive_BeforeWaitState;
;;;392      FSMC_NORSRAMInitStruct->FSMC_WriteOperation = FSMC_WriteOperation_Enable;
000212  02d2              LSLS     r2,r2,#11
000214  61c1              STR      r1,[r0,#0x1c]
000216  e9c01208          STRD     r1,r2,[r0,#0x20]
;;;393      FSMC_NORSRAMInitStruct->FSMC_WaitSignal = FSMC_WaitSignal_Enable;
00021a  0052              LSLS     r2,r2,#1
00021c  e9c0210a          STRD     r2,r1,[r0,#0x28]
;;;394      FSMC_NORSRAMInitStruct->FSMC_ExtendedMode = FSMC_ExtendedMode_Disable;
;;;395      FSMC_NORSRAMInitStruct->FSMC_WriteBurst = FSMC_WriteBurst_Disable;
;;;396      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000220  6301              STR      r1,[r0,#0x30]
000222  6b43              LDR      r3,[r0,#0x34]
000224  220f              MOVS     r2,#0xf
;;;397      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000226  601a              STR      r2,[r3,#0]
000228  6b43              LDR      r3,[r0,#0x34]
;;;398      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataSetupTime = 0xFF;
00022a  605a              STR      r2,[r3,#4]
00022c  6b44              LDR      r4,[r0,#0x34]
00022e  23ff              MOVS     r3,#0xff
;;;399      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
000230  60a3              STR      r3,[r4,#8]
000232  6b44              LDR      r4,[r0,#0x34]
;;;400      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_CLKDivision = 0xF;
000234  60e2              STR      r2,[r4,#0xc]
000236  6b44              LDR      r4,[r0,#0x34]
;;;401      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_DataLatency = 0xF;
000238  6122              STR      r2,[r4,#0x10]
00023a  6b44              LDR      r4,[r0,#0x34]
;;;402      FSMC_NORSRAMInitStruct->FSMC_ReadWriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A; 
00023c  6162              STR      r2,[r4,#0x14]
00023e  6b44              LDR      r4,[r0,#0x34]
;;;403      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressSetupTime = 0xF;
000240  61a1              STR      r1,[r4,#0x18]
000242  6b84              LDR      r4,[r0,#0x38]
;;;404      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AddressHoldTime = 0xF;
000244  6022              STR      r2,[r4,#0]
000246  6b84              LDR      r4,[r0,#0x38]
;;;405      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataSetupTime = 0xFF;
000248  6062              STR      r2,[r4,#4]
00024a  6b84              LDR      r4,[r0,#0x38]
;;;406      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_BusTurnAroundDuration = 0xF;
00024c  60a3              STR      r3,[r4,#8]
00024e  6b83              LDR      r3,[r0,#0x38]
;;;407      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_CLKDivision = 0xF;
000250  60da              STR      r2,[r3,#0xc]
000252  6b83              LDR      r3,[r0,#0x38]
;;;408      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_DataLatency = 0xF;
000254  611a              STR      r2,[r3,#0x10]
000256  6b83              LDR      r3,[r0,#0x38]
;;;409      FSMC_NORSRAMInitStruct->FSMC_WriteTimingStruct->FSMC_AccessMode = FSMC_AccessMode_A;
000258  615a              STR      r2,[r3,#0x14]
00025a  6b80              LDR      r0,[r0,#0x38]
00025c  6181              STR      r1,[r0,#0x18]
;;;410    }
00025e  bd10              POP      {r4,pc}
;;;411    
                          ENDP

                  FSMC_NANDStructInit PROC
;;;417      */
;;;418    void FSMC_NANDStructInit(FSMC_NANDInitTypeDef* FSMC_NANDInitStruct)
000260  2110              MOVS     r1,#0x10
;;;419    { 
;;;420      /* Reset NAND Init structure parameters values */
;;;421      FSMC_NANDInitStruct->FSMC_Bank = FSMC_Bank2_NAND;
;;;422      FSMC_NANDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
000262  6001              STR      r1,[r0,#0]
000264  2100              MOVS     r1,#0
;;;423      FSMC_NANDInitStruct->FSMC_MemoryDataWidth = FSMC_MemoryDataWidth_8b;
000266  6041              STR      r1,[r0,#4]
;;;424      FSMC_NANDInitStruct->FSMC_ECC = FSMC_ECC_Disable;
000268  6081              STR      r1,[r0,#8]
;;;425      FSMC_NANDInitStruct->FSMC_ECCPageSize = FSMC_ECCPageSize_256Bytes;
00026a  60c1              STR      r1,[r0,#0xc]
;;;426      FSMC_NANDInitStruct->FSMC_TCLRSetupTime = 0x0;
00026c  6101              STR      r1,[r0,#0x10]
;;;427      FSMC_NANDInitStruct->FSMC_TARSetupTime = 0x0;
00026e  6141              STR      r1,[r0,#0x14]
;;;428      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000270  6181              STR      r1,[r0,#0x18]
000272  69c2              LDR      r2,[r0,#0x1c]
000274  21fc              MOVS     r1,#0xfc
;;;429      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000276  6011              STR      r1,[r2,#0]
000278  69c2              LDR      r2,[r0,#0x1c]
;;;430      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00027a  6051              STR      r1,[r2,#4]
00027c  69c2              LDR      r2,[r0,#0x1c]
;;;431      FSMC_NANDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
00027e  6091              STR      r1,[r2,#8]
000280  69c2              LDR      r2,[r0,#0x1c]
;;;432      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
000282  60d1              STR      r1,[r2,#0xc]
000284  6a02              LDR      r2,[r0,#0x20]
;;;433      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
000286  6011              STR      r1,[r2,#0]
000288  6a02              LDR      r2,[r0,#0x20]
;;;434      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
00028a  6051              STR      r1,[r2,#4]
00028c  6a02              LDR      r2,[r0,#0x20]
;;;435      FSMC_NANDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	  
00028e  6091              STR      r1,[r2,#8]
000290  6a00              LDR      r0,[r0,#0x20]
000292  60c1              STR      r1,[r0,#0xc]
;;;436    }
000294  4770              BX       lr
;;;437    
                          ENDP

                  FSMC_PCCARDStructInit PROC
;;;443      */
;;;444    void FSMC_PCCARDStructInit(FSMC_PCCARDInitTypeDef* FSMC_PCCARDInitStruct)
000296  2100              MOVS     r1,#0
;;;445    {
;;;446      /* Reset PCCARD Init structure parameters values */
;;;447      FSMC_PCCARDInitStruct->FSMC_Waitfeature = FSMC_Waitfeature_Disable;
;;;448      FSMC_PCCARDInitStruct->FSMC_TCLRSetupTime = 0x0;
000298  6001              STR      r1,[r0,#0]
;;;449      FSMC_PCCARDInitStruct->FSMC_TARSetupTime = 0x0;
00029a  6041              STR      r1,[r0,#4]
;;;450      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_SetupTime = 0xFC;
00029c  6081              STR      r1,[r0,#8]
00029e  68c2              LDR      r2,[r0,#0xc]
0002a0  21fc              MOVS     r1,#0xfc
;;;451      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002a2  6011              STR      r1,[r2,#0]
0002a4  68c2              LDR      r2,[r0,#0xc]
;;;452      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002a6  6051              STR      r1,[r2,#4]
0002a8  68c2              LDR      r2,[r0,#0xc]
;;;453      FSMC_PCCARDInitStruct->FSMC_CommonSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002aa  6091              STR      r1,[r2,#8]
0002ac  68c2              LDR      r2,[r0,#0xc]
;;;454      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002ae  60d1              STR      r1,[r2,#0xc]
0002b0  6902              LDR      r2,[r0,#0x10]
;;;455      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002b2  6011              STR      r1,[r2,#0]
0002b4  6902              LDR      r2,[r0,#0x10]
;;;456      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002b6  6051              STR      r1,[r2,#4]
0002b8  6902              LDR      r2,[r0,#0x10]
;;;457      FSMC_PCCARDInitStruct->FSMC_AttributeSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;	
0002ba  6091              STR      r1,[r2,#8]
0002bc  6902              LDR      r2,[r0,#0x10]
;;;458      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_SetupTime = 0xFC;
0002be  60d1              STR      r1,[r2,#0xc]
0002c0  6942              LDR      r2,[r0,#0x14]
;;;459      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_WaitSetupTime = 0xFC;
0002c2  6011              STR      r1,[r2,#0]
0002c4  6942              LDR      r2,[r0,#0x14]
;;;460      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HoldSetupTime = 0xFC;
0002c6  6051              STR      r1,[r2,#4]
0002c8  6942              LDR      r2,[r0,#0x14]
;;;461      FSMC_PCCARDInitStruct->FSMC_IOSpaceTimingStruct->FSMC_HiZSetupTime = 0xFC;
0002ca  6091              STR      r1,[r2,#8]
0002cc  6940              LDR      r0,[r0,#0x14]
0002ce  60c1              STR      r1,[r0,#0xc]
;;;462    }
0002d0  4770              BX       lr
;;;463    
                          ENDP

                  FSMC_NORSRAMCmd PROC
;;;474      */
;;;475    void FSMC_NORSRAMCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002d2  0080              LSLS     r0,r0,#2
;;;476    {
;;;477      assert_param(IS_FSMC_NORSRAM_BANK(FSMC_Bank));
;;;478      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;479      
;;;480      if (NewState != DISABLE)
;;;481      {
;;;482        /* Enable the selected NOR/SRAM Bank by setting the PBKEN bit in the BCRx register */
;;;483        FSMC_Bank1->BTCR[FSMC_Bank] |= BCR_MBKEN_Set;
0002d4  f1a040c0          SUB      r0,r0,#0x60000000
0002d8  2900              CMP      r1,#0                 ;480
;;;484      }
;;;485      else
;;;486      {
;;;487        /* Disable the selected NOR/SRAM Bank by clearing the PBKEN bit in the BCRx register */
;;;488        FSMC_Bank1->BTCR[FSMC_Bank] &= BCR_MBKEN_Reset;
0002da  6801              LDR      r1,[r0,#0]
0002dc  d002              BEQ      |L1.740|
0002de  f0410101          ORR      r1,r1,#1              ;483
0002e2  e001              B        |L1.744|
                  |L1.740|
0002e4  4a64              LDR      r2,|L1.1144|
0002e6  4011              ANDS     r1,r1,r2
                  |L1.744|
0002e8  6001              STR      r1,[r0,#0]            ;483
;;;489      }
;;;490    }
0002ea  4770              BX       lr
;;;491    
                          ENDP

                  FSMC_NANDCmd PROC
;;;500      */
;;;501    void FSMC_NANDCmd(uint32_t FSMC_Bank, FunctionalState NewState)
0002ec  f04f4220          MOV      r2,#0xa0000000
;;;502    {
0002f0  b151              CBZ      r1,|L1.776|
;;;503      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;504      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;505      
;;;506      if (NewState != DISABLE)
;;;507      {
;;;508        /* Enable the selected NAND Bank by setting the PBKEN bit in the PCRx register */
;;;509        if(FSMC_Bank == FSMC_Bank2_NAND)
0002f2  2810              CMP      r0,#0x10
0002f4  d004              BEQ      |L1.768|
;;;510        {
;;;511          FSMC_Bank2->PCR2 |= PCR_PBKEN_Set;
;;;512        }
;;;513        else
;;;514        {
;;;515          FSMC_Bank3->PCR3 |= PCR_PBKEN_Set;
0002f6  f8520f80          LDR      r0,[r2,#0x80]!
0002fa  f0400004          ORR      r0,r0,#4
0002fe  e00a              B        |L1.790|
                  |L1.768|
000300  6e10              LDR      r0,[r2,#0x60]         ;511
000302  f0400004          ORR      r0,r0,#4              ;511
000306  e00a              B        |L1.798|
                  |L1.776|
;;;516        }
;;;517      }
;;;518      else
;;;519      {
;;;520        /* Disable the selected NAND Bank by clearing the PBKEN bit in the PCRx register */
;;;521        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;522        {
;;;523          FSMC_Bank2->PCR2 &= PCR_PBKEN_Reset;
000308  495b              LDR      r1,|L1.1144|
00030a  1ec9              SUBS     r1,r1,#3
00030c  2810              CMP      r0,#0x10              ;521
00030e  d004              BEQ      |L1.794|
;;;524        }
;;;525        else
;;;526        {
;;;527          FSMC_Bank3->PCR3 &= PCR_PBKEN_Reset;
000310  f8520f80          LDR      r0,[r2,#0x80]!
000314  4008              ANDS     r0,r0,r1
                  |L1.790|
000316  6010              STR      r0,[r2,#0]            ;515
;;;528        }
;;;529      }
;;;530    }
000318  4770              BX       lr
                  |L1.794|
00031a  6e10              LDR      r0,[r2,#0x60]         ;523
00031c  4008              ANDS     r0,r0,r1              ;523
                  |L1.798|
00031e  6610              STR      r0,[r2,#0x60]         ;511
000320  4770              BX       lr
;;;531    
                          ENDP

                  FSMC_PCCARDCmd PROC
;;;537      */
;;;538    void FSMC_PCCARDCmd(FunctionalState NewState)
000322  f04f4120          MOV      r1,#0xa0000000
;;;539    {
;;;540      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;541      
;;;542      if (NewState != DISABLE)
000326  2800              CMP      r0,#0
;;;543      {
;;;544        /* Enable the PCCARD Bank by setting the PBKEN bit in the PCR4 register */
;;;545        FSMC_Bank4->PCR4 |= PCR_PBKEN_Set;
;;;546      }
;;;547      else
;;;548      {
;;;549        /* Disable the PCCARD Bank by clearing the PBKEN bit in the PCR4 register */
;;;550        FSMC_Bank4->PCR4 &= PCR_PBKEN_Reset;
000328  f8510fa0          LDR      r0,[r1,#0xa0]!
00032c  d002              BEQ      |L1.820|
00032e  f0400004          ORR      r0,r0,#4              ;545
000332  e002              B        |L1.826|
                  |L1.820|
000334  4a50              LDR      r2,|L1.1144|
000336  1ed2              SUBS     r2,r2,#3
000338  4010              ANDS     r0,r0,r2
                  |L1.826|
00033a  6008              STR      r0,[r1,#0]            ;545
;;;551      }
;;;552    }
00033c  4770              BX       lr
;;;553    
                          ENDP

                  FSMC_NANDECCCmd PROC
;;;563      */
;;;564    void FSMC_NANDECCCmd(uint32_t FSMC_Bank, FunctionalState NewState)
00033e  f04f4220          MOV      r2,#0xa0000000
;;;565    {
000342  b151              CBZ      r1,|L1.858|
;;;566      assert_param(IS_FSMC_NAND_BANK(FSMC_Bank));
;;;567      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;568      
;;;569      if (NewState != DISABLE)
;;;570      {
;;;571        /* Enable the selected NAND Bank ECC function by setting the ECCEN bit in the PCRx register */
;;;572        if(FSMC_Bank == FSMC_Bank2_NAND)
000344  2810              CMP      r0,#0x10
000346  d004              BEQ      |L1.850|
;;;573        {
;;;574          FSMC_Bank2->PCR2 |= PCR_ECCEN_Set;
;;;575        }
;;;576        else
;;;577        {
;;;578          FSMC_Bank3->PCR3 |= PCR_ECCEN_Set;
000348  f8520f80          LDR      r0,[r2,#0x80]!
00034c  f0400040          ORR      r0,r0,#0x40
000350  e00a              B        |L1.872|
                  |L1.850|
000352  6e10              LDR      r0,[r2,#0x60]         ;574
000354  f0400040          ORR      r0,r0,#0x40           ;574
000358  e00a              B        |L1.880|
                  |L1.858|
;;;579        }
;;;580      }
;;;581      else
;;;582      {
;;;583        /* Disable the selected NAND Bank ECC function by clearing the ECCEN bit in the PCRx register */
;;;584        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;585        {
;;;586          FSMC_Bank2->PCR2 &= PCR_ECCEN_Reset;
00035a  4947              LDR      r1,|L1.1144|
00035c  393f              SUBS     r1,r1,#0x3f
00035e  2810              CMP      r0,#0x10              ;584
000360  d004              BEQ      |L1.876|
;;;587        }
;;;588        else
;;;589        {
;;;590          FSMC_Bank3->PCR3 &= PCR_ECCEN_Reset;
000362  f8520f80          LDR      r0,[r2,#0x80]!
000366  4008              ANDS     r0,r0,r1
                  |L1.872|
000368  6010              STR      r0,[r2,#0]            ;578
;;;591        }
;;;592      }
;;;593    }
00036a  4770              BX       lr
                  |L1.876|
00036c  6e10              LDR      r0,[r2,#0x60]         ;586
00036e  4008              ANDS     r0,r0,r1              ;586
                  |L1.880|
000370  6610              STR      r0,[r2,#0x60]         ;574
000372  4770              BX       lr
;;;594    
                          ENDP

                  FSMC_GetECC PROC
;;;602      */
;;;603    uint32_t FSMC_GetECC(uint32_t FSMC_Bank)
000374  f04f4120          MOV      r1,#0xa0000000
;;;604    {
;;;605      uint32_t eccval = 0x00000000;
;;;606      
;;;607      if(FSMC_Bank == FSMC_Bank2_NAND)
000378  2810              CMP      r0,#0x10
00037a  d002              BEQ      |L1.898|
;;;608      {
;;;609        /* Get the ECCR2 register value */
;;;610        eccval = FSMC_Bank2->ECCR2;
;;;611      }
;;;612      else
;;;613      {
;;;614        /* Get the ECCR3 register value */
;;;615        eccval = FSMC_Bank3->ECCR3;
00037c  f8d10094          LDR      r0,[r1,#0x94]
;;;616      }
;;;617      /* Return the error correction code value */
;;;618      return(eccval);
;;;619    }
000380  4770              BX       lr
                  |L1.898|
000382  6f48              LDR      r0,[r1,#0x74]         ;610
000384  4770              BX       lr
;;;620    
                          ENDP

                  FSMC_ITConfig PROC
;;;636      */
;;;637    void FSMC_ITConfig(uint32_t FSMC_Bank, uint32_t FSMC_IT, FunctionalState NewState)
000386  b510              PUSH     {r4,lr}
;;;638    {
;;;639      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;640      assert_param(IS_FSMC_IT(FSMC_IT));	
;;;641      assert_param(IS_FUNCTIONAL_STATE(NewState));
;;;642      
;;;643      if (NewState != DISABLE)
;;;644      {
;;;645        /* Enable the selected FSMC_Bank2 interrupts */
;;;646        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;647        {
;;;648          FSMC_Bank2->SR2 |= FSMC_IT;
;;;649        }
;;;650        /* Enable the selected FSMC_Bank3 interrupts */
;;;651        else if (FSMC_Bank == FSMC_Bank3_NAND)
000388  f44f7480          MOV      r4,#0x100
00038c  f04f4320          MOV      r3,#0xa0000000        ;648
000390  b172              CBZ      r2,|L1.944|
000392  2810              CMP      r0,#0x10              ;646
000394  d004              BEQ      |L1.928|
000396  42a0              CMP      r0,r4
000398  d105              BNE      |L1.934|
;;;652        {
;;;653          FSMC_Bank3->SR3 |= FSMC_IT;
00039a  f8530f84          LDR      r0,[r3,#0x84]!
00039e  e004              B        |L1.938|
                  |L1.928|
0003a0  6e58              LDR      r0,[r3,#0x64]         ;648
0003a2  4308              ORRS     r0,r0,r1              ;648
0003a4  e00d              B        |L1.962|
                  |L1.934|
;;;654        }
;;;655        /* Enable the selected FSMC_Bank4 interrupts */
;;;656        else
;;;657        {
;;;658          FSMC_Bank4->SR4 |= FSMC_IT;    
0003a6  f8530fa4          LDR      r0,[r3,#0xa4]!
                  |L1.938|
0003aa  4308              ORRS     r0,r0,r1
                  |L1.940|
0003ac  6018              STR      r0,[r3,#0]
;;;659        }
;;;660      }
;;;661      else
;;;662      {
;;;663        /* Disable the selected FSMC_Bank2 interrupts */
;;;664        if(FSMC_Bank == FSMC_Bank2_NAND)
;;;665        {
;;;666          
;;;667          FSMC_Bank2->SR2 &= (uint32_t)~FSMC_IT;
;;;668        }
;;;669        /* Disable the selected FSMC_Bank3 interrupts */
;;;670        else if (FSMC_Bank == FSMC_Bank3_NAND)
;;;671        {
;;;672          FSMC_Bank3->SR3 &= (uint32_t)~FSMC_IT;
;;;673        }
;;;674        /* Disable the selected FSMC_Bank4 interrupts */
;;;675        else
;;;676        {
;;;677          FSMC_Bank4->SR4 &= (uint32_t)~FSMC_IT;    
;;;678        }
;;;679      }
;;;680    }
0003ae  bd10              POP      {r4,pc}
                  |L1.944|
0003b0  2810              CMP      r0,#0x10              ;664
0003b2  d004              BEQ      |L1.958|
0003b4  42a0              CMP      r0,r4                 ;670
0003b6  d106              BNE      |L1.966|
0003b8  f8530f84          LDR      r0,[r3,#0x84]!        ;672
0003bc  e005              B        |L1.970|
                  |L1.958|
0003be  6e58              LDR      r0,[r3,#0x64]         ;667
0003c0  4388              BICS     r0,r0,r1              ;667
                  |L1.962|
0003c2  6658              STR      r0,[r3,#0x64]         ;648
0003c4  bd10              POP      {r4,pc}
                  |L1.966|
0003c6  f8530fa4          LDR      r0,[r3,#0xa4]!        ;677
                  |L1.970|
0003ca  4388              BICS     r0,r0,r1              ;672
0003cc  e7ee              B        |L1.940|
;;;681    
                          ENDP

                  FSMC_GetFlagStatus PROC
;;;696      */
;;;697    FlagStatus FSMC_GetFlagStatus(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003ce  4603              MOV      r3,r0
;;;698    {
;;;699      FlagStatus bitstatus = RESET;
0003d0  2000              MOVS     r0,#0
;;;700      uint32_t tmpsr = 0x00000000;
;;;701      
;;;702      /* Check the parameters */
;;;703      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;704      assert_param(IS_FSMC_GET_FLAG(FSMC_FLAG));
;;;705      
;;;706      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;707      {
;;;708        tmpsr = FSMC_Bank2->SR2;
0003d2  f04f4220          MOV      r2,#0xa0000000
0003d6  2b10              CMP      r3,#0x10              ;706
0003d8  d008              BEQ      |L1.1004|
;;;709      }  
;;;710      else if(FSMC_Bank == FSMC_Bank3_NAND)
0003da  f5b37f80          CMP      r3,#0x100
0003de  d007              BEQ      |L1.1008|
;;;711      {
;;;712        tmpsr = FSMC_Bank3->SR3;
;;;713      }
;;;714      /* FSMC_Bank4_PCCARD*/
;;;715      else
;;;716      {
;;;717        tmpsr = FSMC_Bank4->SR4;
0003e0  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.996|
;;;718      } 
;;;719      
;;;720      /* Get the flag status */
;;;721      if ((tmpsr & FSMC_FLAG) != (uint16_t)RESET )
0003e4  420a              TST      r2,r1
0003e6  d000              BEQ      |L1.1002|
;;;722      {
;;;723        bitstatus = SET;
0003e8  2001              MOVS     r0,#1
                  |L1.1002|
;;;724      }
;;;725      else
;;;726      {
;;;727        bitstatus = RESET;
;;;728      }
;;;729      /* Return the flag status */
;;;730      return bitstatus;
;;;731    }
0003ea  4770              BX       lr
                  |L1.1004|
0003ec  6e52              LDR      r2,[r2,#0x64]         ;708
0003ee  e7f9              B        |L1.996|
                  |L1.1008|
0003f0  f8d22084          LDR      r2,[r2,#0x84]         ;712
0003f4  e7f6              B        |L1.996|
;;;732    
                          ENDP

                  FSMC_ClearFlag PROC
;;;746      */
;;;747    void FSMC_ClearFlag(uint32_t FSMC_Bank, uint32_t FSMC_FLAG)
0003f6  f04f4220          MOV      r2,#0xa0000000
;;;748    {
;;;749     /* Check the parameters */
;;;750      assert_param(IS_FSMC_GETFLAG_BANK(FSMC_Bank));
;;;751      assert_param(IS_FSMC_CLEAR_FLAG(FSMC_FLAG)) ;
;;;752        
;;;753      if(FSMC_Bank == FSMC_Bank2_NAND)
0003fa  2810              CMP      r0,#0x10
0003fc  d007              BEQ      |L1.1038|
;;;754      {
;;;755        FSMC_Bank2->SR2 &= ~FSMC_FLAG; 
;;;756      }  
;;;757      else if(FSMC_Bank == FSMC_Bank3_NAND)
0003fe  f5b07f80          CMP      r0,#0x100
000402  d008              BEQ      |L1.1046|
;;;758      {
;;;759        FSMC_Bank3->SR3 &= ~FSMC_FLAG;
;;;760      }
;;;761      /* FSMC_Bank4_PCCARD*/
;;;762      else
;;;763      {
;;;764        FSMC_Bank4->SR4 &= ~FSMC_FLAG;
000404  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1032|
000408  4388              BICS     r0,r0,r1
00040a  6010              STR      r0,[r2,#0]
;;;765      }
;;;766    }
00040c  4770              BX       lr
                  |L1.1038|
00040e  6e50              LDR      r0,[r2,#0x64]         ;755
000410  4388              BICS     r0,r0,r1              ;755
000412  6650              STR      r0,[r2,#0x64]         ;755
000414  4770              BX       lr
                  |L1.1046|
000416  f8520f84          LDR      r0,[r2,#0x84]!        ;759
00041a  e7f5              B        |L1.1032|
;;;767    
                          ENDP

                  FSMC_GetITStatus PROC
;;;781      */
;;;782    ITStatus FSMC_GetITStatus(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00041c  4603              MOV      r3,r0
;;;783    {
;;;784      ITStatus bitstatus = RESET;
00041e  2000              MOVS     r0,#0
;;;785      uint32_t tmpsr = 0x0, itstatus = 0x0, itenable = 0x0; 
;;;786      
;;;787      /* Check the parameters */
;;;788      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;789      assert_param(IS_FSMC_GET_IT(FSMC_IT));
;;;790      
;;;791      if(FSMC_Bank == FSMC_Bank2_NAND)
;;;792      {
;;;793        tmpsr = FSMC_Bank2->SR2;
000420  f04f4220          MOV      r2,#0xa0000000
000424  2b10              CMP      r3,#0x10              ;791
000426  d00c              BEQ      |L1.1090|
;;;794      }  
;;;795      else if(FSMC_Bank == FSMC_Bank3_NAND)
000428  f5b37f80          CMP      r3,#0x100
00042c  d00b              BEQ      |L1.1094|
;;;796      {
;;;797        tmpsr = FSMC_Bank3->SR3;
;;;798      }
;;;799      /* FSMC_Bank4_PCCARD*/
;;;800      else
;;;801      {
;;;802        tmpsr = FSMC_Bank4->SR4;
00042e  f8d220a4          LDR      r2,[r2,#0xa4]
                  |L1.1074|
;;;803      } 
;;;804      
;;;805      itstatus = tmpsr & FSMC_IT;
000432  420a              TST      r2,r1
;;;806      
;;;807      itenable = tmpsr & (FSMC_IT >> 3);
000434  ea0201d1          AND      r1,r2,r1,LSR #3
;;;808      if ((itstatus != (uint32_t)RESET)  && (itenable != (uint32_t)RESET))
000438  d002              BEQ      |L1.1088|
00043a  2900              CMP      r1,#0
00043c  d000              BEQ      |L1.1088|
;;;809      {
;;;810        bitstatus = SET;
00043e  2001              MOVS     r0,#1
                  |L1.1088|
;;;811      }
;;;812      else
;;;813      {
;;;814        bitstatus = RESET;
;;;815      }
;;;816      return bitstatus; 
;;;817    }
000440  4770              BX       lr
                  |L1.1090|
000442  6e52              LDR      r2,[r2,#0x64]         ;793
000444  e7f5              B        |L1.1074|
                  |L1.1094|
000446  f8d22084          LDR      r2,[r2,#0x84]         ;797
00044a  e7f2              B        |L1.1074|
;;;818    
                          ENDP

                  FSMC_ClearITPendingBit PROC
;;;832      */
;;;833    void FSMC_ClearITPendingBit(uint32_t FSMC_Bank, uint32_t FSMC_IT)
00044c  f04f4220          MOV      r2,#0xa0000000
;;;834    {
;;;835      /* Check the parameters */
;;;836      assert_param(IS_FSMC_IT_BANK(FSMC_Bank));
;;;837      assert_param(IS_FSMC_IT(FSMC_IT));
;;;838        
;;;839      if(FSMC_Bank == FSMC_Bank2_NAND)
000450  2810              CMP      r0,#0x10
000452  d008              BEQ      |L1.1126|
;;;840      {
;;;841        FSMC_Bank2->SR2 &= ~(FSMC_IT >> 3); 
;;;842      }  
;;;843      else if(FSMC_Bank == FSMC_Bank3_NAND)
000454  f5b07f80          CMP      r0,#0x100
000458  d00a              BEQ      |L1.1136|
;;;844      {
;;;845        FSMC_Bank3->SR3 &= ~(FSMC_IT >> 3);
;;;846      }
;;;847      /* FSMC_Bank4_PCCARD*/
;;;848      else
;;;849      {
;;;850        FSMC_Bank4->SR4 &= ~(FSMC_IT >> 3);
00045a  f8520fa4          LDR      r0,[r2,#0xa4]!
                  |L1.1118|
00045e  ea2000d1          BIC      r0,r0,r1,LSR #3
000462  6010              STR      r0,[r2,#0]
;;;851      }
;;;852    }
000464  4770              BX       lr
                  |L1.1126|
000466  6e50              LDR      r0,[r2,#0x64]         ;841
000468  ea2000d1          BIC      r0,r0,r1,LSR #3       ;841
00046c  6650              STR      r0,[r2,#0x64]         ;841
00046e  4770              BX       lr
                  |L1.1136|
000470  f8520f84          LDR      r0,[r2,#0x84]!        ;845
000474  e7f3              B        |L1.1118|
;;;853    
                          ENDP

000476  0000              DCW      0x0000
                  |L1.1144|
                          DCD      0x000ffffe
