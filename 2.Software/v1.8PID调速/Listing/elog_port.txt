; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\elog_port.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\elog_port.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\elog_port.crf ..\..\BSP\easylogger\port\elog_port.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_widthprec
                          REQUIRE _printf_s
                          REQUIRE _printf_str
                          REQUIRE _printf_d
                          REQUIRE _printf_int_dec
                  elog_port_init PROC
;;;42      */
;;;43     ElogErrCode elog_port_init(void)
000000  b510              PUSH     {r4,lr}
;;;44     {
;;;45         ElogErrCode result = ELOG_NO_ERR;
000002  2400              MOVS     r4,#0
;;;46     
;;;47         /* add your code here */
;;;48         //! 创建互斥信号值
;;;49         LogMutexSemaphore = xSemaphoreCreateMutex();
000004  2001              MOVS     r0,#1
000006  f7fffffe          BL       xQueueCreateMutex
00000a  4934              LDR      r1,|L1.220|
;;;50         if (LogMutexSemaphore == NULL)
00000c  6008              STR      r0,[r1,#0]  ; LogMutexSemaphore
00000e  b918              CBNZ     r0,|L1.24|
;;;51         {
;;;52             printf("elog sem create fail\r\n");
000010  a033              ADR      r0,|L1.224|
000012  f7fffffe          BL       __2printf
;;;53             result = ELOG_SEM_FAIL; //!< 注意：ElogErrCode 枚举中没有这个类型，需要添加一个错误类型
000016  2401              MOVS     r4,#1
                  |L1.24|
;;;54         }
;;;55         return result;
000018  4620              MOV      r0,r4
;;;56     }
00001a  bd10              POP      {r4,pc}
;;;57     
                          ENDP

                  elog_port_deinit PROC
;;;61      */
;;;62     void elog_port_deinit(void)
00001c  4770              BX       lr
;;;63     {
;;;64     
;;;65         /* add your code here */
;;;66     }
;;;67     
                          ENDP

                  elog_port_output PROC
;;;73      */
;;;74     void elog_port_output(const char *log, size_t size)
00001e  4602              MOV      r2,r0
;;;75     {
;;;76     
;;;77         /* add your code here */
;;;78         //! %s 表示字符串输出，
;;;79         //! .<十进制数> 是精度控制格式符，输出字符时表示输出字符的位数，
;;;80         //! 在精度控制时，小数点后的十进制数可以使用 * 来占位，
;;;81         //! 在后面提供一个变量作为精度控制的具体值
;;;82         printf("%.*s", size, log);
000020  a035              ADR      r0,|L1.248|
000022  f7ffbffe          B.W      __2printf
;;;83     }
;;;84     
                          ENDP

                  elog_port_output_lock PROC
;;;87      */
;;;88     void elog_port_output_lock(void)
000026  482d              LDR      r0,|L1.220|
;;;89     {
;;;90     
;;;91         /* add your code here */
;;;92         if (NULL != LogMutexSemaphore)
000028  6800              LDR      r0,[r0,#0]  ; LogMutexSemaphore
00002a  2800              CMP      r0,#0                 ;89
00002c  d004              BEQ      |L1.56|
;;;93         {
;;;94             xSemaphoreTake(LogMutexSemaphore, portMAX_DELAY); //!< 等待互斥信号量
00002e  2300              MOVS     r3,#0
000030  1e5a              SUBS     r2,r3,#1
000032  4619              MOV      r1,r3
000034  f7ffbffe          B.W      xQueueGenericReceive
                  |L1.56|
;;;95         }
;;;96     }
000038  4770              BX       lr
;;;97     
                          ENDP

                  elog_port_output_unlock PROC
;;;100     */
;;;101    void elog_port_output_unlock(void)
00003a  4828              LDR      r0,|L1.220|
;;;102    {
;;;103    
;;;104        /* add your code here */
;;;105        if (NULL != LogMutexSemaphore)
00003c  6800              LDR      r0,[r0,#0]  ; LogMutexSemaphore
00003e  2800              CMP      r0,#0                 ;102
000040  d004              BEQ      |L1.76|
;;;106        {
;;;107            xSemaphoreGive(LogMutexSemaphore); //!< 发送互斥信号量
000042  2300              MOVS     r3,#0
000044  461a              MOV      r2,r3
000046  4619              MOV      r1,r3
000048  f7ffbffe          B.W      xQueueGenericSend
                  |L1.76|
;;;108        }
;;;109    }
00004c  4770              BX       lr
;;;110    
                          ENDP

                  elog_port_get_time PROC
;;;115     */
;;;116    const char *elog_port_get_time(void)
00004e  b508              PUSH     {r3,lr}
;;;117    {
;;;118    
;;;119        /* add your code here */
;;;120        static char cur_system_time[16] = {0};
;;;121    
;;;122    #if (INCLUDE_xTaskGetSchedulerState == 1)
;;;123        if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
000050  f7fffffe          BL       xTaskGetSchedulerState
000054  2801              CMP      r0,#1
000056  d00f              BEQ      |L1.120|
;;;124        {
;;;125    #endif
;;;126            TickType_t tick = xTaskGetTickCount();
000058  f7fffffe          BL       xTaskGetTickCount
;;;127            snprintf(cur_system_time, 16, "%d.%.3d", (tick / configTICK_RATE_HZ), tick % configTICK_RATE_HZ);
00005c  f44f717a          MOV      r1,#0x3e8
000060  fbb0f2f1          UDIV     r2,r0,r1
000064  fbb0f3f1          UDIV     r3,r0,r1
000068  fb010212          MLS      r2,r1,r2,r0
00006c  9200              STR      r2,[sp,#0]
00006e  a224              ADR      r2,|L1.256|
000070  2110              MOVS     r1,#0x10
000072  4825              LDR      r0,|L1.264|
000074  f7fffffe          BL       __2snprintf
                  |L1.120|
;;;128    #if (INCLUDE_xTaskGetSchedulerState == 1)
;;;129        }
;;;130    #endif
;;;131    
;;;132        return cur_system_time;
000078  4823              LDR      r0,|L1.264|
;;;133    }
00007a  bd08              POP      {r3,pc}
;;;134    
                          ENDP

                  elog_port_get_p_info PROC
;;;139     */
;;;140    const char *elog_port_get_p_info(void)
00007c  a01f              ADR      r0,|L1.252|
;;;141    {
;;;142    
;;;143        /* add your code here */
;;;144        return "";
;;;145    }
00007e  4770              BX       lr
;;;146    
                          ENDP

                  elog_port_get_t_info PROC
;;;151     */
;;;152    const char *elog_port_get_t_info(void)
000080  b510              PUSH     {r4,lr}
;;;153    {
;;;154    
;;;155    /* add your code here */
;;;156    #if (INCLUDE_xTaskGetSchedulerState == 1)
;;;157        if (xTaskGetSchedulerState() != taskSCHEDULER_NOT_STARTED)
000082  f7fffffe          BL       xTaskGetSchedulerState
000086  2801              CMP      r0,#1
000088  d005              BEQ      |L1.150|
;;;158        {
;;;159    #endif
;;;160            return pcTaskGetName(xTaskGetCurrentTaskHandle());
00008a  f7fffffe          BL       xTaskGetCurrentTaskHandle
00008e  e8bd4010          POP      {r4,lr}
000092  f7ffbffe          B.W      pcTaskGetName
                  |L1.150|
;;;161    #if (INCLUDE_xTaskGetSchedulerState == 1)
;;;162        }
;;;163    #endif
;;;164    
;;;165        return "";
000096  a019              ADR      r0,|L1.252|
;;;166    }
000098  bd10              POP      {r4,pc}
;;;167    
                          ENDP

                  easylogger_init PROC
;;;170     */
;;;171    void easylogger_init(void)
00009a  b510              PUSH     {r4,lr}
;;;172    {
;;;173        /* init Easylogger */
;;;174        elog_init();
00009c  f7fffffe          BL       elog_init
;;;175    
;;;176        /* set EasyLogger log format */
;;;177        elog_set_fmt(ELOG_LVL_ASSERT, ELOG_FMT_ALL);
0000a0  21ff              MOVS     r1,#0xff
0000a2  2000              MOVS     r0,#0
0000a4  f7fffffe          BL       elog_set_fmt
;;;178        elog_set_fmt(ELOG_LVL_ERROR, ELOG_FMT_LVL | ELOG_FMT_TIME | ELOG_FMT_T_INFO);
0000a8  2115              MOVS     r1,#0x15
0000aa  2001              MOVS     r0,#1
0000ac  f7fffffe          BL       elog_set_fmt
;;;179        elog_set_fmt(ELOG_LVL_WARN, ELOG_FMT_LVL | ELOG_FMT_T_INFO);
0000b0  2111              MOVS     r1,#0x11
0000b2  2002              MOVS     r0,#2
0000b4  f7fffffe          BL       elog_set_fmt
;;;180        elog_set_fmt(ELOG_LVL_INFO, ELOG_FMT_LVL);
0000b8  2101              MOVS     r1,#1
0000ba  2003              MOVS     r0,#3
0000bc  f7fffffe          BL       elog_set_fmt
;;;181        elog_set_fmt(ELOG_LVL_DEBUG, ELOG_FMT_ALL & ~ELOG_FMT_FUNC);
0000c0  21bf              MOVS     r1,#0xbf
0000c2  2004              MOVS     r0,#4
0000c4  f7fffffe          BL       elog_set_fmt
;;;182    
;;;183        /*Eenbale color*/
;;;184        elog_set_text_color_enabled(false);
0000c8  2000              MOVS     r0,#0
0000ca  f7fffffe          BL       elog_set_text_color_enabled
;;;185    
;;;186        /* 输出日志等级 */
;;;187        elog_set_filter_lvl(ELOG_LVL_VERBOSE);
0000ce  2005              MOVS     r0,#5
0000d0  f7fffffe          BL       elog_set_filter_lvl
;;;188        /* start EasyLogger */
;;;189        elog_start();
0000d4  e8bd4010          POP      {r4,lr}
0000d8  f7ffbffe          B.W      elog_start
;;;190    }
                          ENDP

                  |L1.220|
                          DCD      ||.data||
                  |L1.224|
0000e0  656c6f67          DCB      "elog sem create fail\r\n",0
0000e4  2073656d
0000e8  20637265
0000ec  61746520
0000f0  6661696c
0000f4  0d0a00  
0000f7  00                DCB      0
                  |L1.248|
0000f8  252e2a73          DCB      "%.*s"
                  |L1.252|
0000fc  00                DCB      0
0000fd  00                DCB      0
0000fe  00                DCB      0
0000ff  00                DCB      0
                  |L1.256|
000100  25642e25          DCB      "%d.%.3d",0
000104  2e336400
                  |L1.264|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=0

                  cur_system_time
                          %        16

                          AREA ||.data||, DATA, ALIGN=2

                  LogMutexSemaphore
                          DCD      0x00000000
