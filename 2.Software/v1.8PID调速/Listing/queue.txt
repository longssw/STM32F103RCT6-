; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\queue.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\queue.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\queue.crf ..\..\FreeRTOS\src\queue.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  xQueueGenericReset PROC
;;;278    
;;;279    BaseType_t xQueueGenericReset( QueueHandle_t xQueue, BaseType_t xNewQueue )
000000  b570              PUSH     {r4-r6,lr}
;;;280    {
000002  460d              MOV      r5,r1
000004  0004              MOVS     r4,r0
000006  d105              BNE      |L1.20|
;;;281    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;282    
;;;283    	configASSERT( pxQueue );
000008  f240121b          MOV      r2,#0x11b
00000c  a1f7              ADR      r1,|L1.1004|
00000e  a0fe              ADR      r0,|L1.1032|
000010  f7fffffe          BL       __2printf
                  |L1.20|
;;;284    
;;;285    	taskENTER_CRITICAL();
000014  f7fffffe          BL       vPortEnterCritical
;;;286    	{
;;;287    		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
000018  e9d4200f          LDRD     r2,r0,[r4,#0x3c]
00001c  6821              LDR      r1,[r4,#0]
00001e  fb021100          MLA      r1,r2,r0,r1
;;;288    		pxQueue->uxMessagesWaiting = ( UBaseType_t ) 0U;
000022  6061              STR      r1,[r4,#4]
000024  2100              MOVS     r1,#0
000026  63a1              STR      r1,[r4,#0x38]
;;;289    		pxQueue->pcWriteTo = pxQueue->pcHead;
000028  6821              LDR      r1,[r4,#0]
;;;290    		pxQueue->u.pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( UBaseType_t ) 1U ) * pxQueue->uxItemSize );
00002a  60a1              STR      r1,[r4,#8]
00002c  460a              MOV      r2,r1
00002e  e9d4010f          LDRD     r0,r1,[r4,#0x3c]
000032  1e40              SUBS     r0,r0,#1
000034  fb002101          MLA      r1,r0,r1,r2
;;;291    		pxQueue->cRxLock = queueUNLOCKED;
000038  60e1              STR      r1,[r4,#0xc]
00003a  4621              MOV      r1,r4
00003c  f04f30ff          MOV      r0,#0xffffffff
000040  f8010f44          STRB     r0,[r1,#0x44]!
;;;292    		pxQueue->cTxLock = queueUNLOCKED;
000044  7048              STRB     r0,[r1,#1]
;;;293    
;;;294    		if( xNewQueue == pdFALSE )
;;;295    		{
;;;296    			/* If there are tasks blocked waiting to read from the queue, then
;;;297    			the tasks will remain blocked as after this function exits the queue
;;;298    			will still be empty.  If there are tasks blocked waiting to write to
;;;299    			the queue, then one should be unblocked as after this function exits
;;;300    			it will be possible to write to it. */
;;;301    			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;302    			{
;;;303    				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000046  f1040010          ADD      r0,r4,#0x10
00004a  b14d              CBZ      r5,|L1.96|
;;;304    				{
;;;305    					queueYIELD_IF_USING_PREEMPTION();
;;;306    				}
;;;307    				else
;;;308    				{
;;;309    					mtCOVERAGE_TEST_MARKER();
;;;310    				}
;;;311    			}
;;;312    			else
;;;313    			{
;;;314    				mtCOVERAGE_TEST_MARKER();
;;;315    			}
;;;316    		}
;;;317    		else
;;;318    		{
;;;319    			/* Ensure the event queues start in the correct state. */
;;;320    			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
00004c  f7fffffe          BL       vListInitialise
;;;321    			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
000050  f1040024          ADD      r0,r4,#0x24
000054  f7fffffe          BL       vListInitialise
                  |L1.88|
;;;322    		}
;;;323    	}
;;;324    	taskEXIT_CRITICAL();
000058  f7fffffe          BL       vPortExitCritical
;;;325    
;;;326    	/* A value is returned for calling semantic consistency with previous
;;;327    	versions. */
;;;328    	return pdPASS;
00005c  2001              MOVS     r0,#1
;;;329    }
00005e  bd70              POP      {r4-r6,pc}
                  |L1.96|
000060  6921              LDR      r1,[r4,#0x10]         ;301
000062  2900              CMP      r1,#0                 ;301
000064  d0f8              BEQ      |L1.88|
000066  f7fffffe          BL       xTaskRemoveFromEventList
00006a  2800              CMP      r0,#0                 ;303
00006c  d0f4              BEQ      |L1.88|
00006e  49ea              LDR      r1,|L1.1048|
000070  f04f5080          MOV      r0,#0x10000000        ;305
000074  6008              STR      r0,[r1,#0]            ;305
000076  f3bf8f4f          DSB                            ;305
00007a  f3bf8f6f          ISB                            ;305
00007e  e7eb              B        |L1.88|
;;;330    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericCreate PROC
;;;385    
;;;386    	QueueHandle_t xQueueGenericCreate( const UBaseType_t uxQueueLength, const UBaseType_t uxItemSize, const uint8_t ucQueueType )
000080  b570              PUSH     {r4-r6,lr}
;;;387    	{
000082  460e              MOV      r6,r1
000084  0005              MOVS     r5,r0
000086  d105              BNE      |L1.148|
;;;388    	Queue_t *pxNewQueue;
;;;389    	size_t xQueueSizeInBytes;
;;;390    	uint8_t *pucQueueStorage;
;;;391    
;;;392    		configASSERT( uxQueueLength > ( UBaseType_t ) 0 );
000088  f44f72c4          MOV      r2,#0x188
00008c  a1d7              ADR      r1,|L1.1004|
00008e  a0de              ADR      r0,|L1.1032|
000090  f7fffffe          BL       __2printf
                  |L1.148|
;;;393    
;;;394    		if( uxItemSize == ( UBaseType_t ) 0 )
000094  b196              CBZ      r6,|L1.188|
;;;395    		{
;;;396    			/* There is not going to be a queue storage area. */
;;;397    			xQueueSizeInBytes = ( size_t ) 0;
;;;398    		}
;;;399    		else
;;;400    		{
;;;401    			/* Allocate enough space to hold the maximum number of items that
;;;402    			can be in the queue at any time. */
;;;403    			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000096  fb05f006          MUL      r0,r5,r6
                  |L1.154|
00009a  3048              ADDS     r0,r0,#0x48
;;;404    		}
;;;405    
;;;406    		pxNewQueue = ( Queue_t * ) pvPortMalloc( sizeof( Queue_t ) + xQueueSizeInBytes );
00009c  f7fffffe          BL       pvPortMalloc
0000a0  0004              MOVS     r4,r0
;;;407    
;;;408    		if( pxNewQueue != NULL )
0000a2  d009              BEQ      |L1.184|
;;;409    		{
;;;410    			/* Jump past the queue structure to find the location of the queue
;;;411    			storage area. */
;;;412    			pucQueueStorage = ( ( uint8_t * ) pxNewQueue ) + sizeof( Queue_t );
0000a4  f1040148          ADD      r1,r4,#0x48
;;;413    
;;;414    			#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;415    			{
;;;416    				/* Queues can be created either statically or dynamically, so
;;;417    				note this task was created dynamically in case it is later
;;;418    				deleted. */
;;;419    				pxNewQueue->ucStaticallyAllocated = pdFALSE;
;;;420    			}
;;;421    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;422    
;;;423    			prvInitialiseNewQueue( uxQueueLength, uxItemSize, pucQueueStorage, ucQueueType, pxNewQueue );
0000a8  4620              MOV      r0,r4
0000aa  b14e              CBZ      r6,|L1.192|
0000ac  6001              STR      r1,[r0,#0]
                  |L1.174|
0000ae  e9c0560f          STRD     r5,r6,[r0,#0x3c]
0000b2  2101              MOVS     r1,#1
0000b4  f7fffffe          BL       xQueueGenericReset
                  |L1.184|
;;;424    		}
;;;425    
;;;426    		return pxNewQueue;
0000b8  4620              MOV      r0,r4
;;;427    	}
0000ba  bd70              POP      {r4-r6,pc}
                  |L1.188|
0000bc  2000              MOVS     r0,#0                 ;397
0000be  e7ec              B        |L1.154|
                  |L1.192|
0000c0  6000              STR      r0,[r0,#0]            ;397
0000c2  e7f4              B        |L1.174|
;;;428    
                          ENDP

                  prvUnlockQueue PROC
;;;1793   
;;;1794   static void prvUnlockQueue( Queue_t * const pxQueue )
0000c4  e92d41f0          PUSH     {r4-r8,lr}
;;;1795   {
0000c8  4604              MOV      r4,r0
;;;1796   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED. */
;;;1797   
;;;1798   	/* The lock counts contains the number of extra data items placed or
;;;1799   	removed from the queue while the queue was locked.  When a queue is
;;;1800   	locked items can be added or removed, but the event lists cannot be
;;;1801   	updated. */
;;;1802   	taskENTER_CRITICAL();
0000ca  f7fffffe          BL       vPortEnterCritical
;;;1803   	{
;;;1804   		int8_t cTxLock = pxQueue->cTxLock;
0000ce  f9945045          LDRSB    r5,[r4,#0x45]
;;;1805   
;;;1806   		/* See if data was added to the queue while it was locked. */
;;;1807   		while( cTxLock > queueLOCKED_UNMODIFIED )
;;;1808   		{
;;;1809   			/* Data was posted while the queue was locked.  Are any tasks
;;;1810   			blocked waiting for data to become available? */
;;;1811   			#if ( configUSE_QUEUE_SETS == 1 )
;;;1812   			{
;;;1813   				if( pxQueue->pxQueueSetContainer != NULL )
;;;1814   				{
;;;1815   					if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1816   					{
;;;1817   						/* The queue is a member of a queue set, and posting to
;;;1818   						the queue set caused a higher priority task to unblock.
;;;1819   						A context switch is required. */
;;;1820   						vTaskMissedYield();
;;;1821   					}
;;;1822   					else
;;;1823   					{
;;;1824   						mtCOVERAGE_TEST_MARKER();
;;;1825   					}
;;;1826   				}
;;;1827   				else
;;;1828   				{
;;;1829   					/* Tasks that are removed from the event list will get
;;;1830   					added to the pending ready list as the scheduler is still
;;;1831   					suspended. */
;;;1832   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1833   					{
;;;1834   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1835   						{
;;;1836   							/* The task waiting has a higher priority so record that a
;;;1837   							context	switch is required. */
;;;1838   							vTaskMissedYield();
;;;1839   						}
;;;1840   						else
;;;1841   						{
;;;1842   							mtCOVERAGE_TEST_MARKER();
;;;1843   						}
;;;1844   					}
;;;1845   					else
;;;1846   					{
;;;1847   						break;
;;;1848   					}
;;;1849   				}
;;;1850   			}
;;;1851   			#else /* configUSE_QUEUE_SETS */
;;;1852   			{
;;;1853   				/* Tasks that are removed from the event list will get added to
;;;1854   				the pending ready list as the scheduler is still suspended. */
;;;1855   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1856   				{
;;;1857   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
0000d2  f1040624          ADD      r6,r4,#0x24
0000d6  e009              B        |L1.236|
                  |L1.216|
0000d8  6a60              LDR      r0,[r4,#0x24]         ;1855
0000da  b148              CBZ      r0,|L1.240|
0000dc  4630              MOV      r0,r6                 ;1855
0000de  f7fffffe          BL       xTaskRemoveFromEventList
0000e2  b108              CBZ      r0,|L1.232|
;;;1858   					{
;;;1859   						/* The task waiting has a higher priority so record that
;;;1860   						a context switch is required. */
;;;1861   						vTaskMissedYield();
0000e4  f7fffffe          BL       vTaskMissedYield
                  |L1.232|
0000e8  1e6d              SUBS     r5,r5,#1
;;;1862   					}
;;;1863   					else
;;;1864   					{
;;;1865   						mtCOVERAGE_TEST_MARKER();
;;;1866   					}
;;;1867   				}
;;;1868   				else
;;;1869   				{
;;;1870   					break;
;;;1871   				}
;;;1872   			}
;;;1873   			#endif /* configUSE_QUEUE_SETS */
;;;1874   
;;;1875   			--cTxLock;
0000ea  b26d              SXTB     r5,r5
                  |L1.236|
0000ec  2d00              CMP      r5,#0                 ;1807
0000ee  dcf3              BGT      |L1.216|
                  |L1.240|
;;;1876   		}
;;;1877   
;;;1878   		pxQueue->cTxLock = queueUNLOCKED;
0000f0  f04f36ff          MOV      r6,#0xffffffff
0000f4  f8846045          STRB     r6,[r4,#0x45]
;;;1879   	}
;;;1880   	taskEXIT_CRITICAL();
0000f8  f7fffffe          BL       vPortExitCritical
;;;1881   
;;;1882   	/* Do the same for the Rx lock. */
;;;1883   	taskENTER_CRITICAL();
0000fc  f7fffffe          BL       vPortEnterCritical
;;;1884   	{
;;;1885   		int8_t cRxLock = pxQueue->cRxLock;
000100  f9945044          LDRSB    r5,[r4,#0x44]
;;;1886   
;;;1887   		while( cRxLock > queueLOCKED_UNMODIFIED )
;;;1888   		{
;;;1889   			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1890   			{
;;;1891   				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
000104  f1040710          ADD      r7,r4,#0x10
000108  e009              B        |L1.286|
                  |L1.266|
00010a  6920              LDR      r0,[r4,#0x10]         ;1889
00010c  b148              CBZ      r0,|L1.290|
00010e  4638              MOV      r0,r7                 ;1889
000110  f7fffffe          BL       xTaskRemoveFromEventList
000114  b108              CBZ      r0,|L1.282|
;;;1892   				{
;;;1893   					vTaskMissedYield();
000116  f7fffffe          BL       vTaskMissedYield
                  |L1.282|
00011a  1e6d              SUBS     r5,r5,#1
;;;1894   				}
;;;1895   				else
;;;1896   				{
;;;1897   					mtCOVERAGE_TEST_MARKER();
;;;1898   				}
;;;1899   
;;;1900   				--cRxLock;
00011c  b26d              SXTB     r5,r5
                  |L1.286|
00011e  2d00              CMP      r5,#0                 ;1887
000120  dcf3              BGT      |L1.266|
                  |L1.290|
;;;1901   			}
;;;1902   			else
;;;1903   			{
;;;1904   				break;
;;;1905   			}
;;;1906   		}
;;;1907   
;;;1908   		pxQueue->cRxLock = queueUNLOCKED;
000122  f8846044          STRB     r6,[r4,#0x44]
;;;1909   	}
;;;1910   	taskEXIT_CRITICAL();
000126  e8bd41f0          POP      {r4-r8,lr}
00012a  f7ffbffe          B.W      vPortExitCritical
;;;1911   }
;;;1912   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataToQueue PROC
;;;1696   
;;;1697   static BaseType_t prvCopyDataToQueue( Queue_t * const pxQueue, const void *pvItemToQueue, const BaseType_t xPosition )
00012e  e92d41f0          PUSH     {r4-r8,lr}
;;;1698   {
;;;1699   BaseType_t xReturn = pdFALSE;
;;;1700   UBaseType_t uxMessagesWaiting;
;;;1701   
;;;1702   	/* This function is called from a critical section. */
;;;1703   
;;;1704   	uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000132  6b85              LDR      r5,[r0,#0x38]
000134  4617              MOV      r7,r2                 ;1698
000136  4604              MOV      r4,r0                 ;1698
000138  2600              MOVS     r6,#0                 ;1699
00013a  6c02              LDR      r2,[r0,#0x40]         ;1698
00013c  b182              CBZ      r2,|L1.352|
;;;1705   
;;;1706   	if( pxQueue->uxItemSize == ( UBaseType_t ) 0 )
;;;1707   	{
;;;1708   		#if ( configUSE_MUTEXES == 1 )
;;;1709   		{
;;;1710   			if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1711   			{
;;;1712   				/* The mutex is no longer being held. */
;;;1713   				xReturn = xTaskPriorityDisinherit( ( void * ) pxQueue->pxMutexHolder );
;;;1714   				pxQueue->pxMutexHolder = NULL;
;;;1715   			}
;;;1716   			else
;;;1717   			{
;;;1718   				mtCOVERAGE_TEST_MARKER();
;;;1719   			}
;;;1720   		}
;;;1721   		#endif /* configUSE_MUTEXES */
;;;1722   	}
;;;1723   	else if( xPosition == queueSEND_TO_BACK )
00013e  b1c7              CBZ      r7,|L1.370|
;;;1724   	{
;;;1725   		( void ) memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports, plus previous logic ensures a null pointer can only be passed to memcpy() if the copy size is 0. */
;;;1726   		pxQueue->pcWriteTo += pxQueue->uxItemSize;
;;;1727   		if( pxQueue->pcWriteTo >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
;;;1728   		{
;;;1729   			pxQueue->pcWriteTo = pxQueue->pcHead;
;;;1730   		}
;;;1731   		else
;;;1732   		{
;;;1733   			mtCOVERAGE_TEST_MARKER();
;;;1734   		}
;;;1735   	}
;;;1736   	else
;;;1737   	{
;;;1738   		( void ) memcpy( ( void * ) pxQueue->u.pcReadFrom, pvItemToQueue, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000140  68e0              LDR      r0,[r4,#0xc]
000142  f7fffffe          BL       __aeabi_memcpy
;;;1739   		pxQueue->u.pcReadFrom -= pxQueue->uxItemSize;
000146  68e1              LDR      r1,[r4,#0xc]
000148  6c20              LDR      r0,[r4,#0x40]
00014a  1a09              SUBS     r1,r1,r0
;;;1740   		if( pxQueue->u.pcReadFrom < pxQueue->pcHead ) /*lint !e946 MISRA exception justified as comparison of pointers is the cleanest solution. */
00014c  60e1              STR      r1,[r4,#0xc]
00014e  6822              LDR      r2,[r4,#0]
000150  4291              CMP      r1,r2
000152  d202              BCS      |L1.346|
;;;1741   		{
;;;1742   			pxQueue->u.pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
000154  6861              LDR      r1,[r4,#4]
000156  1a08              SUBS     r0,r1,r0
000158  60e0              STR      r0,[r4,#0xc]
                  |L1.346|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   
;;;1749   		if( xPosition == queueOVERWRITE )
00015a  2f02              CMP      r7,#2
00015c  d016              BEQ      |L1.396|
00015e  e017              B        |L1.400|
                  |L1.352|
000160  6820              LDR      r0,[r4,#0]            ;1710
000162  b9a8              CBNZ     r0,|L1.400|
000164  6860              LDR      r0,[r4,#4]            ;1713
000166  f7fffffe          BL       xTaskPriorityDisinherit
00016a  4606              MOV      r6,r0                 ;1713
00016c  2000              MOVS     r0,#0                 ;1714
00016e  6060              STR      r0,[r4,#4]            ;1714
000170  e00e              B        |L1.400|
                  |L1.370|
000172  68a0              LDR      r0,[r4,#8]            ;1725
000174  f7fffffe          BL       __aeabi_memcpy
000178  6c21              LDR      r1,[r4,#0x40]         ;1726
00017a  68a0              LDR      r0,[r4,#8]            ;1726
00017c  4408              ADD      r0,r0,r1              ;1726
00017e  60a0              STR      r0,[r4,#8]            ;1727
000180  6861              LDR      r1,[r4,#4]            ;1727
000182  4288              CMP      r0,r1                 ;1727
000184  d304              BCC      |L1.400|
000186  6820              LDR      r0,[r4,#0]            ;1729
000188  60a0              STR      r0,[r4,#8]            ;1729
00018a  e001              B        |L1.400|
                  |L1.396|
;;;1750   		{
;;;1751   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
00018c  b105              CBZ      r5,|L1.400|
00018e  1e6d              SUBS     r5,r5,#1
                  |L1.400|
000190  1c6d              ADDS     r5,r5,#1
;;;1752   			{
;;;1753   				/* An item is not being added but overwritten, so subtract
;;;1754   				one from the recorded number of items in the queue so when
;;;1755   				one is added again below the number of recorded items remains
;;;1756   				correct. */
;;;1757   				--uxMessagesWaiting;
;;;1758   			}
;;;1759   			else
;;;1760   			{
;;;1761   				mtCOVERAGE_TEST_MARKER();
;;;1762   			}
;;;1763   		}
;;;1764   		else
;;;1765   		{
;;;1766   			mtCOVERAGE_TEST_MARKER();
;;;1767   		}
;;;1768   	}
;;;1769   
;;;1770   	pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
000192  63a5              STR      r5,[r4,#0x38]
;;;1771   
;;;1772   	return xReturn;
000194  4630              MOV      r0,r6
                  |L1.406|
;;;1773   }
000196  e8bd81f0          POP      {r4-r8,pc}
;;;1774   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericSend PROC
;;;722    
;;;723    BaseType_t xQueueGenericSend( QueueHandle_t xQueue, const void * const pvItemToQueue, TickType_t xTicksToWait, const BaseType_t xCopyPosition )
00019a  e92d4fff          PUSH     {r0-r11,lr}
;;;724    {
00019e  b083              SUB      sp,sp,#0xc
0001a0  461f              MOV      r7,r3
0001a2  468b              MOV      r11,r1
0001a4  0004              MOVS     r4,r0
;;;725    BaseType_t xEntryTimeSet = pdFALSE, xYieldRequired;
0001a6  f04f0600          MOV      r6,#0
0001aa  d105              BNE      |L1.440|
;;;726    TimeOut_t xTimeOut;
;;;727    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;728    
;;;729    	configASSERT( pxQueue );
0001ac  f24022d9          MOV      r2,#0x2d9
0001b0  a18e              ADR      r1,|L1.1004|
0001b2  a095              ADR      r0,|L1.1032|
0001b4  f7fffffe          BL       __2printf
                  |L1.440|
;;;730    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
0001b8  f1bb0f00          CMP      r11,#0
0001bc  d107              BNE      |L1.462|
0001be  6c20              LDR      r0,[r4,#0x40]
0001c0  b128              CBZ      r0,|L1.462|
0001c2  f24022da          MOV      r2,#0x2da
0001c6  a189              ADR      r1,|L1.1004|
0001c8  a08f              ADR      r0,|L1.1032|
0001ca  f7fffffe          BL       __2printf
                  |L1.462|
;;;731    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
0001ce  2f02              CMP      r7,#2
0001d0  d108              BNE      |L1.484|
0001d2  6be0              LDR      r0,[r4,#0x3c]
0001d4  2801              CMP      r0,#1
0001d6  d005              BEQ      |L1.484|
0001d8  f24022db          MOV      r2,#0x2db
0001dc  a183              ADR      r1,|L1.1004|
0001de  a08a              ADR      r0,|L1.1032|
0001e0  f7fffffe          BL       __2printf
                  |L1.484|
;;;732    	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;733    	{
;;;734    		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0001e4  f7fffffe          BL       xTaskGetSchedulerState
0001e8  b938              CBNZ     r0,|L1.506|
0001ea  9805              LDR      r0,[sp,#0x14]
0001ec  b128              CBZ      r0,|L1.506|
0001ee  f24022de          MOV      r2,#0x2de
0001f2  a17e              ADR      r1,|L1.1004|
0001f4  a084              ADR      r0,|L1.1032|
0001f6  f7fffffe          BL       __2printf
                  |L1.506|
0001fa  f04f0a00          MOV      r10,#0
;;;735    	}
;;;736    	#endif
;;;737    
;;;738    
;;;739    	/* This function relaxes the coding standard somewhat to allow return
;;;740    	statements within the function itself.  This is done in the interest
;;;741    	of execution time efficiency. */
;;;742    	for( ;; )
;;;743    	{
;;;744    		taskENTER_CRITICAL();
;;;745    		{
;;;746    			/* Is there room on the queue now?  The running task must be the
;;;747    			highest priority task wanting to access the queue.  If the head item
;;;748    			in the queue is to be overwritten then it does not matter if the
;;;749    			queue is full. */
;;;750    			if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
;;;751    			{
;;;752    				traceQUEUE_SEND( pxQueue );
;;;753    				xYieldRequired = prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;754    
;;;755    				#if ( configUSE_QUEUE_SETS == 1 )
;;;756    				{
;;;757    					if( pxQueue->pxQueueSetContainer != NULL )
;;;758    					{
;;;759    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;760    						{
;;;761    							/* The queue is a member of a queue set, and posting
;;;762    							to the queue set caused a higher priority task to
;;;763    							unblock. A context switch is required. */
;;;764    							queueYIELD_IF_USING_PREEMPTION();
;;;765    						}
;;;766    						else
;;;767    						{
;;;768    							mtCOVERAGE_TEST_MARKER();
;;;769    						}
;;;770    					}
;;;771    					else
;;;772    					{
;;;773    						/* If there was a task waiting for data to arrive on the
;;;774    						queue then unblock it now. */
;;;775    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;776    						{
;;;777    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;778    							{
;;;779    								/* The unblocked task has a priority higher than
;;;780    								our own so yield immediately.  Yes it is ok to
;;;781    								do this from within the critical section - the
;;;782    								kernel takes care of that. */
;;;783    								queueYIELD_IF_USING_PREEMPTION();
;;;784    							}
;;;785    							else
;;;786    							{
;;;787    								mtCOVERAGE_TEST_MARKER();
;;;788    							}
;;;789    						}
;;;790    						else if( xYieldRequired != pdFALSE )
;;;791    						{
;;;792    							/* This path is a special case that will only get
;;;793    							executed if the task was holding multiple mutexes
;;;794    							and the mutexes were given back in an order that is
;;;795    							different to that in which they were taken. */
;;;796    							queueYIELD_IF_USING_PREEMPTION();
;;;797    						}
;;;798    						else
;;;799    						{
;;;800    							mtCOVERAGE_TEST_MARKER();
;;;801    						}
;;;802    					}
;;;803    				}
;;;804    				#else /* configUSE_QUEUE_SETS */
;;;805    				{
;;;806    					/* If there was a task waiting for data to arrive on the
;;;807    					queue then unblock it now. */
;;;808    					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;809    					{
;;;810    						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;811    						{
;;;812    							/* The unblocked task has a priority higher than
;;;813    							our own so yield immediately.  Yes it is ok to do
;;;814    							this from within the critical section - the kernel
;;;815    							takes care of that. */
;;;816    							queueYIELD_IF_USING_PREEMPTION();
0001fe  f04f5880          MOV      r8,#0x10000000
000202  f8df9214          LDR      r9,|L1.1048|
                  |L1.518|
000206  f7fffffe          BL       vPortEnterCritical
00020a  6ba0              LDR      r0,[r4,#0x38]         ;750
00020c  6be1              LDR      r1,[r4,#0x3c]         ;750
00020e  4288              CMP      r0,r1                 ;750
000210  d305              BCC      |L1.542|
000212  2f02              CMP      r7,#2                 ;750
000214  d003              BEQ      |L1.542|
;;;817    						}
;;;818    						else
;;;819    						{
;;;820    							mtCOVERAGE_TEST_MARKER();
;;;821    						}
;;;822    					}
;;;823    					else if( xYieldRequired != pdFALSE )
;;;824    					{
;;;825    						/* This path is a special case that will only get
;;;826    						executed if the task was holding multiple mutexes and
;;;827    						the mutexes were given back in an order that is
;;;828    						different to that in which they were taken. */
;;;829    						queueYIELD_IF_USING_PREEMPTION();
;;;830    					}
;;;831    					else
;;;832    					{
;;;833    						mtCOVERAGE_TEST_MARKER();
;;;834    					}
;;;835    				}
;;;836    				#endif /* configUSE_QUEUE_SETS */
;;;837    
;;;838    				taskEXIT_CRITICAL();
;;;839    				return pdPASS;
;;;840    			}
;;;841    			else
;;;842    			{
;;;843    				if( xTicksToWait == ( TickType_t ) 0 )
000216  9805              LDR      r0,[sp,#0x14]
000218  b1c8              CBZ      r0,|L1.590|
;;;844    				{
;;;845    					/* The queue was full and no block time is specified (or
;;;846    					the block time has expired) so leave now. */
;;;847    					taskEXIT_CRITICAL();
;;;848    
;;;849    					/* Return to the original privilege level before exiting
;;;850    					the function. */
;;;851    					traceQUEUE_SEND_FAILED( pxQueue );
;;;852    					return errQUEUE_FULL;
;;;853    				}
;;;854    				else if( xEntryTimeSet == pdFALSE )
00021a  b1de              CBZ      r6,|L1.596|
00021c  e01e              B        |L1.604|
                  |L1.542|
00021e  463a              MOV      r2,r7                 ;753
000220  4659              MOV      r1,r11                ;753
000222  4620              MOV      r0,r4                 ;753
000224  f7fffffe          BL       prvCopyDataToQueue
000228  6a61              LDR      r1,[r4,#0x24]         ;808
00022a  b119              CBZ      r1,|L1.564|
00022c  f1040024          ADD      r0,r4,#0x24           ;810
000230  f7fffffe          BL       xTaskRemoveFromEventList
                  |L1.564|
000234  b128              CBZ      r0,|L1.578|
000236  f8c98000          STR      r8,[r9,#0]            ;829
00023a  f3bf8f4f          DSB                            ;829
00023e  f3bf8f6f          ISB                            ;829
                  |L1.578|
000242  f7fffffe          BL       vPortExitCritical
000246  2001              MOVS     r0,#1                 ;839
                  |L1.584|
;;;855    				{
;;;856    					/* The queue was full and a block time was specified so
;;;857    					configure the timeout structure. */
;;;858    					vTaskSetTimeOutState( &xTimeOut );
;;;859    					xEntryTimeSet = pdTRUE;
;;;860    				}
;;;861    				else
;;;862    				{
;;;863    					/* Entry time was already set. */
;;;864    					mtCOVERAGE_TEST_MARKER();
;;;865    				}
;;;866    			}
;;;867    		}
;;;868    		taskEXIT_CRITICAL();
;;;869    
;;;870    		/* Interrupts and other tasks can send to and receive from the queue
;;;871    		now the critical section has been exited. */
;;;872    
;;;873    		vTaskSuspendAll();
;;;874    		prvLockQueue( pxQueue );
;;;875    
;;;876    		/* Update the timeout state to see if it has expired yet. */
;;;877    		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;878    		{
;;;879    			if( prvIsQueueFull( pxQueue ) != pdFALSE )
;;;880    			{
;;;881    				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
;;;882    				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
;;;883    
;;;884    				/* Unlocking the queue means queue events can effect the
;;;885    				event list.  It is possible	that interrupts occurring now
;;;886    				remove this task from the event	list again - but as the
;;;887    				scheduler is suspended the task will go onto the pending
;;;888    				ready last instead of the actual ready list. */
;;;889    				prvUnlockQueue( pxQueue );
;;;890    
;;;891    				/* Resuming the scheduler will move tasks from the pending
;;;892    				ready list into the ready list - so it is feasible that this
;;;893    				task is already in a ready list before it yields - in which
;;;894    				case the yield will not cause a context switch unless there
;;;895    				is also a higher priority task in the pending ready list. */
;;;896    				if( xTaskResumeAll() == pdFALSE )
;;;897    				{
;;;898    					portYIELD_WITHIN_API();
;;;899    				}
;;;900    			}
;;;901    			else
;;;902    			{
;;;903    				/* Try again. */
;;;904    				prvUnlockQueue( pxQueue );
;;;905    				( void ) xTaskResumeAll();
;;;906    			}
;;;907    		}
;;;908    		else
;;;909    		{
;;;910    			/* The timeout has expired. */
;;;911    			prvUnlockQueue( pxQueue );
;;;912    			( void ) xTaskResumeAll();
;;;913    
;;;914    			traceQUEUE_SEND_FAILED( pxQueue );
;;;915    			return errQUEUE_FULL;
;;;916    		}
;;;917    	}
;;;918    }
000248  b007              ADD      sp,sp,#0x1c
00024a  e8bd8ff0          POP      {r4-r11,pc}
                  |L1.590|
00024e  f7fffffe          BL       vPortExitCritical
000252  e021              B        |L1.664|
                  |L1.596|
000254  4668              MOV      r0,sp                 ;858
000256  f7fffffe          BL       vTaskSetTimeOutState
00025a  2601              MOVS     r6,#1                 ;859
                  |L1.604|
00025c  f7fffffe          BL       vPortExitCritical
000260  f7fffffe          BL       vTaskSuspendAll
000264  f7fffffe          BL       vPortEnterCritical
000268  f9940044          LDRSB    r0,[r4,#0x44]         ;874
00026c  1c40              ADDS     r0,r0,#1              ;874
00026e  d101              BNE      |L1.628|
000270  f884a044          STRB     r10,[r4,#0x44]        ;874
                  |L1.628|
000274  f9940045          LDRSB    r0,[r4,#0x45]         ;874
000278  1c40              ADDS     r0,r0,#1              ;874
00027a  d101              BNE      |L1.640|
00027c  f884a045          STRB     r10,[r4,#0x45]        ;874
                  |L1.640|
000280  f7fffffe          BL       vPortExitCritical
000284  a905              ADD      r1,sp,#0x14           ;877
000286  4668              MOV      r0,sp                 ;877
000288  f7fffffe          BL       xTaskCheckForTimeOut
00028c  b130              CBZ      r0,|L1.668|
00028e  4620              MOV      r0,r4                 ;911
000290  f7fffffe          BL       prvUnlockQueue
000294  f7fffffe          BL       xTaskResumeAll
                  |L1.664|
000298  2000              MOVS     r0,#0                 ;915
00029a  e7d5              B        |L1.584|
                  |L1.668|
00029c  f7fffffe          BL       vPortEnterCritical
0002a0  6ba0              LDR      r0,[r4,#0x38]
0002a2  6be1              LDR      r1,[r4,#0x3c]
0002a4  4288              CMP      r0,r1
0002a6  d101              BNE      |L1.684|
0002a8  2501              MOVS     r5,#1
0002aa  e000              B        |L1.686|
                  |L1.684|
0002ac  2500              MOVS     r5,#0
                  |L1.686|
0002ae  f7fffffe          BL       vPortExitCritical
0002b2  b195              CBZ      r5,|L1.730|
0002b4  f1040010          ADD      r0,r4,#0x10           ;882
0002b8  9905              LDR      r1,[sp,#0x14]         ;882
0002ba  f7fffffe          BL       vTaskPlaceOnEventList
0002be  4620              MOV      r0,r4                 ;889
0002c0  f7fffffe          BL       prvUnlockQueue
0002c4  f7fffffe          BL       xTaskResumeAll
0002c8  2800              CMP      r0,#0                 ;896
0002ca  d19c              BNE      |L1.518|
0002cc  f8c98000          STR      r8,[r9,#0]            ;898
0002d0  f3bf8f4f          DSB                            ;898
0002d4  f3bf8f6f          ISB                            ;898
0002d8  e795              B        |L1.518|
                  |L1.730|
0002da  4620              MOV      r0,r4                 ;904
0002dc  f7fffffe          BL       prvUnlockQueue
0002e0  f7fffffe          BL       xTaskResumeAll
0002e4  e78f              B        |L1.518|
;;;919    /*-----------------------------------------------------------*/
                          ENDP

                  xQueueCreateMutex PROC
;;;505    
;;;506    	QueueHandle_t xQueueCreateMutex( const uint8_t ucQueueType )
0002e6  b510              PUSH     {r4,lr}
;;;507    	{
;;;508    	Queue_t *pxNewQueue;
;;;509    	const UBaseType_t uxMutexLength = ( UBaseType_t ) 1, uxMutexSize = ( UBaseType_t ) 0;
;;;510    
;;;511    		pxNewQueue = ( Queue_t * ) xQueueGenericCreate( uxMutexLength, uxMutexSize, ucQueueType );
0002e8  4602              MOV      r2,r0
0002ea  2100              MOVS     r1,#0
0002ec  2001              MOVS     r0,#1
0002ee  f7fffffe          BL       xQueueGenericCreate
0002f2  0004              MOVS     r4,r0
0002f4  d007              BEQ      |L1.774|
0002f6  2100              MOVS     r1,#0
0002f8  6041              STR      r1,[r0,#4]
0002fa  6001              STR      r1,[r0,#0]
0002fc  460b              MOV      r3,r1
0002fe  460a              MOV      r2,r1
000300  60c1              STR      r1,[r0,#0xc]
000302  f7fffffe          BL       xQueueGenericSend
                  |L1.774|
;;;512    		prvInitialiseMutex( pxNewQueue );
;;;513    
;;;514    		return pxNewQueue;
000306  4620              MOV      r0,r4
;;;515    	}
000308  bd10              POP      {r4,pc}
;;;516    
                          ENDP

                  xQueueGenericSendFromISR PROC
;;;920    
;;;921    BaseType_t xQueueGenericSendFromISR( QueueHandle_t xQueue, const void * const pvItemToQueue, BaseType_t * const pxHigherPriorityTaskWoken, const BaseType_t xCopyPosition )
00030a  e92d47f0          PUSH     {r4-r10,lr}
;;;922    {
00030e  461f              MOV      r7,r3
000310  4690              MOV      r8,r2
000312  4689              MOV      r9,r1
000314  0004              MOVS     r4,r0
000316  d105              BNE      |L1.804|
;;;923    BaseType_t xReturn;
;;;924    UBaseType_t uxSavedInterruptStatus;
;;;925    Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;926    
;;;927    	configASSERT( pxQueue );
000318  f240329f          MOV      r2,#0x39f
00031c  a133              ADR      r1,|L1.1004|
00031e  a03a              ADR      r0,|L1.1032|
000320  f7fffffe          BL       __2printf
                  |L1.804|
;;;928    	configASSERT( !( ( pvItemToQueue == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000324  f1b90f00          CMP      r9,#0
000328  d107              BNE      |L1.826|
00032a  6c20              LDR      r0,[r4,#0x40]
00032c  b128              CBZ      r0,|L1.826|
00032e  f44f7268          MOV      r2,#0x3a0
000332  a12e              ADR      r1,|L1.1004|
000334  a034              ADR      r0,|L1.1032|
000336  f7fffffe          BL       __2printf
                  |L1.826|
;;;929    	configASSERT( !( ( xCopyPosition == queueOVERWRITE ) && ( pxQueue->uxLength != 1 ) ) );
00033a  2f02              CMP      r7,#2
00033c  d108              BNE      |L1.848|
00033e  6be0              LDR      r0,[r4,#0x3c]
000340  2801              CMP      r0,#1
000342  d005              BEQ      |L1.848|
000344  f24032a1          MOV      r2,#0x3a1
000348  a128              ADR      r1,|L1.1004|
00034a  a02f              ADR      r0,|L1.1032|
00034c  f7fffffe          BL       __2printf
                  |L1.848|
;;;930    
;;;931    	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;932    	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;933    	above the maximum system call priority are kept permanently enabled, even
;;;934    	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;935    	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;936    	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;937    	failure if a FreeRTOS API function is called from an interrupt that has been
;;;938    	assigned a priority above the configured maximum system call priority.
;;;939    	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;940    	that have been assigned a priority at or (logically) below the maximum
;;;941    	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;942    	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;943    	More information (albeit Cortex-M specific) is provided on the following
;;;944    	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;945    	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000350  f7fffffe          BL       vPortValidateInterruptPriority
000354  2050              MOVS     r0,#0x50
000356  f3ef8611          MRS      r6,BASEPRI
00035a  f3808811          MSR      BASEPRI,r0
00035e  f3bf8f4f          DSB      
000362  f3bf8f6f          ISB      
;;;946    
;;;947    	/* Similar to xQueueGenericSend, except without blocking if there is no room
;;;948    	in the queue.  Also don't directly wake a task that was blocked on a queue
;;;949    	read, instead return a flag to say whether a context switch is required or
;;;950    	not (i.e. has a task with a higher priority than us been woken by this
;;;951    	post). */
;;;952    	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;953    	{
;;;954    		if( ( pxQueue->uxMessagesWaiting < pxQueue->uxLength ) || ( xCopyPosition == queueOVERWRITE ) )
000366  6ba0              LDR      r0,[r4,#0x38]
000368  6be1              LDR      r1,[r4,#0x3c]
00036a  4288              CMP      r0,r1
00036c  d306              BCC      |L1.892|
00036e  2f02              CMP      r7,#2
000370  d004              BEQ      |L1.892|
;;;955    		{
;;;956    			const int8_t cTxLock = pxQueue->cTxLock;
;;;957    
;;;958    			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;959    
;;;960    			/* Semaphores use xQueueGiveFromISR(), so pxQueue will not be a
;;;961    			semaphore or mutex.  That means prvCopyDataToQueue() cannot result
;;;962    			in a task disinheriting a priority and prvCopyDataToQueue() can be
;;;963    			called here even though the disinherit function does not check if
;;;964    			the scheduler is suspended before accessing the ready lists. */
;;;965    			( void ) prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
;;;966    
;;;967    			/* The event list is not altered if the queue is locked.  This will
;;;968    			be done when the queue is unlocked later. */
;;;969    			if( cTxLock == queueUNLOCKED )
;;;970    			{
;;;971    				#if ( configUSE_QUEUE_SETS == 1 )
;;;972    				{
;;;973    					if( pxQueue->pxQueueSetContainer != NULL )
;;;974    					{
;;;975    						if( prvNotifyQueueSetContainer( pxQueue, xCopyPosition ) != pdFALSE )
;;;976    						{
;;;977    							/* The queue is a member of a queue set, and posting
;;;978    							to the queue set caused a higher priority task to
;;;979    							unblock.  A context switch is required. */
;;;980    							if( pxHigherPriorityTaskWoken != NULL )
;;;981    							{
;;;982    								*pxHigherPriorityTaskWoken = pdTRUE;
;;;983    							}
;;;984    							else
;;;985    							{
;;;986    								mtCOVERAGE_TEST_MARKER();
;;;987    							}
;;;988    						}
;;;989    						else
;;;990    						{
;;;991    							mtCOVERAGE_TEST_MARKER();
;;;992    						}
;;;993    					}
;;;994    					else
;;;995    					{
;;;996    						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;997    						{
;;;998    							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;999    							{
;;;1000   								/* The task waiting has a higher priority so
;;;1001   								record that a context switch is required. */
;;;1002   								if( pxHigherPriorityTaskWoken != NULL )
;;;1003   								{
;;;1004   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1005   								}
;;;1006   								else
;;;1007   								{
;;;1008   									mtCOVERAGE_TEST_MARKER();
;;;1009   								}
;;;1010   							}
;;;1011   							else
;;;1012   							{
;;;1013   								mtCOVERAGE_TEST_MARKER();
;;;1014   							}
;;;1015   						}
;;;1016   						else
;;;1017   						{
;;;1018   							mtCOVERAGE_TEST_MARKER();
;;;1019   						}
;;;1020   					}
;;;1021   				}
;;;1022   				#else /* configUSE_QUEUE_SETS */
;;;1023   				{
;;;1024   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1025   					{
;;;1026   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1027   						{
;;;1028   							/* The task waiting has a higher priority so record that a
;;;1029   							context	switch is required. */
;;;1030   							if( pxHigherPriorityTaskWoken != NULL )
;;;1031   							{
;;;1032   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1033   							}
;;;1034   							else
;;;1035   							{
;;;1036   								mtCOVERAGE_TEST_MARKER();
;;;1037   							}
;;;1038   						}
;;;1039   						else
;;;1040   						{
;;;1041   							mtCOVERAGE_TEST_MARKER();
;;;1042   						}
;;;1043   					}
;;;1044   					else
;;;1045   					{
;;;1046   						mtCOVERAGE_TEST_MARKER();
;;;1047   					}
;;;1048   				}
;;;1049   				#endif /* configUSE_QUEUE_SETS */
;;;1050   			}
;;;1051   			else
;;;1052   			{
;;;1053   				/* Increment the lock count so the task that unlocks the queue
;;;1054   				knows that data was posted while it was locked. */
;;;1055   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
;;;1056   			}
;;;1057   
;;;1058   			xReturn = pdPASS;
;;;1059   		}
;;;1060   		else
;;;1061   		{
;;;1062   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1063   			xReturn = errQUEUE_FULL;
000372  2000              MOVS     r0,#0
                  |L1.884|
000374  f3868811          MSR      BASEPRI,r6
                  |L1.888|
;;;1064   		}
;;;1065   	}
;;;1066   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1067   
;;;1068   	return xReturn;
;;;1069   }
000378  e8bd87f0          POP      {r4-r10,pc}
                  |L1.892|
00037c  f9945045          LDRSB    r5,[r4,#0x45]         ;956
000380  463a              MOV      r2,r7                 ;965
000382  4649              MOV      r1,r9                 ;965
000384  4620              MOV      r0,r4                 ;965
000386  f7fffffe          BL       prvCopyDataToQueue
00038a  1c68              ADDS     r0,r5,#1              ;969
00038c  d004              BEQ      |L1.920|
00038e  1c6d              ADDS     r5,r5,#1              ;969
000390  f8845045          STRB     r5,[r4,#0x45]         ;1055
                  |L1.916|
000394  2001              MOVS     r0,#1                 ;1058
000396  e7ed              B        |L1.884|
                  |L1.920|
000398  6a60              LDR      r0,[r4,#0x24]         ;1024
00039a  2800              CMP      r0,#0                 ;1024
00039c  d0fa              BEQ      |L1.916|
00039e  f1040024          ADD      r0,r4,#0x24           ;1026
0003a2  f7fffffe          BL       xTaskRemoveFromEventList
0003a6  2800              CMP      r0,#0                 ;1026
0003a8  d0f4              BEQ      |L1.916|
0003aa  f1b80f00          CMP      r8,#0                 ;1030
0003ae  d0f1              BEQ      |L1.916|
0003b0  2101              MOVS     r1,#1                 ;1032
0003b2  f8c81000          STR      r1,[r8,#0]            ;1032
0003b6  e7ed              B        |L1.916|
;;;1070   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGiveFromISR PROC
;;;1071   
;;;1072   BaseType_t xQueueGiveFromISR( QueueHandle_t xQueue, BaseType_t * const pxHigherPriorityTaskWoken )
0003b8  b570              PUSH     {r4-r6,lr}
;;;1073   {
0003ba  460e              MOV      r6,r1
0003bc  0004              MOVS     r4,r0
0003be  d105              BNE      |L1.972|
;;;1074   BaseType_t xReturn;
;;;1075   UBaseType_t uxSavedInterruptStatus;
;;;1076   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1077   
;;;1078   	/* Similar to xQueueGenericSendFromISR() but used with semaphores where the
;;;1079   	item size is 0.  Don't directly wake a task that was blocked on a queue
;;;1080   	read, instead return a flag to say whether a context switch is required or
;;;1081   	not (i.e. has a task with a higher priority than us been woken by this
;;;1082   	post). */
;;;1083   
;;;1084   	configASSERT( pxQueue );
0003c0  f240423c          MOV      r2,#0x43c
0003c4  a109              ADR      r1,|L1.1004|
0003c6  a010              ADR      r0,|L1.1032|
0003c8  f7fffffe          BL       __2printf
                  |L1.972|
;;;1085   
;;;1086   	/* xQueueGenericSendFromISR() should be used instead of xQueueGiveFromISR()
;;;1087   	if the item size is not 0. */
;;;1088   	configASSERT( pxQueue->uxItemSize == 0 );
0003cc  6c20              LDR      r0,[r4,#0x40]
0003ce  b128              CBZ      r0,|L1.988|
0003d0  f44f6288          MOV      r2,#0x440
0003d4  a105              ADR      r1,|L1.1004|
0003d6  a00c              ADR      r0,|L1.1032|
0003d8  f7fffffe          BL       __2printf
                  |L1.988|
;;;1089   
;;;1090   	/* Normally a mutex would not be given from an interrupt, especially if
;;;1091   	there is a mutex holder, as priority inheritance makes no sense for an
;;;1092   	interrupts, only tasks. */
;;;1093   	configASSERT( !( ( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX ) && ( pxQueue->pxMutexHolder != NULL ) ) );
0003dc  6820              LDR      r0,[r4,#0]
0003de  bb08              CBNZ     r0,|L1.1060|
0003e0  6860              LDR      r0,[r4,#4]
0003e2  b1f8              CBZ      r0,|L1.1060|
0003e4  f2404245          MOV      r2,#0x445
0003e8  a100              ADR      r1,|L1.1004|
0003ea  e017              B        |L1.1052|
                  |L1.1004|
0003ec  2e2e5c2e          DCB      "..\\..\\FreeRTOS\\src\\queue.c",0
0003f0  2e5c4672
0003f4  65655254
0003f8  4f535c73
0003fc  72635c71
000400  75657565
000404  2e6300  
000407  00                DCB      0
                  |L1.1032|
000408  4572726f          DCB      "Error:%s,%d\r\n",0
00040c  723a2573
000410  2c25640d
000414  0a00    
000416  00                DCB      0
000417  00                DCB      0
                  |L1.1048|
                          DCD      0xe000ed04
                  |L1.1052|
00041c  f2af0018          ADR      r0,|L1.1032|
000420  f7fffffe          BL       __2printf
                  |L1.1060|
;;;1094   
;;;1095   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1096   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1097   	above the maximum system call priority are kept permanently enabled, even
;;;1098   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1099   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1100   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1101   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1102   	assigned a priority above the configured maximum system call priority.
;;;1103   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1104   	that have been assigned a priority at or (logically) below the maximum
;;;1105   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1106   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1107   	More information (albeit Cortex-M specific) is provided on the following
;;;1108   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1109   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000424  f7fffffe          BL       vPortValidateInterruptPriority
000428  2050              MOVS     r0,#0x50
00042a  f3ef8511          MRS      r5,BASEPRI
00042e  f3808811          MSR      BASEPRI,r0
000432  f3bf8f4f          DSB      
000436  f3bf8f6f          ISB      
;;;1110   
;;;1111   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1112   	{
;;;1113   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
00043a  6ba1              LDR      r1,[r4,#0x38]
;;;1114   
;;;1115   		/* When the queue is used to implement a semaphore no data is ever
;;;1116   		moved through the queue but it is still valid to see if the queue 'has
;;;1117   		space'. */
;;;1118   		if( uxMessagesWaiting < pxQueue->uxLength )
00043c  6be0              LDR      r0,[r4,#0x3c]
00043e  4288              CMP      r0,r1
000440  d918              BLS      |L1.1140|
;;;1119   		{
;;;1120   			const int8_t cTxLock = pxQueue->cTxLock;
000442  f9940045          LDRSB    r0,[r4,#0x45]
000446  1c49              ADDS     r1,r1,#1
;;;1121   
;;;1122   			traceQUEUE_SEND_FROM_ISR( pxQueue );
;;;1123   
;;;1124   			/* A task can only have an inherited priority if it is a mutex
;;;1125   			holder - and if there is a mutex holder then the mutex cannot be
;;;1126   			given from an ISR.  As this is the ISR version of the function it
;;;1127   			can be assumed there is no mutex holder and no need to determine if
;;;1128   			priority disinheritance is needed.  Simply increase the count of
;;;1129   			messages (semaphores) available. */
;;;1130   			pxQueue->uxMessagesWaiting = uxMessagesWaiting + 1;
000448  63a1              STR      r1,[r4,#0x38]
;;;1131   
;;;1132   			/* The event list is not altered if the queue is locked.  This will
;;;1133   			be done when the queue is unlocked later. */
;;;1134   			if( cTxLock == queueUNLOCKED )
00044a  1c41              ADDS     r1,r0,#1
00044c  d004              BEQ      |L1.1112|
00044e  1c40              ADDS     r0,r0,#1
;;;1135   			{
;;;1136   				#if ( configUSE_QUEUE_SETS == 1 )
;;;1137   				{
;;;1138   					if( pxQueue->pxQueueSetContainer != NULL )
;;;1139   					{
;;;1140   						if( prvNotifyQueueSetContainer( pxQueue, queueSEND_TO_BACK ) != pdFALSE )
;;;1141   						{
;;;1142   							/* The semaphore is a member of a queue set, and
;;;1143   							posting	to the queue set caused a higher priority
;;;1144   							task to	unblock.  A context switch is required. */
;;;1145   							if( pxHigherPriorityTaskWoken != NULL )
;;;1146   							{
;;;1147   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1148   							}
;;;1149   							else
;;;1150   							{
;;;1151   								mtCOVERAGE_TEST_MARKER();
;;;1152   							}
;;;1153   						}
;;;1154   						else
;;;1155   						{
;;;1156   							mtCOVERAGE_TEST_MARKER();
;;;1157   						}
;;;1158   					}
;;;1159   					else
;;;1160   					{
;;;1161   						if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1162   						{
;;;1163   							if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1164   							{
;;;1165   								/* The task waiting has a higher priority so
;;;1166   								record that a context switch is required. */
;;;1167   								if( pxHigherPriorityTaskWoken != NULL )
;;;1168   								{
;;;1169   									*pxHigherPriorityTaskWoken = pdTRUE;
;;;1170   								}
;;;1171   								else
;;;1172   								{
;;;1173   									mtCOVERAGE_TEST_MARKER();
;;;1174   								}
;;;1175   							}
;;;1176   							else
;;;1177   							{
;;;1178   								mtCOVERAGE_TEST_MARKER();
;;;1179   							}
;;;1180   						}
;;;1181   						else
;;;1182   						{
;;;1183   							mtCOVERAGE_TEST_MARKER();
;;;1184   						}
;;;1185   					}
;;;1186   				}
;;;1187   				#else /* configUSE_QUEUE_SETS */
;;;1188   				{
;;;1189   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
;;;1190   					{
;;;1191   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
;;;1192   						{
;;;1193   							/* The task waiting has a higher priority so record that a
;;;1194   							context	switch is required. */
;;;1195   							if( pxHigherPriorityTaskWoken != NULL )
;;;1196   							{
;;;1197   								*pxHigherPriorityTaskWoken = pdTRUE;
;;;1198   							}
;;;1199   							else
;;;1200   							{
;;;1201   								mtCOVERAGE_TEST_MARKER();
;;;1202   							}
;;;1203   						}
;;;1204   						else
;;;1205   						{
;;;1206   							mtCOVERAGE_TEST_MARKER();
;;;1207   						}
;;;1208   					}
;;;1209   					else
;;;1210   					{
;;;1211   						mtCOVERAGE_TEST_MARKER();
;;;1212   					}
;;;1213   				}
;;;1214   				#endif /* configUSE_QUEUE_SETS */
;;;1215   			}
;;;1216   			else
;;;1217   			{
;;;1218   				/* Increment the lock count so the task that unlocks the queue
;;;1219   				knows that data was posted while it was locked. */
;;;1220   				pxQueue->cTxLock = ( int8_t ) ( cTxLock + 1 );
000450  f8840045          STRB     r0,[r4,#0x45]
                  |L1.1108|
;;;1221   			}
;;;1222   
;;;1223   			xReturn = pdPASS;
000454  2001              MOVS     r0,#1
;;;1224   		}
000456  e00e              B        |L1.1142|
                  |L1.1112|
000458  6a60              LDR      r0,[r4,#0x24]         ;1189
00045a  2800              CMP      r0,#0                 ;1189
00045c  d0fa              BEQ      |L1.1108|
00045e  f1040024          ADD      r0,r4,#0x24           ;1191
000462  f7fffffe          BL       xTaskRemoveFromEventList
000466  2800              CMP      r0,#0                 ;1191
000468  d0f4              BEQ      |L1.1108|
00046a  2e00              CMP      r6,#0                 ;1195
00046c  d0f2              BEQ      |L1.1108|
00046e  2001              MOVS     r0,#1                 ;1197
000470  6030              STR      r0,[r6,#0]            ;1197
000472  e7ef              B        |L1.1108|
                  |L1.1140|
;;;1225   		else
;;;1226   		{
;;;1227   			traceQUEUE_SEND_FROM_ISR_FAILED( pxQueue );
;;;1228   			xReturn = errQUEUE_FULL;
000474  2000              MOVS     r0,#0
                  |L1.1142|
000476  f3858811          MSR      BASEPRI,r5
;;;1229   		}
;;;1230   	}
;;;1231   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1232   
;;;1233   	return xReturn;
;;;1234   }
00047a  bd70              POP      {r4-r6,pc}
;;;1235   /*-----------------------------------------------------------*/
                          ENDP

                  prvCopyDataFromQueue PROC
;;;1775   
;;;1776   static void prvCopyDataFromQueue( Queue_t * const pxQueue, void * const pvBuffer )
00047c  b430              PUSH     {r4,r5}
;;;1777   {
00047e  6c02              LDR      r2,[r0,#0x40]
000480  460b              MOV      r3,r1
000482  2a00              CMP      r2,#0
000484  d00b              BEQ      |L1.1182|
;;;1778   	if( pxQueue->uxItemSize != ( UBaseType_t ) 0 )
;;;1779   	{
;;;1780   		pxQueue->u.pcReadFrom += pxQueue->uxItemSize;
000486  68c1              LDR      r1,[r0,#0xc]
000488  4411              ADD      r1,r1,r2
;;;1781   		if( pxQueue->u.pcReadFrom >= pxQueue->pcTail ) /*lint !e946 MISRA exception justified as use of the relational operator is the cleanest solutions. */
00048a  60c1              STR      r1,[r0,#0xc]
00048c  6844              LDR      r4,[r0,#4]
00048e  42a1              CMP      r1,r4
000490  d301              BCC      |L1.1174|
;;;1782   		{
;;;1783   			pxQueue->u.pcReadFrom = pxQueue->pcHead;
000492  6801              LDR      r1,[r0,#0]
000494  60c1              STR      r1,[r0,#0xc]
                  |L1.1174|
;;;1784   		}
;;;1785   		else
;;;1786   		{
;;;1787   			mtCOVERAGE_TEST_MARKER();
;;;1788   		}
;;;1789   		( void ) memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->u.pcReadFrom, ( size_t ) pxQueue->uxItemSize ); /*lint !e961 !e418 MISRA exception as the casts are only redundant for some ports.  Also previous logic ensures a null pointer can only be passed to memcpy() when the count is 0. */
000496  bc30              POP      {r4,r5}
000498  4618              MOV      r0,r3
00049a  f7ffbffe          B.W      __aeabi_memcpy
                  |L1.1182|
;;;1790   	}
;;;1791   }
00049e  bc30              POP      {r4,r5}
0004a0  4770              BX       lr
;;;1792   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueGenericReceive PROC
;;;1236   
;;;1237   BaseType_t xQueueGenericReceive( QueueHandle_t xQueue, void * const pvBuffer, TickType_t xTicksToWait, const BaseType_t xJustPeeking )
0004a2  e92d4fff          PUSH     {r0-r11,lr}
;;;1238   {
0004a6  b083              SUB      sp,sp,#0xc
0004a8  469b              MOV      r11,r3
0004aa  468a              MOV      r10,r1
0004ac  0004              MOVS     r4,r0
;;;1239   BaseType_t xEntryTimeSet = pdFALSE;
0004ae  f04f0600          MOV      r6,#0
0004b2  d107              BNE      |L1.1220|
;;;1240   TimeOut_t xTimeOut;
;;;1241   int8_t *pcOriginalReadPosition;
;;;1242   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1243   
;;;1244   	configASSERT( pxQueue );
0004b4  f24042dc          MOV      r2,#0x4dc
0004b8  f2af01d0          ADR      r1,|L1.1004|
0004bc  f2af00b8          ADR      r0,|L1.1032|
0004c0  f7fffffe          BL       __2printf
                  |L1.1220|
;;;1245   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
0004c4  f1ba0f00          CMP      r10,#0
0004c8  d109              BNE      |L1.1246|
0004ca  6c20              LDR      r0,[r4,#0x40]
0004cc  b138              CBZ      r0,|L1.1246|
0004ce  f24042dd          MOV      r2,#0x4dd
0004d2  f2af01e8          ADR      r1,|L1.1004|
0004d6  f2af00d0          ADR      r0,|L1.1032|
0004da  f7fffffe          BL       __2printf
                  |L1.1246|
;;;1246   	#if ( ( INCLUDE_xTaskGetSchedulerState == 1 ) || ( configUSE_TIMERS == 1 ) )
;;;1247   	{
;;;1248   		configASSERT( !( ( xTaskGetSchedulerState() == taskSCHEDULER_SUSPENDED ) && ( xTicksToWait != 0 ) ) );
0004de  f7fffffe          BL       xTaskGetSchedulerState
0004e2  b948              CBNZ     r0,|L1.1272|
0004e4  9805              LDR      r0,[sp,#0x14]
0004e6  b138              CBZ      r0,|L1.1272|
0004e8  f44f629c          MOV      r2,#0x4e0
0004ec  f2af1104          ADR      r1,|L1.1004|
0004f0  f2af00ec          ADR      r0,|L1.1032|
0004f4  f7fffffe          BL       __2printf
                  |L1.1272|
0004f8  f04f0900          MOV      r9,#0
;;;1249   	}
;;;1250   	#endif
;;;1251   
;;;1252   	/* This function relaxes the coding standard somewhat to allow return
;;;1253   	statements within the function itself.  This is done in the interest
;;;1254   	of execution time efficiency. */
;;;1255   
;;;1256   	for( ;; )
;;;1257   	{
;;;1258   		taskENTER_CRITICAL();
;;;1259   		{
;;;1260   			const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
;;;1261   
;;;1262   			/* Is there data in the queue now?  To be running the calling task
;;;1263   			must be the highest priority task wanting to access the queue. */
;;;1264   			if( uxMessagesWaiting > ( UBaseType_t ) 0 )
;;;1265   			{
;;;1266   				/* Remember the read position in case the queue is only being
;;;1267   				peeked. */
;;;1268   				pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1269   
;;;1270   				prvCopyDataFromQueue( pxQueue, pvBuffer );
;;;1271   
;;;1272   				if( xJustPeeking == pdFALSE )
;;;1273   				{
;;;1274   					traceQUEUE_RECEIVE( pxQueue );
;;;1275   
;;;1276   					/* Actually removing data, not just peeking. */
;;;1277   					pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
;;;1278   
;;;1279   					#if ( configUSE_MUTEXES == 1 )
;;;1280   					{
;;;1281   						if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1282   						{
;;;1283   							/* Record the information required to implement
;;;1284   							priority inheritance should it become necessary. */
;;;1285   							pxQueue->pxMutexHolder = ( int8_t * ) pvTaskIncrementMutexHeldCount(); /*lint !e961 Cast is not redundant as TaskHandle_t is a typedef. */
;;;1286   						}
;;;1287   						else
;;;1288   						{
;;;1289   							mtCOVERAGE_TEST_MARKER();
;;;1290   						}
;;;1291   					}
;;;1292   					#endif /* configUSE_MUTEXES */
;;;1293   
;;;1294   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1295   					{
;;;1296   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1297   						{
;;;1298   							queueYIELD_IF_USING_PREEMPTION();
0004fc  f04f5780          MOV      r7,#0x10000000
000500  f8df8360          LDR      r8,|L1.2148|
                  |L1.1284|
000504  f7fffffe          BL       vPortEnterCritical
000508  6ba5              LDR      r5,[r4,#0x38]         ;1260
00050a  b335              CBZ      r5,|L1.1370|
00050c  4651              MOV      r1,r10                ;1270
00050e  4620              MOV      r0,r4                 ;1270
000510  68e6              LDR      r6,[r4,#0xc]          ;1270
000512  f7fffffe          BL       prvCopyDataFromQueue
000516  f1bb0f00          CMP      r11,#0                ;1272
00051a  d011              BEQ      |L1.1344|
;;;1299   						}
;;;1300   						else
;;;1301   						{
;;;1302   							mtCOVERAGE_TEST_MARKER();
;;;1303   						}
;;;1304   					}
;;;1305   					else
;;;1306   					{
;;;1307   						mtCOVERAGE_TEST_MARKER();
;;;1308   					}
;;;1309   				}
;;;1310   				else
;;;1311   				{
;;;1312   					traceQUEUE_PEEK( pxQueue );
;;;1313   
;;;1314   					/* The data is not being removed, so reset the read
;;;1315   					pointer. */
;;;1316   					pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1317   
;;;1318   					/* The data is being left in the queue, so see if there are
;;;1319   					any other tasks waiting for the data. */
;;;1320   					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
00051c  60e6              STR      r6,[r4,#0xc]
00051e  6a60              LDR      r0,[r4,#0x24]
000520  b150              CBZ      r0,|L1.1336|
;;;1321   					{
;;;1322   						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
000522  f1040024          ADD      r0,r4,#0x24
                  |L1.1318|
000526  f7fffffe          BL       xTaskRemoveFromEventList
00052a  b128              CBZ      r0,|L1.1336|
;;;1323   						{
;;;1324   							/* The task waiting has a higher priority than this task. */
;;;1325   							queueYIELD_IF_USING_PREEMPTION();
00052c  f8c87000          STR      r7,[r8,#0]
000530  f3bf8f4f          DSB      
000534  f3bf8f6f          ISB      
                  |L1.1336|
;;;1326   						}
;;;1327   						else
;;;1328   						{
;;;1329   							mtCOVERAGE_TEST_MARKER();
;;;1330   						}
;;;1331   					}
;;;1332   					else
;;;1333   					{
;;;1334   						mtCOVERAGE_TEST_MARKER();
;;;1335   					}
;;;1336   				}
;;;1337   
;;;1338   				taskEXIT_CRITICAL();
000538  f7fffffe          BL       vPortExitCritical
;;;1339   				return pdPASS;
00053c  2001              MOVS     r0,#1
;;;1340   			}
;;;1341   			else
;;;1342   			{
;;;1343   				if( xTicksToWait == ( TickType_t ) 0 )
;;;1344   				{
;;;1345   					/* The queue was empty and no block time is specified (or
;;;1346   					the block time has expired) so leave now. */
;;;1347   					taskEXIT_CRITICAL();
;;;1348   					traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1349   					return errQUEUE_EMPTY;
;;;1350   				}
;;;1351   				else if( xEntryTimeSet == pdFALSE )
;;;1352   				{
;;;1353   					/* The queue was empty and a block time was specified so
;;;1354   					configure the timeout structure. */
;;;1355   					vTaskSetTimeOutState( &xTimeOut );
;;;1356   					xEntryTimeSet = pdTRUE;
;;;1357   				}
;;;1358   				else
;;;1359   				{
;;;1360   					/* Entry time was already set. */
;;;1361   					mtCOVERAGE_TEST_MARKER();
;;;1362   				}
;;;1363   			}
;;;1364   		}
;;;1365   		taskEXIT_CRITICAL();
;;;1366   
;;;1367   		/* Interrupts and other tasks can send to and receive from the queue
;;;1368   		now the critical section has been exited. */
;;;1369   
;;;1370   		vTaskSuspendAll();
;;;1371   		prvLockQueue( pxQueue );
;;;1372   
;;;1373   		/* Update the timeout state to see if it has expired yet. */
;;;1374   		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
;;;1375   		{
;;;1376   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1377   			{
;;;1378   				traceBLOCKING_ON_QUEUE_RECEIVE( pxQueue );
;;;1379   
;;;1380   				#if ( configUSE_MUTEXES == 1 )
;;;1381   				{
;;;1382   					if( pxQueue->uxQueueType == queueQUEUE_IS_MUTEX )
;;;1383   					{
;;;1384   						taskENTER_CRITICAL();
;;;1385   						{
;;;1386   							vTaskPriorityInherit( ( void * ) pxQueue->pxMutexHolder );
;;;1387   						}
;;;1388   						taskEXIT_CRITICAL();
;;;1389   					}
;;;1390   					else
;;;1391   					{
;;;1392   						mtCOVERAGE_TEST_MARKER();
;;;1393   					}
;;;1394   				}
;;;1395   				#endif
;;;1396   
;;;1397   				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
;;;1398   				prvUnlockQueue( pxQueue );
;;;1399   				if( xTaskResumeAll() == pdFALSE )
;;;1400   				{
;;;1401   					portYIELD_WITHIN_API();
;;;1402   				}
;;;1403   				else
;;;1404   				{
;;;1405   					mtCOVERAGE_TEST_MARKER();
;;;1406   				}
;;;1407   			}
;;;1408   			else
;;;1409   			{
;;;1410   				/* Try again. */
;;;1411   				prvUnlockQueue( pxQueue );
;;;1412   				( void ) xTaskResumeAll();
;;;1413   			}
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			prvUnlockQueue( pxQueue );
;;;1418   			( void ) xTaskResumeAll();
;;;1419   
;;;1420   			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
;;;1421   			{
;;;1422   				traceQUEUE_RECEIVE_FAILED( pxQueue );
;;;1423   				return errQUEUE_EMPTY;
;;;1424   			}
;;;1425   			else
;;;1426   			{
;;;1427   				mtCOVERAGE_TEST_MARKER();
;;;1428   			}
;;;1429   		}
;;;1430   	}
;;;1431   }
00053e  e683              B        |L1.584|
                  |L1.1344|
000540  1e6d              SUBS     r5,r5,#1
000542  63a5              STR      r5,[r4,#0x38]         ;1277
000544  6820              LDR      r0,[r4,#0]            ;1281
000546  b910              CBNZ     r0,|L1.1358|
000548  f7fffffe          BL       pvTaskIncrementMutexHeldCount
00054c  6060              STR      r0,[r4,#4]            ;1285
                  |L1.1358|
00054e  6920              LDR      r0,[r4,#0x10]         ;1294
000550  2800              CMP      r0,#0                 ;1294
000552  d0f1              BEQ      |L1.1336|
000554  f1040010          ADD      r0,r4,#0x10           ;1296
000558  e7e5              B        |L1.1318|
                  |L1.1370|
00055a  9805              LDR      r0,[sp,#0x14]         ;1343
00055c  b108              CBZ      r0,|L1.1378|
00055e  b11e              CBZ      r6,|L1.1384|
000560  e006              B        |L1.1392|
                  |L1.1378|
000562  f7fffffe          BL       vPortExitCritical
000566  e027              B        |L1.1464|
                  |L1.1384|
000568  4668              MOV      r0,sp                 ;1355
00056a  f7fffffe          BL       vTaskSetTimeOutState
00056e  2601              MOVS     r6,#1                 ;1356
                  |L1.1392|
000570  f7fffffe          BL       vPortExitCritical
000574  f7fffffe          BL       vTaskSuspendAll
000578  f7fffffe          BL       vPortEnterCritical
00057c  f9940044          LDRSB    r0,[r4,#0x44]         ;1371
000580  1c40              ADDS     r0,r0,#1              ;1371
000582  d101              BNE      |L1.1416|
000584  f8849044          STRB     r9,[r4,#0x44]         ;1371
                  |L1.1416|
000588  f9940045          LDRSB    r0,[r4,#0x45]         ;1371
00058c  1c40              ADDS     r0,r0,#1              ;1371
00058e  d101              BNE      |L1.1428|
000590  f8849045          STRB     r9,[r4,#0x45]         ;1371
                  |L1.1428|
000594  f7fffffe          BL       vPortExitCritical
000598  a905              ADD      r1,sp,#0x14           ;1374
00059a  4668              MOV      r0,sp                 ;1374
00059c  f7fffffe          BL       xTaskCheckForTimeOut
0005a0  2800              CMP      r0,#0                 ;1374
0005a2  4620              MOV      r0,r4                 ;1417
0005a4  d00a              BEQ      |L1.1468|
0005a6  f7fffffe          BL       prvUnlockQueue
0005aa  f7fffffe          BL       xTaskResumeAll
0005ae  4620              MOV      r0,r4                 ;1420
0005b0  f7fffffe          BL       prvIsQueueEmpty
0005b4  2800              CMP      r0,#0                 ;1420
0005b6  d0a5              BEQ      |L1.1284|
                  |L1.1464|
0005b8  2000              MOVS     r0,#0                 ;1423
0005ba  e645              B        |L1.584|
                  |L1.1468|
0005bc  f7fffffe          BL       prvIsQueueEmpty
0005c0  b1d8              CBZ      r0,|L1.1530|
0005c2  6820              LDR      r0,[r4,#0]            ;1382
0005c4  b930              CBNZ     r0,|L1.1492|
0005c6  f7fffffe          BL       vPortEnterCritical
0005ca  6860              LDR      r0,[r4,#4]            ;1386
0005cc  f7fffffe          BL       vTaskPriorityInherit
0005d0  f7fffffe          BL       vPortExitCritical
                  |L1.1492|
0005d4  f1040024          ADD      r0,r4,#0x24           ;1397
0005d8  9905              LDR      r1,[sp,#0x14]         ;1397
0005da  f7fffffe          BL       vTaskPlaceOnEventList
0005de  4620              MOV      r0,r4                 ;1398
0005e0  f7fffffe          BL       prvUnlockQueue
0005e4  f7fffffe          BL       xTaskResumeAll
0005e8  2800              CMP      r0,#0                 ;1399
0005ea  d18b              BNE      |L1.1284|
0005ec  f8c87000          STR      r7,[r8,#0]            ;1401
0005f0  f3bf8f4f          DSB                            ;1401
0005f4  f3bf8f6f          ISB                            ;1401
0005f8  e784              B        |L1.1284|
                  |L1.1530|
0005fa  4620              MOV      r0,r4                 ;1411
0005fc  f7fffffe          BL       prvUnlockQueue
000600  f7fffffe          BL       xTaskResumeAll
000604  e77e              B        |L1.1284|
;;;1432   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueReceiveFromISR PROC
;;;1433   
;;;1434   BaseType_t xQueueReceiveFromISR( QueueHandle_t xQueue, void * const pvBuffer, BaseType_t * const pxHigherPriorityTaskWoken )
000606  e92d47f0          PUSH     {r4-r10,lr}
;;;1435   {
00060a  4690              MOV      r8,r2
00060c  4689              MOV      r9,r1
00060e  0004              MOVS     r4,r0
000610  d107              BNE      |L1.1570|
;;;1436   BaseType_t xReturn;
;;;1437   UBaseType_t uxSavedInterruptStatus;
;;;1438   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1439   
;;;1440   	configASSERT( pxQueue );
000612  f44f62b4          MOV      r2,#0x5a0
000616  f2af212c          ADR      r1,|L1.1004|
00061a  f2af2014          ADR      r0,|L1.1032|
00061e  f7fffffe          BL       __2printf
                  |L1.1570|
;;;1441   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
000622  f1b90f00          CMP      r9,#0
000626  d109              BNE      |L1.1596|
000628  6c20              LDR      r0,[r4,#0x40]
00062a  b138              CBZ      r0,|L1.1596|
00062c  f24052a1          MOV      r2,#0x5a1
000630  f2af2148          ADR      r1,|L1.1004|
000634  f2af2030          ADR      r0,|L1.1032|
000638  f7fffffe          BL       __2printf
                  |L1.1596|
;;;1442   
;;;1443   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1444   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1445   	above the maximum system call priority are kept permanently enabled, even
;;;1446   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1447   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1448   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1449   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1450   	assigned a priority above the configured maximum system call priority.
;;;1451   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1452   	that have been assigned a priority at or (logically) below the maximum
;;;1453   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1454   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1455   	More information (albeit Cortex-M specific) is provided on the following
;;;1456   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1457   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
00063c  f7fffffe          BL       vPortValidateInterruptPriority
000640  2050              MOVS     r0,#0x50
000642  f3ef8711          MRS      r7,BASEPRI
000646  f3808811          MSR      BASEPRI,r0
00064a  f3bf8f4f          DSB      
00064e  f3bf8f6f          ISB      
;;;1458   
;;;1459   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1460   	{
;;;1461   		const UBaseType_t uxMessagesWaiting = pxQueue->uxMessagesWaiting;
000652  6ba6              LDR      r6,[r4,#0x38]
;;;1462   
;;;1463   		/* Cannot block in an ISR, so check there is data available. */
;;;1464   		if( uxMessagesWaiting > ( UBaseType_t ) 0 )
000654  b1f6              CBZ      r6,|L1.1684|
;;;1465   		{
;;;1466   			const int8_t cRxLock = pxQueue->cRxLock;
000656  f9945044          LDRSB    r5,[r4,#0x44]
;;;1467   
;;;1468   			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );
;;;1469   
;;;1470   			prvCopyDataFromQueue( pxQueue, pvBuffer );
00065a  4649              MOV      r1,r9
00065c  4620              MOV      r0,r4
00065e  f7fffffe          BL       prvCopyDataFromQueue
000662  1e76              SUBS     r6,r6,#1
;;;1471   			pxQueue->uxMessagesWaiting = uxMessagesWaiting - 1;
000664  63a6              STR      r6,[r4,#0x38]
;;;1472   
;;;1473   			/* If the queue is locked the event list will not be modified.
;;;1474   			Instead update the lock count so the task that unlocks the queue
;;;1475   			will know that an ISR has removed data while the queue was
;;;1476   			locked. */
;;;1477   			if( cRxLock == queueUNLOCKED )
000666  1c68              ADDS     r0,r5,#1
000668  d004              BEQ      |L1.1652|
00066a  1c6d              ADDS     r5,r5,#1
;;;1478   			{
;;;1479   				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
;;;1480   				{
;;;1481   					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
;;;1482   					{
;;;1483   						/* The task waiting has a higher priority than us so
;;;1484   						force a context switch. */
;;;1485   						if( pxHigherPriorityTaskWoken != NULL )
;;;1486   						{
;;;1487   							*pxHigherPriorityTaskWoken = pdTRUE;
;;;1488   						}
;;;1489   						else
;;;1490   						{
;;;1491   							mtCOVERAGE_TEST_MARKER();
;;;1492   						}
;;;1493   					}
;;;1494   					else
;;;1495   					{
;;;1496   						mtCOVERAGE_TEST_MARKER();
;;;1497   					}
;;;1498   				}
;;;1499   				else
;;;1500   				{
;;;1501   					mtCOVERAGE_TEST_MARKER();
;;;1502   				}
;;;1503   			}
;;;1504   			else
;;;1505   			{
;;;1506   				/* Increment the lock count so the task that unlocks the queue
;;;1507   				knows that data was removed while it was locked. */
;;;1508   				pxQueue->cRxLock = ( int8_t ) ( cRxLock + 1 );
00066c  f8845044          STRB     r5,[r4,#0x44]
                  |L1.1648|
;;;1509   			}
;;;1510   
;;;1511   			xReturn = pdPASS;
000670  2001              MOVS     r0,#1
;;;1512   		}
000672  e010              B        |L1.1686|
                  |L1.1652|
000674  6920              LDR      r0,[r4,#0x10]         ;1479
000676  2800              CMP      r0,#0                 ;1479
000678  d0fa              BEQ      |L1.1648|
00067a  f1040010          ADD      r0,r4,#0x10           ;1481
00067e  f7fffffe          BL       xTaskRemoveFromEventList
000682  2800              CMP      r0,#0                 ;1481
000684  d0f4              BEQ      |L1.1648|
000686  f1b80f00          CMP      r8,#0                 ;1485
00068a  d0f1              BEQ      |L1.1648|
00068c  2101              MOVS     r1,#1                 ;1487
00068e  f8c81000          STR      r1,[r8,#0]            ;1487
000692  e7ed              B        |L1.1648|
                  |L1.1684|
;;;1513   		else
;;;1514   		{
;;;1515   			xReturn = pdFAIL;
000694  2000              MOVS     r0,#0
                  |L1.1686|
000696  f3878811          MSR      BASEPRI,r7
;;;1516   			traceQUEUE_RECEIVE_FROM_ISR_FAILED( pxQueue );
;;;1517   		}
;;;1518   	}
;;;1519   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1520   
;;;1521   	return xReturn;
;;;1522   }
00069a  e66d              B        |L1.888|
;;;1523   /*-----------------------------------------------------------*/
                          ENDP

                  xQueuePeekFromISR PROC
;;;1524   
;;;1525   BaseType_t xQueuePeekFromISR( QueueHandle_t xQueue,  void * const pvBuffer )
00069c  e92d41f0          PUSH     {r4-r8,lr}
;;;1526   {
0006a0  460e              MOV      r6,r1
0006a2  0004              MOVS     r4,r0
0006a4  d107              BNE      |L1.1718|
;;;1527   BaseType_t xReturn;
;;;1528   UBaseType_t uxSavedInterruptStatus;
;;;1529   int8_t *pcOriginalReadPosition;
;;;1530   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1531   
;;;1532   	configASSERT( pxQueue );
0006a6  f24052fc          MOV      r2,#0x5fc
0006aa  f2af21c0          ADR      r1,|L1.1004|
0006ae  f2af20a8          ADR      r0,|L1.1032|
0006b2  f7fffffe          BL       __2printf
                  |L1.1718|
;;;1533   	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( UBaseType_t ) 0U ) ) );
0006b6  b94e              CBNZ     r6,|L1.1740|
0006b8  6c20              LDR      r0,[r4,#0x40]
0006ba  b148              CBZ      r0,|L1.1744|
0006bc  f24052fd          MOV      r2,#0x5fd
0006c0  f2af21d8          ADR      r1,|L1.1004|
0006c4  f2af20c0          ADR      r0,|L1.1032|
0006c8  f7fffffe          BL       __2printf
                  |L1.1740|
;;;1534   	configASSERT( pxQueue->uxItemSize != 0 ); /* Can't peek a semaphore. */
0006cc  6c20              LDR      r0,[r4,#0x40]
0006ce  b938              CBNZ     r0,|L1.1760|
                  |L1.1744|
0006d0  f24052fe          MOV      r2,#0x5fe
0006d4  f2af21ec          ADR      r1,|L1.1004|
0006d8  f2af20d4          ADR      r0,|L1.1032|
0006dc  f7fffffe          BL       __2printf
                  |L1.1760|
;;;1535   
;;;1536   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;1537   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;1538   	above the maximum system call priority are kept permanently enabled, even
;;;1539   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;1540   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;1541   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1542   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;1543   	assigned a priority above the configured maximum system call priority.
;;;1544   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;1545   	that have been assigned a priority at or (logically) below the maximum
;;;1546   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;1547   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;1548   	More information (albeit Cortex-M specific) is provided on the following
;;;1549   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1550   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
0006e0  f7fffffe          BL       vPortValidateInterruptPriority
0006e4  2050              MOVS     r0,#0x50
0006e6  f3ef8511          MRS      r5,BASEPRI
0006ea  f3808811          MSR      BASEPRI,r0
0006ee  f3bf8f4f          DSB      
0006f2  f3bf8f6f          ISB      
;;;1551   
;;;1552   	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1553   	{
;;;1554   		/* Cannot block in an ISR, so check there is data available. */
;;;1555   		if( pxQueue->uxMessagesWaiting > ( UBaseType_t ) 0 )
0006f6  6ba0              LDR      r0,[r4,#0x38]
0006f8  b130              CBZ      r0,|L1.1800|
;;;1556   		{
;;;1557   			traceQUEUE_PEEK_FROM_ISR( pxQueue );
;;;1558   
;;;1559   			/* Remember the read position so it can be reset as nothing is
;;;1560   			actually being removed from the queue. */
;;;1561   			pcOriginalReadPosition = pxQueue->u.pcReadFrom;
;;;1562   			prvCopyDataFromQueue( pxQueue, pvBuffer );
0006fa  4631              MOV      r1,r6
0006fc  4620              MOV      r0,r4
0006fe  68e7              LDR      r7,[r4,#0xc]
000700  f7fffffe          BL       prvCopyDataFromQueue
;;;1563   			pxQueue->u.pcReadFrom = pcOriginalReadPosition;
;;;1564   
;;;1565   			xReturn = pdPASS;
000704  2001              MOVS     r0,#1
000706  60e7              STR      r7,[r4,#0xc]
                  |L1.1800|
000708  f3858811          MSR      BASEPRI,r5
;;;1566   		}
;;;1567   		else
;;;1568   		{
;;;1569   			xReturn = pdFAIL;
;;;1570   			traceQUEUE_PEEK_FROM_ISR_FAILED( pxQueue );
;;;1571   		}
;;;1572   	}
;;;1573   	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1574   
;;;1575   	return xReturn;
;;;1576   }
00070c  e543              B        |L1.406|
;;;1577   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaiting PROC
;;;1578   
;;;1579   UBaseType_t uxQueueMessagesWaiting( const QueueHandle_t xQueue )
00070e  b510              PUSH     {r4,lr}
;;;1580   {
000710  0004              MOVS     r4,r0
000712  d107              BNE      |L1.1828|
;;;1581   UBaseType_t uxReturn;
;;;1582   
;;;1583   	configASSERT( xQueue );
000714  f240622f          MOV      r2,#0x62f
000718  f2af3130          ADR      r1,|L1.1004|
00071c  f2af3018          ADR      r0,|L1.1032|
000720  f7fffffe          BL       __2printf
                  |L1.1828|
;;;1584   
;;;1585   	taskENTER_CRITICAL();
000724  f7fffffe          BL       vPortEnterCritical
;;;1586   	{
;;;1587   		uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000728  6ba4              LDR      r4,[r4,#0x38]
;;;1588   	}
;;;1589   	taskEXIT_CRITICAL();
00072a  f7fffffe          BL       vPortExitCritical
;;;1590   
;;;1591   	return uxReturn;
00072e  4620              MOV      r0,r4
;;;1592   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000730  bd10              POP      {r4,pc}
;;;1593   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueSpacesAvailable PROC
;;;1594   
;;;1595   UBaseType_t uxQueueSpacesAvailable( const QueueHandle_t xQueue )
000732  b510              PUSH     {r4,lr}
;;;1596   {
000734  0004              MOVS     r4,r0
000736  d107              BNE      |L1.1864|
;;;1597   UBaseType_t uxReturn;
;;;1598   Queue_t *pxQueue;
;;;1599   
;;;1600   	pxQueue = ( Queue_t * ) xQueue;
;;;1601   	configASSERT( pxQueue );
000738  f2406241          MOV      r2,#0x641
00073c  f2af3154          ADR      r1,|L1.1004|
000740  f2af303c          ADR      r0,|L1.1032|
000744  f7fffffe          BL       __2printf
                  |L1.1864|
;;;1602   
;;;1603   	taskENTER_CRITICAL();
000748  f7fffffe          BL       vPortEnterCritical
;;;1604   	{
;;;1605   		uxReturn = pxQueue->uxLength - pxQueue->uxMessagesWaiting;
00074c  e9d4100e          LDRD     r1,r0,[r4,#0x38]
000750  1a44              SUBS     r4,r0,r1
;;;1606   	}
;;;1607   	taskEXIT_CRITICAL();
000752  f7fffffe          BL       vPortExitCritical
;;;1608   
;;;1609   	return uxReturn;
000756  4620              MOV      r0,r4
;;;1610   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000758  bd10              POP      {r4,pc}
;;;1611   /*-----------------------------------------------------------*/
                          ENDP

                  uxQueueMessagesWaitingFromISR PROC
;;;1612   
;;;1613   UBaseType_t uxQueueMessagesWaitingFromISR( const QueueHandle_t xQueue )
00075a  b510              PUSH     {r4,lr}
;;;1614   {
00075c  0004              MOVS     r4,r0
00075e  d107              BNE      |L1.1904|
;;;1615   UBaseType_t uxReturn;
;;;1616   
;;;1617   	configASSERT( xQueue );
000760  f2406251          MOV      r2,#0x651
000764  f2af317c          ADR      r1,|L1.1004|
000768  f2af3064          ADR      r0,|L1.1032|
00076c  f7fffffe          BL       __2printf
                  |L1.1904|
;;;1618   
;;;1619   	uxReturn = ( ( Queue_t * ) xQueue )->uxMessagesWaiting;
000770  6ba0              LDR      r0,[r4,#0x38]
;;;1620   
;;;1621   	return uxReturn;
;;;1622   } /*lint !e818 Pointer cannot be declared const as xQueue is a typedef not pointer. */
000772  bd10              POP      {r4,pc}
;;;1623   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueUnregisterQueue PROC
;;;2325   
;;;2326   	void vQueueUnregisterQueue( QueueHandle_t xQueue )
000774  4a3c              LDR      r2,|L1.2152|
;;;2327   	{
;;;2328   	UBaseType_t ux;
;;;2329   
;;;2330   		/* See if the handle of the queue being unregistered in actually in the
;;;2331   		registry. */
;;;2332   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
000776  2100              MOVS     r1,#0
                  |L1.1912|
;;;2333   		{
;;;2334   			if( xQueueRegistry[ ux ].xHandle == xQueue )
000778  eb0203c1          ADD      r3,r2,r1,LSL #3
00077c  685b              LDR      r3,[r3,#4]
00077e  4283              CMP      r3,r0
000780  d106              BNE      |L1.1936|
;;;2335   			{
;;;2336   				/* Set the name to NULL to show that this slot if free again. */
;;;2337   				xQueueRegistry[ ux ].pcQueueName = NULL;
000782  2000              MOVS     r0,#0
000784  f8420031          STR      r0,[r2,r1,LSL #3]
;;;2338   
;;;2339   				/* Set the handle to NULL to ensure the same queue handle cannot
;;;2340   				appear in the registry twice if it is added, removed, then
;;;2341   				added again. */
;;;2342   				xQueueRegistry[ ux ].xHandle = ( QueueHandle_t ) 0;
000788  eb0201c1          ADD      r1,r2,r1,LSL #3
;;;2343   				break;
00078c  6048              STR      r0,[r1,#4]
;;;2344   			}
;;;2345   			else
;;;2346   			{
;;;2347   				mtCOVERAGE_TEST_MARKER();
;;;2348   			}
;;;2349   		}
;;;2350   
;;;2351   	} /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
00078e  4770              BX       lr
                  |L1.1936|
000790  1c49              ADDS     r1,r1,#1
000792  290a              CMP      r1,#0xa               ;2332
000794  d3f0              BCC      |L1.1912|
000796  4770              BX       lr
;;;2352   
                          ENDP

                  vQueueDelete PROC
;;;1624   
;;;1625   void vQueueDelete( QueueHandle_t xQueue )
000798  b510              PUSH     {r4,lr}
;;;1626   {
00079a  0004              MOVS     r4,r0
00079c  d107              BNE      |L1.1966|
;;;1627   Queue_t * const pxQueue = ( Queue_t * ) xQueue;
;;;1628   
;;;1629   	configASSERT( pxQueue );
00079e  f240625d          MOV      r2,#0x65d
0007a2  f2af31b8          ADR      r1,|L1.1004|
0007a6  f2af30a0          ADR      r0,|L1.1032|
0007aa  f7fffffe          BL       __2printf
                  |L1.1966|
;;;1630   	traceQUEUE_DELETE( pxQueue );
;;;1631   
;;;1632   	#if ( configQUEUE_REGISTRY_SIZE > 0 )
;;;1633   	{
;;;1634   		vQueueUnregisterQueue( pxQueue );
0007ae  4620              MOV      r0,r4
0007b0  f7fffffe          BL       vQueueUnregisterQueue
;;;1635   	}
;;;1636   	#endif
;;;1637   
;;;1638   	#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) )
;;;1639   	{
;;;1640   		/* The queue can only have been allocated dynamically - free it
;;;1641   		again. */
;;;1642   		vPortFree( pxQueue );
0007b4  4620              MOV      r0,r4
0007b6  e8bd4010          POP      {r4,lr}
0007ba  f7ffbffe          B.W      vPortFree
;;;1643   	}
;;;1644   	#elif( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 1 ) )
;;;1645   	{
;;;1646   		/* The queue could have been allocated statically or dynamically, so
;;;1647   		check before attempting to free the memory. */
;;;1648   		if( pxQueue->ucStaticallyAllocated == ( uint8_t ) pdFALSE )
;;;1649   		{
;;;1650   			vPortFree( pxQueue );
;;;1651   		}
;;;1652   		else
;;;1653   		{
;;;1654   			mtCOVERAGE_TEST_MARKER();
;;;1655   		}
;;;1656   	}
;;;1657   	#else
;;;1658   	{
;;;1659   		/* The queue must have been statically allocated, so is not going to be
;;;1660   		deleted.  Avoid compiler warnings about the unused parameter. */
;;;1661   		( void ) pxQueue;
;;;1662   	}
;;;1663   	#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;1664   }
;;;1665   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueEmptyFromISR PROC
;;;1934   
;;;1935   BaseType_t xQueueIsQueueEmptyFromISR( const QueueHandle_t xQueue )
0007be  b510              PUSH     {r4,lr}
;;;1936   {
0007c0  0004              MOVS     r4,r0
0007c2  d107              BNE      |L1.2004|
;;;1937   BaseType_t xReturn;
;;;1938   
;;;1939   	configASSERT( xQueue );
0007c4  f2407293          MOV      r2,#0x793
0007c8  f2af31e0          ADR      r1,|L1.1004|
0007cc  f2af30c8          ADR      r0,|L1.1032|
0007d0  f7fffffe          BL       __2printf
                  |L1.2004|
;;;1940   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( UBaseType_t ) 0 )
0007d4  6ba0              LDR      r0,[r4,#0x38]
0007d6  b108              CBZ      r0,|L1.2012|
;;;1941   	{
;;;1942   		xReturn = pdTRUE;
;;;1943   	}
;;;1944   	else
;;;1945   	{
;;;1946   		xReturn = pdFALSE;
0007d8  2000              MOVS     r0,#0
;;;1947   	}
;;;1948   
;;;1949   	return xReturn;
;;;1950   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
0007da  bd10              POP      {r4,pc}
                  |L1.2012|
0007dc  2001              MOVS     r0,#1                 ;1942
0007de  bd10              POP      {r4,pc}
;;;1951   /*-----------------------------------------------------------*/
                          ENDP

                  xQueueIsQueueFullFromISR PROC
;;;1973   
;;;1974   BaseType_t xQueueIsQueueFullFromISR( const QueueHandle_t xQueue )
0007e0  b510              PUSH     {r4,lr}
;;;1975   {
0007e2  0004              MOVS     r4,r0
0007e4  d107              BNE      |L1.2038|
;;;1976   BaseType_t xReturn;
;;;1977   
;;;1978   	configASSERT( xQueue );
0007e6  f24072ba          MOV      r2,#0x7ba
0007ea  f2af4100          ADR      r1,|L1.1004|
0007ee  f2af30e8          ADR      r0,|L1.1032|
0007f2  f7fffffe          BL       __2printf
                  |L1.2038|
;;;1979   	if( ( ( Queue_t * ) xQueue )->uxMessagesWaiting == ( ( Queue_t * ) xQueue )->uxLength )
0007f6  6ba0              LDR      r0,[r4,#0x38]
0007f8  6be1              LDR      r1,[r4,#0x3c]
0007fa  4288              CMP      r0,r1
0007fc  d101              BNE      |L1.2050|
;;;1980   	{
;;;1981   		xReturn = pdTRUE;
0007fe  2001              MOVS     r0,#1
;;;1982   	}
;;;1983   	else
;;;1984   	{
;;;1985   		xReturn = pdFALSE;
;;;1986   	}
;;;1987   
;;;1988   	return xReturn;
;;;1989   } /*lint !e818 xQueue could not be pointer to const because it is a typedef. */
000800  bd10              POP      {r4,pc}
                  |L1.2050|
000802  2000              MOVS     r0,#0                 ;1985
000804  bd10              POP      {r4,pc}
;;;1990   /*-----------------------------------------------------------*/
                          ENDP

                  vQueueAddToRegistry PROC
;;;2268   
;;;2269   	void vQueueAddToRegistry( QueueHandle_t xQueue, const char *pcQueueName ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000806  b510              PUSH     {r4,lr}
;;;2270   	{
;;;2271   	UBaseType_t ux;
;;;2272   
;;;2273   		/* See if there is an empty space in the registry.  A NULL name denotes
;;;2274   		a free slot. */
;;;2275   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2276   		{
;;;2277   			if( xQueueRegistry[ ux ].pcQueueName == NULL )
000808  4b17              LDR      r3,|L1.2152|
00080a  2200              MOVS     r2,#0                 ;2275
                  |L1.2060|
00080c  f8534032          LDR      r4,[r3,r2,LSL #3]
000810  b11c              CBZ      r4,|L1.2074|
000812  1c52              ADDS     r2,r2,#1
000814  2a0a              CMP      r2,#0xa               ;2275
000816  d3f9              BCC      |L1.2060|
;;;2278   			{
;;;2279   				/* Store the information on this queue. */
;;;2280   				xQueueRegistry[ ux ].pcQueueName = pcQueueName;
;;;2281   				xQueueRegistry[ ux ].xHandle = xQueue;
;;;2282   
;;;2283   				traceQUEUE_REGISTRY_ADD( xQueue, pcQueueName );
;;;2284   				break;
;;;2285   			}
;;;2286   			else
;;;2287   			{
;;;2288   				mtCOVERAGE_TEST_MARKER();
;;;2289   			}
;;;2290   		}
;;;2291   	}
000818  bd10              POP      {r4,pc}
                  |L1.2074|
00081a  f8431032          STR      r1,[r3,r2,LSL #3]     ;2280
00081e  eb0301c2          ADD      r1,r3,r2,LSL #3       ;2281
000822  6048              STR      r0,[r1,#4]            ;2281
000824  bd10              POP      {r4,pc}
;;;2292   
                          ENDP

                  pcQueueGetName PROC
;;;2297   
;;;2298   	const char *pcQueueGetName( QueueHandle_t xQueue ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000826  b510              PUSH     {r4,lr}
;;;2299   	{
;;;2300   	UBaseType_t ux;
;;;2301   	const char *pcReturn = NULL; /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
000828  2400              MOVS     r4,#0
;;;2302   
;;;2303   		/* Note there is nothing here to protect against another task adding or
;;;2304   		removing entries from the registry while it is being searched. */
;;;2305   		for( ux = ( UBaseType_t ) 0U; ux < ( UBaseType_t ) configQUEUE_REGISTRY_SIZE; ux++ )
;;;2306   		{
;;;2307   			if( xQueueRegistry[ ux ].xHandle == xQueue )
00082a  4a0f              LDR      r2,|L1.2152|
00082c  4621              MOV      r1,r4                 ;2305
                  |L1.2094|
00082e  eb0203c1          ADD      r3,r2,r1,LSL #3
000832  685b              LDR      r3,[r3,#4]
000834  4283              CMP      r3,r0
000836  d102              BNE      |L1.2110|
;;;2308   			{
;;;2309   				pcReturn = xQueueRegistry[ ux ].pcQueueName;
000838  f8524031          LDR      r4,[r2,r1,LSL #3]
;;;2310   				break;
00083c  e002              B        |L1.2116|
                  |L1.2110|
00083e  1c49              ADDS     r1,r1,#1
000840  290a              CMP      r1,#0xa               ;2305
000842  d3f4              BCC      |L1.2094|
                  |L1.2116|
;;;2311   			}
;;;2312   			else
;;;2313   			{
;;;2314   				mtCOVERAGE_TEST_MARKER();
;;;2315   			}
;;;2316   		}
;;;2317   
;;;2318   		return pcReturn;
000844  4620              MOV      r0,r4
;;;2319   	}
000846  bd10              POP      {r4,pc}
;;;2320   
                          ENDP

                  prvIsQueueEmpty PROC
;;;1913   
;;;1914   static BaseType_t prvIsQueueEmpty( const Queue_t *pxQueue )
000848  b510              PUSH     {r4,lr}
;;;1915   {
00084a  4604              MOV      r4,r0
;;;1916   BaseType_t xReturn;
;;;1917   
;;;1918   	taskENTER_CRITICAL();
00084c  f7fffffe          BL       vPortEnterCritical
;;;1919   	{
;;;1920   		if( pxQueue->uxMessagesWaiting == ( UBaseType_t )  0 )
000850  6ba0              LDR      r0,[r4,#0x38]
000852  b120              CBZ      r0,|L1.2142|
;;;1921   		{
;;;1922   			xReturn = pdTRUE;
;;;1923   		}
;;;1924   		else
;;;1925   		{
;;;1926   			xReturn = pdFALSE;
000854  2400              MOVS     r4,#0
                  |L1.2134|
;;;1927   		}
;;;1928   	}
;;;1929   	taskEXIT_CRITICAL();
000856  f7fffffe          BL       vPortExitCritical
;;;1930   
;;;1931   	return xReturn;
00085a  4620              MOV      r0,r4
;;;1932   }
00085c  bd10              POP      {r4,pc}
                  |L1.2142|
00085e  2401              MOVS     r4,#1                 ;1922
000860  e7f9              B        |L1.2134|
;;;1933   /*-----------------------------------------------------------*/
                          ENDP

000862  0000              DCW      0x0000
                  |L1.2148|
                          DCD      0xe000ed04
                  |L1.2152|
                          DCD      ||.bss||

                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  xQueueRegistry
                          %        80
