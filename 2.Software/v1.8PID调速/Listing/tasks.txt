; generated by Component: ARM Compiler 5.05 update 1 (build 106) Tool: ArmCC [4d0efa]
; commandline ArmCC [--c99 --list --debug -c --asm --interleave -o..\..\output\tasks.o --asm_dir=..\..\Listing\ --list_dir=..\..\Listing\ --depend=..\..\output\tasks.d --cpu=Cortex-M3 --apcs=interwork --diag_suppress=9931 -I..\..\Libraries\CMSIS -I..\..\User -I..\..\Libraries\FWlib\inc -I..\..\User\led -I..\..\FreeRTOS\include -I..\..\FreeRTOS\port\RVDS\ARM_CM3 -I..\..\User\key -I..\..\User\uart -I..\..\Application -I..\..\BSP -I..\..\BSP\easylogger\inc -I..\..\BSP\easylogger\port -I..\..\BSP\easylogger\src -I..\..\BSP\eMPL -ID:\01-stm32单片机\04-当前项目\ROS小车\Project\Project\RTOS\v1.3TB6612电机驱动\Project\RVMDK（uv5）\RTE -ID:\00-Software\keil\ARM\PACK\Keil\STM32F1xx_DFP\1.0.5\Device\Include -ID:\00-Software\keil\ARM\CMSIS\Include -D__MICROLIB -D__UVISION_VERSION=514 -DSTM32F10X_HD -DSTM32F10X_HD -DUSE_STDPERIPH_DRIVER --omf_browse=..\..\output\tasks.crf ..\..\FreeRTOS\src\tasks.c]
                          THUMB

                          AREA ||.text||, CODE, READONLY, ALIGN=2

                          REQUIRE _printf_percent
                          REQUIRE _printf_d
                          REQUIRE _printf_s
                          REQUIRE _printf_int_dec
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                          REQUIRE _printf_str
                  prvAddNewTaskToReadyList PROC
;;;962    
;;;963    static void prvAddNewTaskToReadyList( TCB_t *pxNewTCB )
000000  e92d41f0          PUSH     {r4-r8,lr}
;;;964    {
000004  4605              MOV      r5,r0
;;;965    	/* Ensure interrupts don't access the task lists while the lists are being
;;;966    	updated. */
;;;967    	taskENTER_CRITICAL();
000006  f7fffffe          BL       vPortEnterCritical
;;;968    	{
;;;969    		uxCurrentNumberOfTasks++;
00000a  4efe              LDR      r6,|L1.1028|
00000c  68b0              LDR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
00000e  1c40              ADDS     r0,r0,#1
000010  60b0              STR      r0,[r6,#8]  ; uxCurrentNumberOfTasks
;;;970    		if( pxCurrentTCB == NULL )
000012  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000014  4ffc              LDR      r7,|L1.1032|
000016  b110              CBZ      r0,|L1.30|
;;;971    		{
;;;972    			/* There are no other tasks, or all the other tasks are in
;;;973    			the suspended state - make this the current task. */
;;;974    			pxCurrentTCB = pxNewTCB;
;;;975    
;;;976    			if( uxCurrentNumberOfTasks == ( UBaseType_t ) 1 )
;;;977    			{
;;;978    				/* This is the first task to be created so do the preliminary
;;;979    				initialisation required.  We will not recover if this call
;;;980    				fails, but we will report the failure. */
;;;981    				prvInitialiseTaskLists();
;;;982    			}
;;;983    			else
;;;984    			{
;;;985    				mtCOVERAGE_TEST_MARKER();
;;;986    			}
;;;987    		}
;;;988    		else
;;;989    		{
;;;990    			/* If the scheduler is not already running, make this task the
;;;991    			current task if it is the highest priority task to be created
;;;992    			so far. */
;;;993    			if( xSchedulerRunning == pdFALSE )
000018  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
00001a  b330              CBZ      r0,|L1.106|
00001c  e02b              B        |L1.118|
                  |L1.30|
00001e  6035              STR      r5,[r6,#0]            ;974  ; pxCurrentTCB
000020  68b0              LDR      r0,[r6,#8]            ;976  ; uxCurrentNumberOfTasks
000022  2801              CMP      r0,#1                 ;976
000024  d127              BNE      |L1.118|
000026  2400              MOVS     r4,#0                 ;976
                  |L1.40|
000028  eb040084          ADD      r0,r4,r4,LSL #2       ;976
00002c  eb070080          ADD      r0,r7,r0,LSL #2       ;976
000030  f7fffffe          BL       vListInitialise
000034  1c64              ADDS     r4,r4,#1              ;976
000036  2c20              CMP      r4,#0x20              ;976
000038  d3f6              BCC      |L1.40|
00003a  48f4              LDR      r0,|L1.1036|
00003c  f7fffffe          BL       vListInitialise
000040  48f2              LDR      r0,|L1.1036|
000042  3014              ADDS     r0,r0,#0x14           ;976
000044  f7fffffe          BL       vListInitialise
000048  48f0              LDR      r0,|L1.1036|
00004a  3028              ADDS     r0,r0,#0x28           ;976
00004c  f7fffffe          BL       vListInitialise
000050  48ee              LDR      r0,|L1.1036|
000052  303c              ADDS     r0,r0,#0x3c           ;976
000054  f7fffffe          BL       vListInitialise
000058  48ec              LDR      r0,|L1.1036|
00005a  3050              ADDS     r0,r0,#0x50           ;976
00005c  f7fffffe          BL       vListInitialise
000060  48ea              LDR      r0,|L1.1036|
000062  6370              STR      r0,[r6,#0x34]         ;976  ; pxDelayedTaskList
000064  3014              ADDS     r0,r0,#0x14           ;976
000066  63b0              STR      r0,[r6,#0x38]         ;976  ; pxOverflowDelayedTaskList
000068  e005              B        |L1.118|
                  |L1.106|
;;;994    			{
;;;995    				if( pxCurrentTCB->uxPriority <= pxNewTCB->uxPriority )
00006a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00006c  6ae9              LDR      r1,[r5,#0x2c]
00006e  6ac0              LDR      r0,[r0,#0x2c]
000070  4288              CMP      r0,r1
000072  d800              BHI      |L1.118|
;;;996    				{
;;;997    					pxCurrentTCB = pxNewTCB;
000074  6035              STR      r5,[r6,#0]  ; pxCurrentTCB
                  |L1.118|
;;;998    				}
;;;999    				else
;;;1000   				{
;;;1001   					mtCOVERAGE_TEST_MARKER();
;;;1002   				}
;;;1003   			}
;;;1004   			else
;;;1005   			{
;;;1006   				mtCOVERAGE_TEST_MARKER();
;;;1007   			}
;;;1008   		}
;;;1009   
;;;1010   		uxTaskNumber++;
000076  6a70              LDR      r0,[r6,#0x24]  ; uxTaskNumber
;;;1011   
;;;1012   		#if ( configUSE_TRACE_FACILITY == 1 )
;;;1013   		{
;;;1014   			/* Add a counter into the TCB for tracing only. */
;;;1015   			pxNewTCB->uxTCBNumber = uxTaskNumber;
;;;1016   		}
;;;1017   		#endif /* configUSE_TRACE_FACILITY */
;;;1018   		traceTASK_CREATE( pxNewTCB );
;;;1019   
;;;1020   		prvAddTaskToReadyList( pxNewTCB );
000078  2101              MOVS     r1,#1
00007a  1c40              ADDS     r0,r0,#1              ;1010
00007c  6270              STR      r0,[r6,#0x24]  ; uxTaskNumber
00007e  6ae8              LDR      r0,[r5,#0x2c]
000080  6932              LDR      r2,[r6,#0x10]  ; uxTopReadyPriority
000082  4081              LSLS     r1,r1,r0
000084  4311              ORRS     r1,r1,r2
000086  6131              STR      r1,[r6,#0x10]  ; uxTopReadyPriority
000088  eb000080          ADD      r0,r0,r0,LSL #2
00008c  eb070080          ADD      r0,r7,r0,LSL #2
000090  1d29              ADDS     r1,r5,#4
000092  f7fffffe          BL       vListInsertEnd
;;;1021   
;;;1022   		portSETUP_TCB( pxNewTCB );
;;;1023   	}
;;;1024   	taskEXIT_CRITICAL();
000096  f7fffffe          BL       vPortExitCritical
;;;1025   
;;;1026   	if( xSchedulerRunning != pdFALSE )
00009a  6970              LDR      r0,[r6,#0x14]  ; xSchedulerRunning
00009c  2800              CMP      r0,#0
00009e  d00c              BEQ      |L1.186|
;;;1027   	{
;;;1028   		/* If the created task is of a higher priority than the current task
;;;1029   		then it should run now. */
;;;1030   		if( pxCurrentTCB->uxPriority < pxNewTCB->uxPriority )
0000a0  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
0000a2  6ae9              LDR      r1,[r5,#0x2c]
0000a4  6ac0              LDR      r0,[r0,#0x2c]
0000a6  4288              CMP      r0,r1
0000a8  d207              BCS      |L1.186|
;;;1031   		{
;;;1032   			taskYIELD_IF_USING_PREEMPTION();
0000aa  49d9              LDR      r1,|L1.1040|
0000ac  f04f5080          MOV      r0,#0x10000000
0000b0  6008              STR      r0,[r1,#0]
0000b2  f3bf8f4f          DSB      
0000b6  f3bf8f6f          ISB      
                  |L1.186|
;;;1033   		}
;;;1034   		else
;;;1035   		{
;;;1036   			mtCOVERAGE_TEST_MARKER();
;;;1037   		}
;;;1038   	}
;;;1039   	else
;;;1040   	{
;;;1041   		mtCOVERAGE_TEST_MARKER();
;;;1042   	}
;;;1043   }
0000ba  e8bd81f0          POP      {r4-r8,pc}
;;;1044   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCreate PROC
;;;675    
;;;676    	BaseType_t xTaskCreate(	TaskFunction_t pxTaskCode,
0000be  e92d5fff          PUSH     {r0-r12,lr}
;;;677    							const char * const pcName,
;;;678    							const uint16_t usStackDepth,
;;;679    							void * const pvParameters,
;;;680    							UBaseType_t uxPriority,
;;;681    							TaskHandle_t * const pxCreatedTask ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;682    	{
0000c2  4683              MOV      r11,r0
0000c4  e9dd870e          LDRD     r8,r7,[sp,#0x38]
0000c8  4699              MOV      r9,r3
0000ca  4616              MOV      r6,r2
0000cc  468a              MOV      r10,r1
;;;683    	TCB_t *pxNewTCB;
;;;684    	BaseType_t xReturn;
;;;685    
;;;686    		/* If the stack grows down then allocate the stack then the TCB so the stack
;;;687    		does not grow into the TCB.  Likewise if the stack grows up then allocate
;;;688    		the TCB then the stack. */
;;;689    		#if( portSTACK_GROWTH > 0 )
;;;690    		{
;;;691    			/* Allocate space for the TCB.  Where the memory comes from depends on
;;;692    			the implementation of the port malloc function and whether or not static
;;;693    			allocation is being used. */
;;;694    			pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) );
;;;695    
;;;696    			if( pxNewTCB != NULL )
;;;697    			{
;;;698    				/* Allocate space for the stack used by the task being created.
;;;699    				The base of the stack memory stored in the TCB so the task can
;;;700    				be deleted later if required. */
;;;701    				pxNewTCB->pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;702    
;;;703    				if( pxNewTCB->pxStack == NULL )
;;;704    				{
;;;705    					/* Could not allocate the stack.  Delete the allocated TCB. */
;;;706    					vPortFree( pxNewTCB );
;;;707    					pxNewTCB = NULL;
;;;708    				}
;;;709    			}
;;;710    		}
;;;711    		#else /* portSTACK_GROWTH */
;;;712    		{
;;;713    		StackType_t *pxStack;
;;;714    
;;;715    			/* Allocate space for the stack used by the task being created. */
;;;716    			pxStack = ( StackType_t * ) pvPortMalloc( ( ( ( size_t ) usStackDepth ) * sizeof( StackType_t ) ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
0000ce  0090              LSLS     r0,r2,#2
0000d0  f7fffffe          BL       pvPortMalloc
0000d4  0005              MOVS     r5,r0
;;;717    
;;;718    			if( pxStack != NULL )
0000d6  d01a              BEQ      |L1.270|
;;;719    			{
;;;720    				/* Allocate space for the TCB. */
;;;721    				pxNewTCB = ( TCB_t * ) pvPortMalloc( sizeof( TCB_t ) ); /*lint !e961 MISRA exception as the casts are only redundant for some paths. */
0000d8  2054              MOVS     r0,#0x54
0000da  f7fffffe          BL       pvPortMalloc
0000de  0004              MOVS     r4,r0
;;;722    
;;;723    				if( pxNewTCB != NULL )
0000e0  d012              BEQ      |L1.264|
;;;724    				{
;;;725    					/* Store the stack location in the TCB. */
;;;726    					pxNewTCB->pxStack = pxStack;
;;;727    				}
;;;728    				else
;;;729    				{
;;;730    					/* The stack cannot be used as the TCB was not created.  Free
;;;731    					it again. */
;;;732    					vPortFree( pxStack );
;;;733    				}
;;;734    			}
;;;735    			else
;;;736    			{
;;;737    				pxNewTCB = NULL;
;;;738    			}
;;;739    		}
;;;740    		#endif /* portSTACK_GROWTH */
;;;741    
;;;742    		if( pxNewTCB != NULL )
;;;743    		{
;;;744    			#if( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE != 0 )
;;;745    			{
;;;746    				/* Tasks can be created statically or dynamically, so note this
;;;747    				task was created dynamically in case it is later deleted. */
;;;748    				pxNewTCB->ucStaticallyAllocated = tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB;
;;;749    			}
;;;750    			#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;751    
;;;752    			prvInitialiseNewTask( pxTaskCode, pcName, ( uint32_t ) usStackDepth, pvParameters, uxPriority, pxCreatedTask, pxNewTCB, NULL );
0000e2  6325              STR      r5,[r4,#0x30]
0000e4  2100              MOVS     r1,#0
0000e6  e9cd4102          STRD     r4,r1,[sp,#8]
0000ea  e9cd8700          STRD     r8,r7,[sp,#0]
0000ee  464b              MOV      r3,r9
0000f0  4632              MOV      r2,r6
0000f2  4651              MOV      r1,r10
0000f4  4658              MOV      r0,r11
0000f6  f7fffffe          BL       prvInitialiseNewTask
;;;753    			prvAddNewTaskToReadyList( pxNewTCB );
0000fa  4620              MOV      r0,r4
0000fc  f7fffffe          BL       prvAddNewTaskToReadyList
;;;754    			xReturn = pdPASS;
000100  2001              MOVS     r0,#1
                  |L1.258|
;;;755    		}
;;;756    		else
;;;757    		{
;;;758    			xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
;;;759    		}
;;;760    
;;;761    		return xReturn;
;;;762    	}
000102  b004              ADD      sp,sp,#0x10
000104  e8bd9ff0          POP      {r4-r12,pc}
                  |L1.264|
000108  4628              MOV      r0,r5                 ;732
00010a  f7fffffe          BL       vPortFree
                  |L1.270|
00010e  f04f30ff          MOV      r0,#0xffffffff        ;758
000112  e7f6              B        |L1.258|
;;;763    
                          ENDP

                  vTaskDelete PROC
;;;1047   
;;;1048   	void vTaskDelete( TaskHandle_t xTaskToDelete )
000114  b570              PUSH     {r4-r6,lr}
;;;1049   	{
000116  4604              MOV      r4,r0
;;;1050   	TCB_t *pxTCB;
;;;1051   
;;;1052   		taskENTER_CRITICAL();
000118  f7fffffe          BL       vPortEnterCritical
;;;1053   		{
;;;1054   			/* If null is passed in here then it is the calling task that is
;;;1055   			being deleted. */
;;;1056   			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
00011c  4db9              LDR      r5,|L1.1028|
00011e  b904              CBNZ     r4,|L1.290|
000120  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.290|
;;;1057   
;;;1058   			/* Remove task from the ready list. */
;;;1059   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000122  1d20              ADDS     r0,r4,#4
000124  f7fffffe          BL       uxListRemove
000128  b958              CBNZ     r0,|L1.322|
;;;1060   			{
;;;1061   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00012a  6ae0              LDR      r0,[r4,#0x2c]
00012c  4ab6              LDR      r2,|L1.1032|
00012e  eb000180          ADD      r1,r0,r0,LSL #2
000132  f8521021          LDR      r1,[r2,r1,LSL #2]
000136  b921              CBNZ     r1,|L1.322|
000138  2101              MOVS     r1,#1
00013a  4081              LSLS     r1,r1,r0
00013c  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
00013e  4388              BICS     r0,r0,r1
000140  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.322|
;;;1062   			}
;;;1063   			else
;;;1064   			{
;;;1065   				mtCOVERAGE_TEST_MARKER();
;;;1066   			}
;;;1067   
;;;1068   			/* Is the task waiting on an event also? */
;;;1069   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000142  6aa0              LDR      r0,[r4,#0x28]
000144  b118              CBZ      r0,|L1.334|
;;;1070   			{
;;;1071   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000146  f1040018          ADD      r0,r4,#0x18
00014a  f7fffffe          BL       uxListRemove
                  |L1.334|
;;;1072   			}
;;;1073   			else
;;;1074   			{
;;;1075   				mtCOVERAGE_TEST_MARKER();
;;;1076   			}
;;;1077   
;;;1078   			/* Increment the uxTaskNumber also so kernel aware debuggers can
;;;1079   			detect that the task lists need re-generating.  This is done before
;;;1080   			portPRE_TASK_DELETE_HOOK() as in the Windows port that macro will
;;;1081   			not return. */
;;;1082   			uxTaskNumber++;
00014e  6a68              LDR      r0,[r5,#0x24]  ; uxTaskNumber
000150  1c40              ADDS     r0,r0,#1
;;;1083   
;;;1084   			if( pxTCB == pxCurrentTCB )
000152  6268              STR      r0,[r5,#0x24]  ; uxTaskNumber
000154  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000156  4284              CMP      r4,r0
000158  d108              BNE      |L1.364|
;;;1085   			{
;;;1086   				/* A task is deleting itself.  This cannot complete within the
;;;1087   				task itself, as a context switch to another task is required.
;;;1088   				Place the task in the termination list.  The idle task will
;;;1089   				check the termination list and free up any memory allocated by
;;;1090   				the scheduler for the TCB and stack of the deleted task. */
;;;1091   				vListInsertEnd( &xTasksWaitingTermination, &( pxTCB->xStateListItem ) );
00015a  48ac              LDR      r0,|L1.1036|
00015c  1d21              ADDS     r1,r4,#4
00015e  303c              ADDS     r0,r0,#0x3c
000160  f7fffffe          BL       vListInsertEnd
;;;1092   
;;;1093   				/* Increment the ucTasksDeleted variable so the idle task knows
;;;1094   				there is a task that has been deleted and that it should therefore
;;;1095   				check the xTasksWaitingTermination list. */
;;;1096   				++uxDeletedTasksWaitingCleanUp;
000164  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
000166  1c40              ADDS     r0,r0,#1
000168  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00016a  e007              B        |L1.380|
                  |L1.364|
;;;1097   
;;;1098   				/* The pre-delete hook is primarily for the Windows simulator,
;;;1099   				in which Windows specific clean up operations are performed,
;;;1100   				after which it is not possible to yield away from this task -
;;;1101   				hence xYieldPending is used to latch that a context switch is
;;;1102   				required. */
;;;1103   				portPRE_TASK_DELETE_HOOK( pxTCB, &xYieldPending );
;;;1104   			}
;;;1105   			else
;;;1106   			{
;;;1107   				--uxCurrentNumberOfTasks;
00016c  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
00016e  1e40              SUBS     r0,r0,#1
000170  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;1108   				prvDeleteTCB( pxTCB );
000172  4620              MOV      r0,r4
000174  f7fffffe          BL       prvDeleteTCB
;;;1109   
;;;1110   				/* Reset the next expected unblock time in case it referred to
;;;1111   				the task that has just been deleted. */
;;;1112   				prvResetNextTaskUnblockTime();
000178  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L1.380|
;;;1113   			}
;;;1114   
;;;1115   			traceTASK_DELETE( pxTCB );
;;;1116   		}
;;;1117   		taskEXIT_CRITICAL();
00017c  f7fffffe          BL       vPortExitCritical
;;;1118   
;;;1119   		/* Force a reschedule if it is the currently running task that has just
;;;1120   		been deleted. */
;;;1121   		if( xSchedulerRunning != pdFALSE )
000180  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000182  2800              CMP      r0,#0
000184  d012              BEQ      |L1.428|
;;;1122   		{
;;;1123   			if( pxTCB == pxCurrentTCB )
000186  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000188  4284              CMP      r4,r0
00018a  d10f              BNE      |L1.428|
;;;1124   			{
;;;1125   				configASSERT( uxSchedulerSuspended == 0 );
00018c  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00018e  b128              CBZ      r0,|L1.412|
000190  f2404265          MOV      r2,#0x465
000194  a19f              ADR      r1,|L1.1044|
000196  a0a6              ADR      r0,|L1.1072|
000198  f7fffffe          BL       __2printf
                  |L1.412|
;;;1126   				portYIELD_WITHIN_API();
00019c  499c              LDR      r1,|L1.1040|
00019e  f04f5080          MOV      r0,#0x10000000
0001a2  6008              STR      r0,[r1,#0]
0001a4  f3bf8f4f          DSB      
0001a8  f3bf8f6f          ISB      
                  |L1.428|
;;;1127   			}
;;;1128   			else
;;;1129   			{
;;;1130   				mtCOVERAGE_TEST_MARKER();
;;;1131   			}
;;;1132   		}
;;;1133   	}
0001ac  bd70              POP      {r4-r6,pc}
;;;1134   
                          ENDP

                  xTaskIncrementTick PROC
;;;2498   
;;;2499   BaseType_t xTaskIncrementTick( void )
0001ae  e92d41f0          PUSH     {r4-r8,lr}
;;;2500   {
;;;2501   TCB_t * pxTCB;
;;;2502   TickType_t xItemValue;
;;;2503   BaseType_t xSwitchRequired = pdFALSE;
;;;2504   
;;;2505   	/* Called by the portable layer each time a tick interrupt occurs.
;;;2506   	Increments the tick then checks to see if the new tick value will cause any
;;;2507   	tasks to be unblocked. */
;;;2508   	traceTASK_INCREMENT_TICK( xTickCount );
;;;2509   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0001b2  4f94              LDR      r7,|L1.1028|
0001b4  2600              MOVS     r6,#0                 ;2503
0001b6  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
0001b8  b138              CBZ      r0,|L1.458|
;;;2510   	{
;;;2511   		/* Minor optimisation.  The tick count cannot change in this
;;;2512   		block. */
;;;2513   		const TickType_t xConstTickCount = xTickCount + 1;
;;;2514   
;;;2515   		/* Increment the RTOS tick, switching the delayed and overflowed
;;;2516   		delayed lists if it wraps to 0. */
;;;2517   		xTickCount = xConstTickCount;
;;;2518   
;;;2519   		if( xConstTickCount == ( TickType_t ) 0U )
;;;2520   		{
;;;2521   			taskSWITCH_DELAYED_LISTS();
;;;2522   		}
;;;2523   		else
;;;2524   		{
;;;2525   			mtCOVERAGE_TEST_MARKER();
;;;2526   		}
;;;2527   
;;;2528   		/* See if this tick has made a timeout expire.  Tasks are stored in
;;;2529   		the	queue in the order of their wake time - meaning once one task
;;;2530   		has been found whose block time has not expired there is no need to
;;;2531   		look any further down the list. */
;;;2532   		if( xConstTickCount >= xNextTaskUnblockTime )
;;;2533   		{
;;;2534   			for( ;; )
;;;2535   			{
;;;2536   				if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
;;;2537   				{
;;;2538   					/* The delayed list is empty.  Set xNextTaskUnblockTime
;;;2539   					to the maximum possible value so it is extremely
;;;2540   					unlikely that the
;;;2541   					if( xTickCount >= xNextTaskUnblockTime ) test will pass
;;;2542   					next time through. */
;;;2543   					xNextTaskUnblockTime = portMAX_DELAY; /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
;;;2544   					break;
;;;2545   				}
;;;2546   				else
;;;2547   				{
;;;2548   					/* The delayed list is not empty, get the value of the
;;;2549   					item at the head of the delayed list.  This is the time
;;;2550   					at which the task at the head of the delayed list must
;;;2551   					be removed from the Blocked state. */
;;;2552   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
;;;2553   					xItemValue = listGET_LIST_ITEM_VALUE( &( pxTCB->xStateListItem ) );
;;;2554   
;;;2555   					if( xConstTickCount < xItemValue )
;;;2556   					{
;;;2557   						/* It is not time to unblock this item yet, but the
;;;2558   						item value is the time at which the task at the head
;;;2559   						of the blocked list must be removed from the Blocked
;;;2560   						state -	so record the item value in
;;;2561   						xNextTaskUnblockTime. */
;;;2562   						xNextTaskUnblockTime = xItemValue;
;;;2563   						break;
;;;2564   					}
;;;2565   					else
;;;2566   					{
;;;2567   						mtCOVERAGE_TEST_MARKER();
;;;2568   					}
;;;2569   
;;;2570   					/* It is time to remove the item from the Blocked state. */
;;;2571   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2572   
;;;2573   					/* Is the task waiting on an event also?  If so remove
;;;2574   					it from the event list. */
;;;2575   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
;;;2576   					{
;;;2577   						( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2578   					}
;;;2579   					else
;;;2580   					{
;;;2581   						mtCOVERAGE_TEST_MARKER();
;;;2582   					}
;;;2583   
;;;2584   					/* Place the unblocked task into the appropriate ready
;;;2585   					list. */
;;;2586   					prvAddTaskToReadyList( pxTCB );
;;;2587   
;;;2588   					/* A task being unblocked cannot cause an immediate
;;;2589   					context switch if preemption is turned off. */
;;;2590   					#if (  configUSE_PREEMPTION == 1 )
;;;2591   					{
;;;2592   						/* Preemption is on, but a context switch should
;;;2593   						only be performed if the unblocked task has a
;;;2594   						priority that is equal to or higher than the
;;;2595   						currently executing task. */
;;;2596   						if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;2597   						{
;;;2598   							xSwitchRequired = pdTRUE;
;;;2599   						}
;;;2600   						else
;;;2601   						{
;;;2602   							mtCOVERAGE_TEST_MARKER();
;;;2603   						}
;;;2604   					}
;;;2605   					#endif /* configUSE_PREEMPTION */
;;;2606   				}
;;;2607   			}
;;;2608   		}
;;;2609   
;;;2610   		/* Tasks of equal priority to the currently running task will share
;;;2611   		processing time (time slice) if preemption is on, and the application
;;;2612   		writer has not explicitly turned time slicing off. */
;;;2613   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) )
;;;2614   		{
;;;2615   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ pxCurrentTCB->uxPriority ] ) ) > ( UBaseType_t ) 1 )
;;;2616   			{
;;;2617   				xSwitchRequired = pdTRUE;
;;;2618   			}
;;;2619   			else
;;;2620   			{
;;;2621   				mtCOVERAGE_TEST_MARKER();
;;;2622   			}
;;;2623   		}
;;;2624   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configUSE_TIME_SLICING == 1 ) ) */
;;;2625   
;;;2626   		#if ( configUSE_TICK_HOOK == 1 )
;;;2627   		{
;;;2628   			/* Guard against the tick hook being called when the pended tick
;;;2629   			count is being unwound (when the scheduler is being unlocked). */
;;;2630   			if( uxPendedTicks == ( UBaseType_t ) 0U )
;;;2631   			{
;;;2632   				vApplicationTickHook();
;;;2633   			}
;;;2634   			else
;;;2635   			{
;;;2636   				mtCOVERAGE_TEST_MARKER();
;;;2637   			}
;;;2638   		}
;;;2639   		#endif /* configUSE_TICK_HOOK */
;;;2640   	}
;;;2641   	else
;;;2642   	{
;;;2643   		++uxPendedTicks;
0001ba  69b8              LDR      r0,[r7,#0x18]  ; uxPendedTicks
0001bc  1c40              ADDS     r0,r0,#1
0001be  61b8              STR      r0,[r7,#0x18]  ; uxPendedTicks
                  |L1.448|
;;;2644   
;;;2645   		/* The tick hook gets called at regular intervals, even if the
;;;2646   		scheduler is locked. */
;;;2647   		#if ( configUSE_TICK_HOOK == 1 )
;;;2648   		{
;;;2649   			vApplicationTickHook();
;;;2650   		}
;;;2651   		#endif
;;;2652   	}
;;;2653   
;;;2654   	#if ( configUSE_PREEMPTION == 1 )
;;;2655   	{
;;;2656   		if( xYieldPending != pdFALSE )
0001c0  69f8              LDR      r0,[r7,#0x1c]  ; xYieldPending
0001c2  b100              CBZ      r0,|L1.454|
;;;2657   		{
;;;2658   			xSwitchRequired = pdTRUE;
0001c4  2601              MOVS     r6,#1
                  |L1.454|
;;;2659   		}
;;;2660   		else
;;;2661   		{
;;;2662   			mtCOVERAGE_TEST_MARKER();
;;;2663   		}
;;;2664   	}
;;;2665   	#endif /* configUSE_PREEMPTION */
;;;2666   
;;;2667   	return xSwitchRequired;
0001c6  4630              MOV      r0,r6
                  |L1.456|
;;;2668   }
0001c8  e777              B        |L1.186|
                  |L1.458|
0001ca  68fd              LDR      r5,[r7,#0xc]          ;2513  ; xTickCount
0001cc  1c6d              ADDS     r5,r5,#1              ;2513
0001ce  60fd              STR      r5,[r7,#0xc]          ;2517  ; xTickCount
0001d0  d111              BNE      |L1.502|
0001d2  6b78              LDR      r0,[r7,#0x34]         ;2521  ; pxDelayedTaskList
0001d4  6800              LDR      r0,[r0,#0]            ;2521
0001d6  b128              CBZ      r0,|L1.484|
0001d8  f64012d9          MOV      r2,#0x9d9             ;2521
0001dc  a18d              ADR      r1,|L1.1044|
0001de  a094              ADR      r0,|L1.1072|
0001e0  f7fffffe          BL       __2printf
                  |L1.484|
0001e4  6b78              LDR      r0,[r7,#0x34]         ;2521  ; pxDelayedTaskList
0001e6  6bb9              LDR      r1,[r7,#0x38]         ;2521  ; pxOverflowDelayedTaskList
0001e8  6379              STR      r1,[r7,#0x34]         ;2521  ; pxDelayedTaskList
0001ea  63b8              STR      r0,[r7,#0x38]         ;2521  ; pxOverflowDelayedTaskList
0001ec  6a38              LDR      r0,[r7,#0x20]         ;2521  ; xNumOfOverflows
0001ee  1c40              ADDS     r0,r0,#1              ;2521
0001f0  6238              STR      r0,[r7,#0x20]         ;2521  ; xNumOfOverflows
0001f2  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L1.502|
0001f6  6ab8              LDR      r0,[r7,#0x28]         ;2532  ; xNextTaskUnblockTime
0001f8  f8df820c          LDR      r8,|L1.1032|
0001fc  4285              CMP      r5,r0                 ;2532
0001fe  d309              BCC      |L1.532|
                  |L1.512|
000200  6b78              LDR      r0,[r7,#0x34]         ;2536  ; pxDelayedTaskList
000202  6800              LDR      r0,[r0,#0]            ;2536
000204  b180              CBZ      r0,|L1.552|
000206  6b78              LDR      r0,[r7,#0x34]         ;2552  ; pxDelayedTaskList
000208  68c0              LDR      r0,[r0,#0xc]          ;2552
00020a  68c4              LDR      r4,[r0,#0xc]          ;2553
00020c  6860              LDR      r0,[r4,#4]            ;2555
00020e  4285              CMP      r5,r0                 ;2555
000210  d20d              BCS      |L1.558|
                  |L1.530|
000212  62b8              STR      r0,[r7,#0x28]         ;2562  ; xNextTaskUnblockTime
                  |L1.532|
000214  6838              LDR      r0,[r7,#0]            ;2615  ; pxCurrentTCB
000216  6ac0              LDR      r0,[r0,#0x2c]         ;2615
000218  eb000180          ADD      r1,r0,r0,LSL #2       ;2615
00021c  f8580021          LDR      r0,[r8,r1,LSL #2]     ;2615
000220  2801              CMP      r0,#1                 ;2615
000222  d9cd              BLS      |L1.448|
000224  2601              MOVS     r6,#1                 ;2617
000226  e7cb              B        |L1.448|
                  |L1.552|
000228  f04f30ff          MOV      r0,#0xffffffff        ;2543
00022c  e7f1              B        |L1.530|
                  |L1.558|
00022e  1d20              ADDS     r0,r4,#4              ;2571
000230  f7fffffe          BL       uxListRemove
000234  6aa0              LDR      r0,[r4,#0x28]         ;2575
000236  b118              CBZ      r0,|L1.576|
000238  f1040018          ADD      r0,r4,#0x18           ;2577
00023c  f7fffffe          BL       uxListRemove
                  |L1.576|
000240  6ae0              LDR      r0,[r4,#0x2c]         ;2586
000242  2101              MOVS     r1,#1                 ;2586
000244  693a              LDR      r2,[r7,#0x10]         ;2586  ; uxTopReadyPriority
000246  4081              LSLS     r1,r1,r0              ;2586
000248  4311              ORRS     r1,r1,r2              ;2586
00024a  6139              STR      r1,[r7,#0x10]         ;2586  ; uxTopReadyPriority
00024c  eb000180          ADD      r1,r0,r0,LSL #2       ;2586
000250  eb080081          ADD      r0,r8,r1,LSL #2       ;2586
000254  1d21              ADDS     r1,r4,#4              ;2586
000256  f7fffffe          BL       vListInsertEnd
00025a  6ae0              LDR      r0,[r4,#0x2c]         ;2596
00025c  6839              LDR      r1,[r7,#0]            ;2596  ; pxCurrentTCB
00025e  6ac9              LDR      r1,[r1,#0x2c]         ;2596
000260  4288              CMP      r0,r1                 ;2596
000262  d3cd              BCC      |L1.512|
000264  2601              MOVS     r6,#1                 ;2598
000266  e7cb              B        |L1.512|
;;;2669   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskResumeAll PROC
;;;2016   
;;;2017   BaseType_t xTaskResumeAll( void )
000268  e92d47f0          PUSH     {r4-r10,lr}
;;;2018   {
;;;2019   TCB_t *pxTCB = NULL;
;;;2020   BaseType_t xAlreadyYielded = pdFALSE;
;;;2021   
;;;2022   	/* If uxSchedulerSuspended is zero then this function does not match a
;;;2023   	previous call to vTaskSuspendAll(). */
;;;2024   	configASSERT( uxSchedulerSuspended );
00026c  4d65              LDR      r5,|L1.1028|
00026e  2400              MOVS     r4,#0                 ;2019
000270  4627              MOV      r7,r4                 ;2020
000272  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000274  b928              CBNZ     r0,|L1.642|
000276  f44f62fd          MOV      r2,#0x7e8
00027a  a166              ADR      r1,|L1.1044|
00027c  a06c              ADR      r0,|L1.1072|
00027e  f7fffffe          BL       __2printf
                  |L1.642|
;;;2025   
;;;2026   	/* It is possible that an ISR caused a task to be removed from an event
;;;2027   	list while the scheduler was suspended.  If this was the case then the
;;;2028   	removed task will have been added to the xPendingReadyList.  Once the
;;;2029   	scheduler has been resumed it is safe to move all the pending ready
;;;2030   	tasks from this list into their appropriate ready list. */
;;;2031   	taskENTER_CRITICAL();
000282  f7fffffe          BL       vPortEnterCritical
;;;2032   	{
;;;2033   		--uxSchedulerSuspended;
000286  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000288  1e40              SUBS     r0,r0,#1
00028a  6328              STR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;2034   
;;;2035   		if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
00028c  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
00028e  bbe0              CBNZ     r0,|L1.778|
;;;2036   		{
;;;2037   			if( uxCurrentNumberOfTasks > ( UBaseType_t ) 0U )
000290  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;2038   			{
;;;2039   				/* Move any readied tasks from the pending list into the
;;;2040   				appropriate ready list. */
;;;2041   				while( listLIST_IS_EMPTY( &xPendingReadyList ) == pdFALSE )
;;;2042   				{
;;;2043   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xPendingReadyList ) );
000292  495e              LDR      r1,|L1.1036|
000294  3128              ADDS     r1,r1,#0x28
;;;2044   					( void ) uxListRemove( &( pxTCB->xEventListItem ) );
;;;2045   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;2046   					prvAddTaskToReadyList( pxTCB );
000296  2601              MOVS     r6,#1
000298  b3b8              CBZ      r0,|L1.778|
00029a  f8df916c          LDR      r9,|L1.1032|
00029e  4688              MOV      r8,r1                 ;2043
                  |L1.672|
0002a0  f8d81000          LDR      r1,[r8,#0]            ;2041  ; xPendingReadyList
0002a4  b1e9              CBZ      r1,|L1.738|
0002a6  f8d8000c          LDR      r0,[r8,#0xc]          ;2043  ; xPendingReadyList
0002aa  68c4              LDR      r4,[r0,#0xc]          ;2044
0002ac  f1040018          ADD      r0,r4,#0x18           ;2044
0002b0  f7fffffe          BL       uxListRemove
0002b4  1d20              ADDS     r0,r4,#4              ;2045
0002b6  f7fffffe          BL       uxListRemove
0002ba  6ae0              LDR      r0,[r4,#0x2c]
0002bc  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
0002be  fa06f100          LSL      r1,r6,r0
0002c2  4311              ORRS     r1,r1,r2
0002c4  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
0002c6  eb000180          ADD      r1,r0,r0,LSL #2
0002ca  eb090081          ADD      r0,r9,r1,LSL #2
0002ce  1d21              ADDS     r1,r4,#4
0002d0  f7fffffe          BL       vListInsertEnd
;;;2047   
;;;2048   					/* If the moved task has a priority higher than the current
;;;2049   					task then a yield must be performed. */
;;;2050   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
0002d4  6ae0              LDR      r0,[r4,#0x2c]
0002d6  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
0002d8  6ac9              LDR      r1,[r1,#0x2c]
0002da  4288              CMP      r0,r1
0002dc  d3e0              BCC      |L1.672|
;;;2051   					{
;;;2052   						xYieldPending = pdTRUE;
0002de  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
0002e0  e7de              B        |L1.672|
                  |L1.738|
;;;2053   					}
;;;2054   					else
;;;2055   					{
;;;2056   						mtCOVERAGE_TEST_MARKER();
;;;2057   					}
;;;2058   				}
;;;2059   
;;;2060   				if( pxTCB != NULL )
0002e2  b10c              CBZ      r4,|L1.744|
;;;2061   				{
;;;2062   					/* A task was unblocked while the scheduler was suspended,
;;;2063   					which may have prevented the next unblock time from being
;;;2064   					re-calculated, in which case re-calculate it now.  Mainly
;;;2065   					important for low power tickless implementations, where
;;;2066   					this can prevent an unnecessary exit from low power
;;;2067   					state. */
;;;2068   					prvResetNextTaskUnblockTime();
0002e4  f7fffffe          BL       prvResetNextTaskUnblockTime
                  |L1.744|
;;;2069   				}
;;;2070   
;;;2071   				/* If any ticks occurred while the scheduler was suspended then
;;;2072   				they should be processed now.  This ensures the tick count does
;;;2073   				not	slip, and that any delayed tasks are resumed at the correct
;;;2074   				time. */
;;;2075   				{
;;;2076   					UBaseType_t uxPendedCounts = uxPendedTicks; /* Non-volatile copy. */
0002e8  69ac              LDR      r4,[r5,#0x18]  ; uxPendedTicks
;;;2077   
;;;2078   					if( uxPendedCounts > ( UBaseType_t ) 0U )
0002ea  b13c              CBZ      r4,|L1.764|
                  |L1.748|
;;;2079   					{
;;;2080   						do
;;;2081   						{
;;;2082   							if( xTaskIncrementTick() != pdFALSE )
0002ec  f7fffffe          BL       xTaskIncrementTick
0002f0  b100              CBZ      r0,|L1.756|
;;;2083   							{
;;;2084   								xYieldPending = pdTRUE;
0002f2  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L1.756|
0002f4  1e64              SUBS     r4,r4,#1
;;;2085   							}
;;;2086   							else
;;;2087   							{
;;;2088   								mtCOVERAGE_TEST_MARKER();
;;;2089   							}
;;;2090   							--uxPendedCounts;
;;;2091   						} while( uxPendedCounts > ( UBaseType_t ) 0U );
0002f6  d1f9              BNE      |L1.748|
;;;2092   
;;;2093   						uxPendedTicks = 0;
0002f8  2000              MOVS     r0,#0
0002fa  61a8              STR      r0,[r5,#0x18]  ; uxPendedTicks
                  |L1.764|
;;;2094   					}
;;;2095   					else
;;;2096   					{
;;;2097   						mtCOVERAGE_TEST_MARKER();
;;;2098   					}
;;;2099   				}
;;;2100   
;;;2101   				if( xYieldPending != pdFALSE )
0002fc  69e8              LDR      r0,[r5,#0x1c]  ; xYieldPending
0002fe  b120              CBZ      r0,|L1.778|
;;;2102   				{
;;;2103   					#if( configUSE_PREEMPTION != 0 )
;;;2104   					{
;;;2105   						xAlreadyYielded = pdTRUE;
;;;2106   					}
;;;2107   					#endif
;;;2108   					taskYIELD_IF_USING_PREEMPTION();
000300  4943              LDR      r1,|L1.1040|
000302  2701              MOVS     r7,#1                 ;2105
000304  0738              LSLS     r0,r7,#28
000306  6008              STR      r0,[r1,#0]
000308  e000              B        |L1.780|
                  |L1.778|
00030a  e003              B        |L1.788|
                  |L1.780|
00030c  f3bf8f4f          DSB      
000310  f3bf8f6f          ISB      
                  |L1.788|
;;;2109   				}
;;;2110   				else
;;;2111   				{
;;;2112   					mtCOVERAGE_TEST_MARKER();
;;;2113   				}
;;;2114   			}
;;;2115   		}
;;;2116   		else
;;;2117   		{
;;;2118   			mtCOVERAGE_TEST_MARKER();
;;;2119   		}
;;;2120   	}
;;;2121   	taskEXIT_CRITICAL();
000314  f7fffffe          BL       vPortExitCritical
;;;2122   
;;;2123   	return xAlreadyYielded;
000318  4638              MOV      r0,r7
;;;2124   }
00031a  e8bd87f0          POP      {r4-r10,pc}
;;;2125   /*-----------------------------------------------------------*/
                          ENDP

                  prvAddCurrentTaskToDelayedList PROC
;;;4691   
;;;4692   static void prvAddCurrentTaskToDelayedList( TickType_t xTicksToWait, const BaseType_t xCanBlockIndefinitely )
00031e  e92d41f0          PUSH     {r4-r8,lr}
;;;4693   {
;;;4694   TickType_t xTimeToWake;
;;;4695   const TickType_t xConstTickCount = xTickCount;
000322  4e38              LDR      r6,|L1.1028|
000324  460f              MOV      r7,r1                 ;4693
000326  4604              MOV      r4,r0                 ;4693
000328  68f5              LDR      r5,[r6,#0xc]  ; xTickCount
;;;4696   
;;;4697   	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;4698   	{
;;;4699   		/* About to enter a delayed list, so ensure the ucDelayAborted flag is
;;;4700   		reset to pdFALSE so it can be detected as having been set to pdTRUE
;;;4701   		when the task leaves the Blocked state. */
;;;4702   		pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;4703   	}
;;;4704   	#endif
;;;4705   
;;;4706   	/* Remove the task from the ready list before adding it to the blocked list
;;;4707   	as the same list item is used for both lists. */
;;;4708   	if( uxListRemove( &( pxCurrentTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00032a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00032c  1d00              ADDS     r0,r0,#4
00032e  f7fffffe          BL       uxListRemove
000332  b938              CBNZ     r0,|L1.836|
;;;4709   	{
;;;4710   		/* The current task must be in a ready list, so there is no need to
;;;4711   		check, and the port reset macro can be called directly. */
;;;4712   		portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
000334  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
000336  f890102c          LDRB     r1,[r0,#0x2c]
00033a  2001              MOVS     r0,#1
00033c  4088              LSLS     r0,r0,r1
00033e  6931              LDR      r1,[r6,#0x10]  ; uxTopReadyPriority
000340  4381              BICS     r1,r1,r0
000342  6131              STR      r1,[r6,#0x10]  ; uxTopReadyPriority
                  |L1.836|
;;;4713   	}
;;;4714   	else
;;;4715   	{
;;;4716   		mtCOVERAGE_TEST_MARKER();
;;;4717   	}
;;;4718   
;;;4719   	#if ( INCLUDE_vTaskSuspend == 1 )
;;;4720   	{
;;;4721   		if( ( xTicksToWait == portMAX_DELAY ) && ( xCanBlockIndefinitely != pdFALSE ) )
000344  1c60              ADDS     r0,r4,#1
000346  d108              BNE      |L1.858|
000348  b13f              CBZ      r7,|L1.858|
;;;4722   		{
;;;4723   			/* Add the task to the suspended task list instead of a delayed task
;;;4724   			list to ensure it is not woken by a timing event.  It will block
;;;4725   			indefinitely. */
;;;4726   			vListInsertEnd( &xSuspendedTaskList, &( pxCurrentTCB->xStateListItem ) );
00034a  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
00034c  e8bd41f0          POP      {r4-r8,lr}
000350  482e              LDR      r0,|L1.1036|
000352  3050              ADDS     r0,r0,#0x50
000354  1d09              ADDS     r1,r1,#4
000356  f7ffbffe          B.W      vListInsertEnd
                  |L1.858|
;;;4727   		}
;;;4728   		else
;;;4729   		{
;;;4730   			/* Calculate the time at which the task should be woken if the event
;;;4731   			does not occur.  This may overflow but this doesn't matter, the
;;;4732   			kernel will manage it correctly. */
;;;4733   			xTimeToWake = xConstTickCount + xTicksToWait;
;;;4734   
;;;4735   			/* The list item will be inserted in wake time order. */
;;;4736   			listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
00035a  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
00035c  442c              ADD      r4,r4,r5              ;4733
;;;4737   
;;;4738   			if( xTimeToWake < xConstTickCount )
00035e  42ac              CMP      r4,r5
000360  6044              STR      r4,[r0,#4]
;;;4739   			{
;;;4740   				/* Wake time has overflowed.  Place this item in the overflow
;;;4741   				list. */
;;;4742   				vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4743   			}
;;;4744   			else
;;;4745   			{
;;;4746   				/* The wake time has not overflowed, so the current block list
;;;4747   				is used. */
;;;4748   				vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
000362  6831              LDR      r1,[r6,#0]  ; pxCurrentTCB
000364  d205              BCS      |L1.882|
000366  6bb0              LDR      r0,[r6,#0x38]         ;4742  ; pxOverflowDelayedTaskList
000368  e8bd41f0          POP      {r4-r8,lr}            ;4742
00036c  1d09              ADDS     r1,r1,#4              ;4742
00036e  f7ffbffe          B.W      vListInsert
                  |L1.882|
000372  6b70              LDR      r0,[r6,#0x34]  ; pxDelayedTaskList
000374  1d09              ADDS     r1,r1,#4
000376  f7fffffe          BL       vListInsert
;;;4749   
;;;4750   				/* If the task entering the blocked state was placed at the
;;;4751   				head of the list of blocked tasks then xNextTaskUnblockTime
;;;4752   				needs to be updated too. */
;;;4753   				if( xTimeToWake < xNextTaskUnblockTime )
00037a  6ab0              LDR      r0,[r6,#0x28]  ; xNextTaskUnblockTime
00037c  4284              CMP      r4,r0
00037e  d200              BCS      |L1.898|
;;;4754   				{
;;;4755   					xNextTaskUnblockTime = xTimeToWake;
000380  62b4              STR      r4,[r6,#0x28]  ; xNextTaskUnblockTime
                  |L1.898|
;;;4756   				}
;;;4757   				else
;;;4758   				{
;;;4759   					mtCOVERAGE_TEST_MARKER();
;;;4760   				}
;;;4761   			}
;;;4762   		}
;;;4763   	}
;;;4764   	#else /* INCLUDE_vTaskSuspend */
;;;4765   	{
;;;4766   		/* Calculate the time at which the task should be woken if the event
;;;4767   		does not occur.  This may overflow but this doesn't matter, the kernel
;;;4768   		will manage it correctly. */
;;;4769   		xTimeToWake = xConstTickCount + xTicksToWait;
;;;4770   
;;;4771   		/* The list item will be inserted in wake time order. */
;;;4772   		listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xStateListItem ), xTimeToWake );
;;;4773   
;;;4774   		if( xTimeToWake < xConstTickCount )
;;;4775   		{
;;;4776   			/* Wake time has overflowed.  Place this item in the overflow list. */
;;;4777   			vListInsert( pxOverflowDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4778   		}
;;;4779   		else
;;;4780   		{
;;;4781   			/* The wake time has not overflowed, so the current block list is used. */
;;;4782   			vListInsert( pxDelayedTaskList, &( pxCurrentTCB->xStateListItem ) );
;;;4783   
;;;4784   			/* If the task entering the blocked state was placed at the head of the
;;;4785   			list of blocked tasks then xNextTaskUnblockTime needs to be updated
;;;4786   			too. */
;;;4787   			if( xTimeToWake < xNextTaskUnblockTime )
;;;4788   			{
;;;4789   				xNextTaskUnblockTime = xTimeToWake;
;;;4790   			}
;;;4791   			else
;;;4792   			{
;;;4793   				mtCOVERAGE_TEST_MARKER();
;;;4794   			}
;;;4795   		}
;;;4796   
;;;4797   		/* Avoid compiler warning when INCLUDE_vTaskSuspend is not 1. */
;;;4798   		( void ) xCanBlockIndefinitely;
;;;4799   	}
;;;4800   	#endif /* INCLUDE_vTaskSuspend */
;;;4801   }
000382  e69a              B        |L1.186|
;;;4802   
                          ENDP

                  vTaskSuspendAll PROC
;;;1943   
;;;1944   void vTaskSuspendAll( void )
000384  481f              LDR      r0,|L1.1028|
;;;1945   {
;;;1946   	/* A critical section is not required as the variable is of type
;;;1947   	BaseType_t.  Please read Richard Barry's reply in the following link to a
;;;1948   	post in the FreeRTOS support forum before reporting this as a bug! -
;;;1949   	http://goo.gl/wu4acr */
;;;1950   	++uxSchedulerSuspended;
000386  6b01              LDR      r1,[r0,#0x30]  ; uxSchedulerSuspended
000388  1c49              ADDS     r1,r1,#1
00038a  6301              STR      r1,[r0,#0x30]  ; uxSchedulerSuspended
;;;1951   }
00038c  4770              BX       lr
;;;1952   /*----------------------------------------------------------*/
                          ENDP

                  vTaskDelayUntil PROC
;;;1139   
;;;1140   	void vTaskDelayUntil( TickType_t * const pxPreviousWakeTime, const TickType_t xTimeIncrement )
00038e  e92d41f0          PUSH     {r4-r8,lr}
;;;1141   	{
000392  460e              MOV      r6,r1
000394  0005              MOVS     r5,r0
;;;1142   	TickType_t xTimeToWake;
;;;1143   	BaseType_t xAlreadyYielded, xShouldDelay = pdFALSE;
000396  f04f0400          MOV      r4,#0
00039a  d105              BNE      |L1.936|
;;;1144   
;;;1145   		configASSERT( pxPreviousWakeTime );
00039c  f2404279          MOV      r2,#0x479
0003a0  a11c              ADR      r1,|L1.1044|
0003a2  a023              ADR      r0,|L1.1072|
0003a4  f7fffffe          BL       __2printf
                  |L1.936|
;;;1146   		configASSERT( ( xTimeIncrement > 0U ) );
0003a8  b92e              CBNZ     r6,|L1.950|
0003aa  f240427a          MOV      r2,#0x47a
0003ae  a119              ADR      r1,|L1.1044|
0003b0  a01f              ADR      r0,|L1.1072|
0003b2  f7fffffe          BL       __2printf
                  |L1.950|
;;;1147   		configASSERT( uxSchedulerSuspended == 0 );
0003b6  4f13              LDR      r7,|L1.1028|
0003b8  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
0003ba  b128              CBZ      r0,|L1.968|
0003bc  f240427b          MOV      r2,#0x47b
0003c0  a114              ADR      r1,|L1.1044|
0003c2  a01b              ADR      r0,|L1.1072|
0003c4  f7fffffe          BL       __2printf
                  |L1.968|
;;;1148   
;;;1149   		vTaskSuspendAll();
0003c8  f7fffffe          BL       vTaskSuspendAll
;;;1150   		{
;;;1151   			/* Minor optimisation.  The tick count cannot change in this
;;;1152   			block. */
;;;1153   			const TickType_t xConstTickCount = xTickCount;
0003cc  68fa              LDR      r2,[r7,#0xc]  ; xTickCount
;;;1154   
;;;1155   			/* Generate the tick time at which the task wants to wake. */
;;;1156   			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
0003ce  6828              LDR      r0,[r5,#0]
0003d0  1981              ADDS     r1,r0,r6
;;;1157   
;;;1158   			if( xConstTickCount < *pxPreviousWakeTime )
0003d2  4290              CMP      r0,r2
0003d4  d902              BLS      |L1.988|
;;;1159   			{
;;;1160   				/* The tick count has overflowed since this function was
;;;1161   				lasted called.  In this case the only time we should ever
;;;1162   				actually delay is if the wake time has also	overflowed,
;;;1163   				and the wake time is greater than the tick time.  When this
;;;1164   				is the case it is as if neither time had overflowed. */
;;;1165   				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xConstTickCount ) )
0003d6  4288              CMP      r0,r1
0003d8  d802              BHI      |L1.992|
0003da  e004              B        |L1.998|
                  |L1.988|
;;;1166   				{
;;;1167   					xShouldDelay = pdTRUE;
;;;1168   				}
;;;1169   				else
;;;1170   				{
;;;1171   					mtCOVERAGE_TEST_MARKER();
;;;1172   				}
;;;1173   			}
;;;1174   			else
;;;1175   			{
;;;1176   				/* The tick time has not overflowed.  In this case we will
;;;1177   				delay if either the wake time has overflowed, and/or the
;;;1178   				tick time is less than the wake time. */
;;;1179   				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xConstTickCount ) )
0003dc  4288              CMP      r0,r1
0003de  d801              BHI      |L1.996|
                  |L1.992|
0003e0  4291              CMP      r1,r2
0003e2  d900              BLS      |L1.998|
                  |L1.996|
;;;1180   				{
;;;1181   					xShouldDelay = pdTRUE;
0003e4  2401              MOVS     r4,#1
                  |L1.998|
;;;1182   				}
;;;1183   				else
;;;1184   				{
;;;1185   					mtCOVERAGE_TEST_MARKER();
;;;1186   				}
;;;1187   			}
;;;1188   
;;;1189   			/* Update the wake time ready for the next call. */
;;;1190   			*pxPreviousWakeTime = xTimeToWake;
;;;1191   
;;;1192   			if( xShouldDelay != pdFALSE )
0003e6  6029              STR      r1,[r5,#0]
0003e8  b11c              CBZ      r4,|L1.1010|
;;;1193   			{
;;;1194   				traceTASK_DELAY_UNTIL( xTimeToWake );
;;;1195   
;;;1196   				/* prvAddCurrentTaskToDelayedList() needs the block time, not
;;;1197   				the time to wake, so subtract the current tick count. */
;;;1198   				prvAddCurrentTaskToDelayedList( xTimeToWake - xConstTickCount, pdFALSE );
0003ea  1a88              SUBS     r0,r1,r2
0003ec  2100              MOVS     r1,#0
0003ee  f7fffffe          BL       prvAddCurrentTaskToDelayedList
                  |L1.1010|
;;;1199   			}
;;;1200   			else
;;;1201   			{
;;;1202   				mtCOVERAGE_TEST_MARKER();
;;;1203   			}
;;;1204   		}
;;;1205   		xAlreadyYielded = xTaskResumeAll();
0003f2  f7fffffe          BL       xTaskResumeAll
;;;1206   
;;;1207   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1208   		have put ourselves to sleep. */
;;;1209   		if( xAlreadyYielded == pdFALSE )
0003f6  2800              CMP      r0,#0
0003f8  d126              BNE      |L1.1096|
;;;1210   		{
;;;1211   			portYIELD_WITHIN_API();
0003fa  4905              LDR      r1,|L1.1040|
0003fc  f04f5080          MOV      r0,#0x10000000
000400  6008              STR      r0,[r1,#0]
000402  e01d              B        |L1.1088|
                  |L1.1028|
                          DCD      ||.data||
                  |L1.1032|
                          DCD      ||.bss||
                  |L1.1036|
                          DCD      ||.bss||+0x280
                  |L1.1040|
                          DCD      0xe000ed04
                  |L1.1044|
000414  2e2e5c2e          DCB      "..\\..\\FreeRTOS\\src\\tasks.c",0
000418  2e5c4672
00041c  65655254
000420  4f535c73
000424  72635c74
000428  61736b73
00042c  2e6300  
00042f  00                DCB      0
                  |L1.1072|
000430  4572726f          DCB      "Error:%s,%d\r\n",0
000434  723a2573
000438  2c25640d
00043c  0a00    
00043e  00                DCB      0
00043f  00                DCB      0
                  |L1.1088|
000440  f3bf8f4f          DSB      
000444  f3bf8f6f          ISB      
                  |L1.1096|
;;;1212   		}
;;;1213   		else
;;;1214   		{
;;;1215   			mtCOVERAGE_TEST_MARKER();
;;;1216   		}
;;;1217   	}
000448  e637              B        |L1.186|
;;;1218   
                          ENDP

                  vTaskDelay PROC
;;;1223   
;;;1224   	void vTaskDelay( const TickType_t xTicksToDelay )
00044a  b510              PUSH     {r4,lr}
;;;1225   	{
00044c  0004              MOVS     r4,r0
00044e  d014              BEQ      |L1.1146|
;;;1226   	BaseType_t xAlreadyYielded = pdFALSE;
;;;1227   
;;;1228   		/* A delay time of zero just forces a reschedule. */
;;;1229   		if( xTicksToDelay > ( TickType_t ) 0U )
;;;1230   		{
;;;1231   			configASSERT( uxSchedulerSuspended == 0 );
000450  49fe              LDR      r1,|L1.2124|
000452  6b09              LDR      r1,[r1,#0x30]  ; uxSchedulerSuspended
000454  b139              CBZ      r1,|L1.1126|
000456  f24042cf          MOV      r2,#0x4cf
00045a  f2af0148          ADR      r1,|L1.1044|
00045e  f2af0030          ADR      r0,|L1.1072|
000462  f7fffffe          BL       __2printf
                  |L1.1126|
;;;1232   			vTaskSuspendAll();
000466  f7fffffe          BL       vTaskSuspendAll
;;;1233   			{
;;;1234   				traceTASK_DELAY();
;;;1235   
;;;1236   				/* A task that is removed from the event list while the
;;;1237   				scheduler is suspended will not get placed in the ready
;;;1238   				list or removed from the blocked list until the scheduler
;;;1239   				is resumed.
;;;1240   
;;;1241   				This task cannot be in an event list as it is the currently
;;;1242   				executing task. */
;;;1243   				prvAddCurrentTaskToDelayedList( xTicksToDelay, pdFALSE );
00046a  2100              MOVS     r1,#0
00046c  4620              MOV      r0,r4
00046e  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;1244   			}
;;;1245   			xAlreadyYielded = xTaskResumeAll();
000472  f7fffffe          BL       xTaskResumeAll
000476  2800              CMP      r0,#0
000478  d107              BNE      |L1.1162|
                  |L1.1146|
;;;1246   		}
;;;1247   		else
;;;1248   		{
;;;1249   			mtCOVERAGE_TEST_MARKER();
;;;1250   		}
;;;1251   
;;;1252   		/* Force a reschedule if xTaskResumeAll has not already done so, we may
;;;1253   		have put ourselves to sleep. */
;;;1254   		if( xAlreadyYielded == pdFALSE )
;;;1255   		{
;;;1256   			portYIELD_WITHIN_API();
00047a  49f5              LDR      r1,|L1.2128|
00047c  f04f5080          MOV      r0,#0x10000000
000480  6008              STR      r0,[r1,#0]
000482  f3bf8f4f          DSB      
000486  f3bf8f6f          ISB      
                  |L1.1162|
;;;1257   		}
;;;1258   		else
;;;1259   		{
;;;1260   			mtCOVERAGE_TEST_MARKER();
;;;1261   		}
;;;1262   	}
00048a  bd10              POP      {r4,pc}
;;;1263   
                          ENDP

                  eTaskGetState PROC
;;;1268   
;;;1269   	eTaskState eTaskGetState( TaskHandle_t xTask )
00048c  b570              PUSH     {r4-r6,lr}
;;;1270   	{
00048e  0005              MOVS     r5,r0
000490  d107              BNE      |L1.1186|
;;;1271   	eTaskState eReturn;
;;;1272   	List_t *pxStateList;
;;;1273   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
;;;1274   
;;;1275   		configASSERT( pxTCB );
000492  f24042fb          MOV      r2,#0x4fb
000496  f2af0184          ADR      r1,|L1.1044|
00049a  f2af006c          ADR      r0,|L1.1072|
00049e  f7fffffe          BL       __2printf
                  |L1.1186|
;;;1276   
;;;1277   		if( pxTCB == pxCurrentTCB )
0004a2  4eea              LDR      r6,|L1.2124|
0004a4  6830              LDR      r0,[r6,#0]  ; pxCurrentTCB
0004a6  4285              CMP      r5,r0
0004a8  d101              BNE      |L1.1198|
;;;1278   		{
;;;1279   			/* The task calling this function is querying its own state. */
;;;1280   			eReturn = eRunning;
0004aa  2000              MOVS     r0,#0
;;;1281   		}
;;;1282   		else
;;;1283   		{
;;;1284   			taskENTER_CRITICAL();
;;;1285   			{
;;;1286   				pxStateList = ( List_t * ) listLIST_ITEM_CONTAINER( &( pxTCB->xStateListItem ) );
;;;1287   			}
;;;1288   			taskEXIT_CRITICAL();
;;;1289   
;;;1290   			if( ( pxStateList == pxDelayedTaskList ) || ( pxStateList == pxOverflowDelayedTaskList ) )
;;;1291   			{
;;;1292   				/* The task being queried is referenced from one of the Blocked
;;;1293   				lists. */
;;;1294   				eReturn = eBlocked;
;;;1295   			}
;;;1296   
;;;1297   			#if ( INCLUDE_vTaskSuspend == 1 )
;;;1298   				else if( pxStateList == &xSuspendedTaskList )
;;;1299   				{
;;;1300   					/* The task being queried is referenced from the suspended
;;;1301   					list.  Is it genuinely suspended or is it block
;;;1302   					indefinitely? */
;;;1303   					if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL )
;;;1304   					{
;;;1305   						eReturn = eSuspended;
;;;1306   					}
;;;1307   					else
;;;1308   					{
;;;1309   						eReturn = eBlocked;
;;;1310   					}
;;;1311   				}
;;;1312   			#endif
;;;1313   
;;;1314   			#if ( INCLUDE_vTaskDelete == 1 )
;;;1315   				else if( ( pxStateList == &xTasksWaitingTermination ) || ( pxStateList == NULL ) )
;;;1316   				{
;;;1317   					/* The task being queried is referenced from the deleted
;;;1318   					tasks list, or it is not referenced from any lists at
;;;1319   					all. */
;;;1320   					eReturn = eDeleted;
;;;1321   				}
;;;1322   			#endif
;;;1323   
;;;1324   			else /*lint !e525 Negative indentation is intended to make use of pre-processor clearer. */
;;;1325   			{
;;;1326   				/* If the task is not in any other state, it must be in the
;;;1327   				Ready (including pending ready) state. */
;;;1328   				eReturn = eReady;
;;;1329   			}
;;;1330   		}
;;;1331   
;;;1332   		return eReturn;
;;;1333   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
0004ac  bd70              POP      {r4-r6,pc}
                  |L1.1198|
0004ae  f7fffffe          BL       vPortEnterCritical
0004b2  696c              LDR      r4,[r5,#0x14]         ;1288
0004b4  f7fffffe          BL       vPortExitCritical
0004b8  6b70              LDR      r0,[r6,#0x34]         ;1290  ; pxDelayedTaskList
0004ba  4284              CMP      r4,r0                 ;1290
0004bc  d002              BEQ      |L1.1220|
0004be  6bb0              LDR      r0,[r6,#0x38]         ;1290  ; pxOverflowDelayedTaskList
0004c0  4284              CMP      r4,r0                 ;1290
0004c2  d101              BNE      |L1.1224|
                  |L1.1220|
0004c4  2002              MOVS     r0,#2                 ;1294
0004c6  bd70              POP      {r4-r6,pc}
                  |L1.1224|
0004c8  48e2              LDR      r0,|L1.2132|
0004ca  4284              CMP      r4,r0                 ;1298
0004cc  d104              BNE      |L1.1240|
0004ce  6aa8              LDR      r0,[r5,#0x28]         ;1303
0004d0  2800              CMP      r0,#0                 ;1303
0004d2  d1f7              BNE      |L1.1220|
0004d4  2003              MOVS     r0,#3                 ;1305
0004d6  bd70              POP      {r4-r6,pc}
                  |L1.1240|
0004d8  48de              LDR      r0,|L1.2132|
0004da  3814              SUBS     r0,r0,#0x14           ;1315
0004dc  4284              CMP      r4,r0                 ;1315
0004de  d002              BEQ      |L1.1254|
0004e0  b10c              CBZ      r4,|L1.1254|
0004e2  2001              MOVS     r0,#1                 ;1328
0004e4  bd70              POP      {r4-r6,pc}
                  |L1.1254|
0004e6  2004              MOVS     r0,#4                 ;1320
0004e8  bd70              POP      {r4-r6,pc}
;;;1334   
                          ENDP

                  uxTaskPriorityGet PROC
;;;1339   
;;;1340   	UBaseType_t uxTaskPriorityGet( TaskHandle_t xTask )
0004ea  b510              PUSH     {r4,lr}
;;;1341   	{
0004ec  4604              MOV      r4,r0
;;;1342   	TCB_t *pxTCB;
;;;1343   	UBaseType_t uxReturn;
;;;1344   
;;;1345   		taskENTER_CRITICAL();
0004ee  f7fffffe          BL       vPortEnterCritical
;;;1346   		{
;;;1347   			/* If null is passed in here then it is the priority of the that
;;;1348   			called uxTaskPriorityGet() that is being queried. */
;;;1349   			pxTCB = prvGetTCBFromHandle( xTask );
0004f2  b90c              CBNZ     r4,|L1.1272|
0004f4  48d5              LDR      r0,|L1.2124|
0004f6  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.1272|
;;;1350   			uxReturn = pxTCB->uxPriority;
0004f8  6ae4              LDR      r4,[r4,#0x2c]
;;;1351   		}
;;;1352   		taskEXIT_CRITICAL();
0004fa  f7fffffe          BL       vPortExitCritical
;;;1353   
;;;1354   		return uxReturn;
0004fe  4620              MOV      r0,r4
;;;1355   	}
000500  bd10              POP      {r4,pc}
;;;1356   
                          ENDP

                  uxTaskPriorityGetFromISR PROC
;;;1361   
;;;1362   	UBaseType_t uxTaskPriorityGetFromISR( TaskHandle_t xTask )
000502  b510              PUSH     {r4,lr}
;;;1363   	{
000504  4604              MOV      r4,r0
;;;1364   	TCB_t *pxTCB;
;;;1365   	UBaseType_t uxReturn, uxSavedInterruptState;
;;;1366   
;;;1367   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1368   		maximum	system call (or maximum API call) interrupt priority.
;;;1369   		Interrupts that are	above the maximum system call priority are keep
;;;1370   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1371   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1372   		is defined in FreeRTOSConfig.h then
;;;1373   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1374   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1375   		been assigned a priority above the configured maximum system call
;;;1376   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1377   		from interrupts	that have been assigned a priority at or (logically)
;;;1378   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1379   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1380   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1381   		provided on the following link:
;;;1382   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1383   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000506  f7fffffe          BL       vPortValidateInterruptPriority
00050a  2050              MOVS     r0,#0x50
00050c  f3ef8111          MRS      r1,BASEPRI
000510  f3808811          MSR      BASEPRI,r0
000514  f3bf8f4f          DSB      
000518  f3bf8f6f          ISB      
;;;1384   
;;;1385   		uxSavedInterruptState = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1386   		{
;;;1387   			/* If null is passed in here then it is the priority of the calling
;;;1388   			task that is being queried. */
;;;1389   			pxTCB = prvGetTCBFromHandle( xTask );
00051c  b90c              CBNZ     r4,|L1.1314|
00051e  48cb              LDR      r0,|L1.2124|
000520  6804              LDR      r4,[r0,#0]  ; pxCurrentTCB
                  |L1.1314|
000522  6ae0              LDR      r0,[r4,#0x2c]
000524  f3818811          MSR      BASEPRI,r1
;;;1390   			uxReturn = pxTCB->uxPriority;
;;;1391   		}
;;;1392   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptState );
;;;1393   
;;;1394   		return uxReturn;
;;;1395   	}
000528  bd10              POP      {r4,pc}
;;;1396   
                          ENDP

                  vTaskPrioritySet PROC
;;;1401   
;;;1402   	void vTaskPrioritySet( TaskHandle_t xTask, UBaseType_t uxNewPriority )
00052a  e92d41f0          PUSH     {r4-r8,lr}
;;;1403   	{
;;;1404   	TCB_t *pxTCB;
;;;1405   	UBaseType_t uxCurrentBasePriority, uxPriorityUsedOnEntry;
;;;1406   	BaseType_t xYieldRequired = pdFALSE;
00052e  2600              MOVS     r6,#0
000530  460d              MOV      r5,r1                 ;1403
000532  4604              MOV      r4,r0                 ;1403
;;;1407   
;;;1408   		configASSERT( ( uxNewPriority < configMAX_PRIORITIES ) );
000534  2920              CMP      r1,#0x20
000536  d308              BCC      |L1.1354|
000538  f44f62b0          MOV      r2,#0x580
00053c  f2af112c          ADR      r1,|L1.1044|
000540  f2af1014          ADR      r0,|L1.1072|
000544  f7fffffe          BL       __2printf
;;;1409   
;;;1410   		/* Ensure the new priority is valid. */
;;;1411   		if( uxNewPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
;;;1412   		{
;;;1413   			uxNewPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000548  251f              MOVS     r5,#0x1f
                  |L1.1354|
;;;1414   		}
;;;1415   		else
;;;1416   		{
;;;1417   			mtCOVERAGE_TEST_MARKER();
;;;1418   		}
;;;1419   
;;;1420   		taskENTER_CRITICAL();
00054a  f7fffffe          BL       vPortEnterCritical
;;;1421   		{
;;;1422   			/* If null is passed in here then it is the priority of the calling
;;;1423   			task that is being changed. */
;;;1424   			pxTCB = prvGetTCBFromHandle( xTask );
00054e  4fbf              LDR      r7,|L1.2124|
000550  b904              CBNZ     r4,|L1.1364|
000552  683c              LDR      r4,[r7,#0]  ; pxCurrentTCB
                  |L1.1364|
;;;1425   
;;;1426   			traceTASK_PRIORITY_SET( pxTCB, uxNewPriority );
;;;1427   
;;;1428   			#if ( configUSE_MUTEXES == 1 )
;;;1429   			{
;;;1430   				uxCurrentBasePriority = pxTCB->uxBasePriority;
;;;1431   			}
;;;1432   			#else
;;;1433   			{
;;;1434   				uxCurrentBasePriority = pxTCB->uxPriority;
;;;1435   			}
;;;1436   			#endif
;;;1437   
;;;1438   			if( uxCurrentBasePriority != uxNewPriority )
000554  6c60              LDR      r0,[r4,#0x44]
000556  42a8              CMP      r0,r5
000558  d03f              BEQ      |L1.1498|
;;;1439   			{
;;;1440   				/* The priority change may have readied a task of higher
;;;1441   				priority than the calling task. */
;;;1442   				if( uxNewPriority > uxCurrentBasePriority )
;;;1443   				{
;;;1444   					if( pxTCB != pxCurrentTCB )
;;;1445   					{
;;;1446   						/* The priority of a task other than the currently
;;;1447   						running task is being raised.  Is the priority being
;;;1448   						raised above that of the running task? */
;;;1449   						if( uxNewPriority >= pxCurrentTCB->uxPriority )
;;;1450   						{
;;;1451   							xYieldRequired = pdTRUE;
;;;1452   						}
;;;1453   						else
;;;1454   						{
;;;1455   							mtCOVERAGE_TEST_MARKER();
;;;1456   						}
;;;1457   					}
;;;1458   					else
;;;1459   					{
;;;1460   						/* The priority of the running task is being raised,
;;;1461   						but the running task must already be the highest
;;;1462   						priority task able to run so no yield is required. */
;;;1463   					}
;;;1464   				}
;;;1465   				else if( pxTCB == pxCurrentTCB )
00055a  6839              LDR      r1,[r7,#0]  ; pxCurrentTCB
00055c  4285              CMP      r5,r0                 ;1442
00055e  d906              BLS      |L1.1390|
000560  428c              CMP      r4,r1                 ;1444
000562  d007              BEQ      |L1.1396|
000564  6839              LDR      r1,[r7,#0]            ;1449  ; pxCurrentTCB
000566  6ac9              LDR      r1,[r1,#0x2c]         ;1449
000568  42a9              CMP      r1,r5                 ;1449
00056a  d902              BLS      |L1.1394|
00056c  e002              B        |L1.1396|
                  |L1.1390|
00056e  428c              CMP      r4,r1
000570  d100              BNE      |L1.1396|
                  |L1.1394|
;;;1466   				{
;;;1467   					/* Setting the priority of the running task down means
;;;1468   					there may now be another task of higher priority that
;;;1469   					is ready to execute. */
;;;1470   					xYieldRequired = pdTRUE;
000572  2601              MOVS     r6,#1
                  |L1.1396|
;;;1471   				}
;;;1472   				else
;;;1473   				{
;;;1474   					/* Setting the priority of any other task down does not
;;;1475   					require a yield as the running task must be above the
;;;1476   					new priority of the task being modified. */
;;;1477   				}
;;;1478   
;;;1479   				/* Remember the ready list the task might be referenced from
;;;1480   				before its uxPriority member is changed so the
;;;1481   				taskRESET_READY_PRIORITY() macro can function correctly. */
;;;1482   				uxPriorityUsedOnEntry = pxTCB->uxPriority;
000574  6ae1              LDR      r1,[r4,#0x2c]
000576  4688              MOV      r8,r1
;;;1483   
;;;1484   				#if ( configUSE_MUTEXES == 1 )
;;;1485   				{
;;;1486   					/* Only change the priority being used if the task is not
;;;1487   					currently using an inherited priority. */
;;;1488   					if( pxTCB->uxBasePriority == pxTCB->uxPriority )
000578  4288              CMP      r0,r1
00057a  d100              BNE      |L1.1406|
;;;1489   					{
;;;1490   						pxTCB->uxPriority = uxNewPriority;
00057c  62e5              STR      r5,[r4,#0x2c]
                  |L1.1406|
;;;1491   					}
;;;1492   					else
;;;1493   					{
;;;1494   						mtCOVERAGE_TEST_MARKER();
;;;1495   					}
;;;1496   
;;;1497   					/* The base priority gets set whatever. */
;;;1498   					pxTCB->uxBasePriority = uxNewPriority;
;;;1499   				}
;;;1500   				#else
;;;1501   				{
;;;1502   					pxTCB->uxPriority = uxNewPriority;
;;;1503   				}
;;;1504   				#endif
;;;1505   
;;;1506   				/* Only reset the event list item value if the value is not
;;;1507   				being used for anything else. */
;;;1508   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
00057e  6465              STR      r5,[r4,#0x44]
000580  69a0              LDR      r0,[r4,#0x18]
000582  2800              CMP      r0,#0
000584  db02              BLT      |L1.1420|
;;;1509   				{
;;;1510   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxNewPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000586  f1c50020          RSB      r0,r5,#0x20
00058a  61a0              STR      r0,[r4,#0x18]
                  |L1.1420|
;;;1511   				}
;;;1512   				else
;;;1513   				{
;;;1514   					mtCOVERAGE_TEST_MARKER();
;;;1515   				}
;;;1516   
;;;1517   				/* If the task is in the blocked or suspended list we need do
;;;1518   				nothing more than change it's priority variable. However, if
;;;1519   				the task is in a ready list it needs to be removed and placed
;;;1520   				in the list appropriate to its new priority. */
;;;1521   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ uxPriorityUsedOnEntry ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
00058c  4db2              LDR      r5,|L1.2136|
00058e  eb080088          ADD      r0,r8,r8,LSL #2
000592  6961              LDR      r1,[r4,#0x14]
000594  eb050080          ADD      r0,r5,r0,LSL #2
000598  4281              CMP      r1,r0
00059a  d115              BNE      |L1.1480|
;;;1522   				{
;;;1523   					/* The task is currently in its ready list - remove before adding
;;;1524   					it to it's new ready list.  As we are in a critical section we
;;;1525   					can do this even if the scheduler is suspended. */
;;;1526   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
00059c  1d20              ADDS     r0,r4,#4
00059e  f7fffffe          BL       uxListRemove
0005a2  2101              MOVS     r1,#1                 ;1451
0005a4  b920              CBNZ     r0,|L1.1456|
;;;1527   					{
;;;1528   						/* It is known that the task is in its ready list so
;;;1529   						there is no need to check again and the port level
;;;1530   						reset macro can be called directly. */
;;;1531   						portRESET_READY_PRIORITY( uxPriorityUsedOnEntry, uxTopReadyPriority );
0005a6  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
0005a8  fa01f008          LSL      r0,r1,r8
0005ac  4382              BICS     r2,r2,r0
0005ae  613a              STR      r2,[r7,#0x10]  ; uxTopReadyPriority
                  |L1.1456|
;;;1532   					}
;;;1533   					else
;;;1534   					{
;;;1535   						mtCOVERAGE_TEST_MARKER();
;;;1536   					}
;;;1537   					prvAddTaskToReadyList( pxTCB );
0005b0  6ae0              LDR      r0,[r4,#0x2c]
0005b2  693a              LDR      r2,[r7,#0x10]  ; uxTopReadyPriority
0005b4  4081              LSLS     r1,r1,r0
0005b6  4311              ORRS     r1,r1,r2
0005b8  6139              STR      r1,[r7,#0x10]  ; uxTopReadyPriority
0005ba  eb000080          ADD      r0,r0,r0,LSL #2
0005be  eb050080          ADD      r0,r5,r0,LSL #2
0005c2  1d21              ADDS     r1,r4,#4
0005c4  f7fffffe          BL       vListInsertEnd
                  |L1.1480|
;;;1538   				}
;;;1539   				else
;;;1540   				{
;;;1541   					mtCOVERAGE_TEST_MARKER();
;;;1542   				}
;;;1543   
;;;1544   				if( xYieldRequired != pdFALSE )
0005c8  b13e              CBZ      r6,|L1.1498|
;;;1545   				{
;;;1546   					taskYIELD_IF_USING_PREEMPTION();
0005ca  49a1              LDR      r1,|L1.2128|
0005cc  f04f5080          MOV      r0,#0x10000000
0005d0  6008              STR      r0,[r1,#0]
0005d2  f3bf8f4f          DSB      
0005d6  f3bf8f6f          ISB      
                  |L1.1498|
;;;1547   				}
;;;1548   				else
;;;1549   				{
;;;1550   					mtCOVERAGE_TEST_MARKER();
;;;1551   				}
;;;1552   
;;;1553   				/* Remove compiler warning about unused variables when the port
;;;1554   				optimised task selection is not being used. */
;;;1555   				( void ) uxPriorityUsedOnEntry;
;;;1556   			}
;;;1557   		}
;;;1558   		taskEXIT_CRITICAL();
0005da  e8bd41f0          POP      {r4-r8,lr}
0005de  f7ffbffe          B.W      vPortExitCritical
;;;1559   	}
;;;1560   
                          ENDP

                  vTaskSwitchContext PROC
;;;2760   
;;;2761   void vTaskSwitchContext( void )
0005e2  b570              PUSH     {r4-r6,lr}
;;;2762   {
;;;2763   	if( uxSchedulerSuspended != ( UBaseType_t ) pdFALSE )
0005e4  4d99              LDR      r5,|L1.2124|
0005e6  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
0005e8  b110              CBZ      r0,|L1.1520|
;;;2764   	{
;;;2765   		/* The scheduler is currently suspended - do not allow a context
;;;2766   		switch. */
;;;2767   		xYieldPending = pdTRUE;
0005ea  2001              MOVS     r0,#1
0005ec  61e8              STR      r0,[r5,#0x1c]  ; xYieldPending
;;;2768   	}
;;;2769   	else
;;;2770   	{
;;;2771   		xYieldPending = pdFALSE;
;;;2772   		traceTASK_SWITCHED_OUT();
;;;2773   
;;;2774   		#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;2775   		{
;;;2776   				#ifdef portALT_GET_RUN_TIME_COUNTER_VALUE
;;;2777   					portALT_GET_RUN_TIME_COUNTER_VALUE( ulTotalRunTime );
;;;2778   				#else
;;;2779   					ulTotalRunTime = portGET_RUN_TIME_COUNTER_VALUE();
;;;2780   				#endif
;;;2781   
;;;2782   				/* Add the amount of time the task has been running to the
;;;2783   				accumulated time so far.  The time the task started running was
;;;2784   				stored in ulTaskSwitchedInTime.  Note that there is no overflow
;;;2785   				protection here so count values are only valid until the timer
;;;2786   				overflows.  The guard against negative values is to protect
;;;2787   				against suspect run time stat counter implementations - which
;;;2788   				are provided by the application, not the kernel. */
;;;2789   				if( ulTotalRunTime > ulTaskSwitchedInTime )
;;;2790   				{
;;;2791   					pxCurrentTCB->ulRunTimeCounter += ( ulTotalRunTime - ulTaskSwitchedInTime );
;;;2792   				}
;;;2793   				else
;;;2794   				{
;;;2795   					mtCOVERAGE_TEST_MARKER();
;;;2796   				}
;;;2797   				ulTaskSwitchedInTime = ulTotalRunTime;
;;;2798   		}
;;;2799   		#endif /* configGENERATE_RUN_TIME_STATS */
;;;2800   
;;;2801   		/* Check for stack overflow, if configured. */
;;;2802   		taskCHECK_FOR_STACK_OVERFLOW();
;;;2803   
;;;2804   		/* Select a new task to run using either the generic C or port
;;;2805   		optimised asm code. */
;;;2806   		taskSELECT_HIGHEST_PRIORITY_TASK();
;;;2807   		traceTASK_SWITCHED_IN();
;;;2808   
;;;2809   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;2810   		{
;;;2811   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;2812   			structure specific to this task. */
;;;2813   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;2814   		}
;;;2815   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;2816   	}
;;;2817   }
0005ee  bd70              POP      {r4-r6,pc}
                  |L1.1520|
0005f0  2000              MOVS     r0,#0                 ;2771
0005f2  61e8              STR      r0,[r5,#0x1c]         ;2771  ; xYieldPending
0005f4  6928              LDR      r0,[r5,#0x10]         ;2806  ; uxTopReadyPriority
0005f6  4e98              LDR      r6,|L1.2136|
0005f8  fab0f080          CLZ      r0,r0                 ;2806
0005fc  f1c0001f          RSB      r0,r0,#0x1f           ;2806
000600  eb000480          ADD      r4,r0,r0,LSL #2       ;2806
000604  f8560024          LDR      r0,[r6,r4,LSL #2]     ;2806
000608  b938              CBNZ     r0,|L1.1562|
00060a  f64022f6          MOV      r2,#0xaf6             ;2806
00060e  f2af11fc          ADR      r1,|L1.1044|
000612  f2af10e4          ADR      r0,|L1.1072|
000616  f7fffffe          BL       __2printf
                  |L1.1562|
00061a  eb060084          ADD      r0,r6,r4,LSL #2       ;2806
00061e  f1000208          ADD      r2,r0,#8              ;2806
000622  6841              LDR      r1,[r0,#4]            ;2806
000624  6849              LDR      r1,[r1,#4]            ;2806
000626  6041              STR      r1,[r0,#4]            ;2806
000628  4291              CMP      r1,r2                 ;2806
00062a  d101              BNE      |L1.1584|
00062c  6849              LDR      r1,[r1,#4]            ;2806
00062e  6041              STR      r1,[r0,#4]            ;2806
                  |L1.1584|
000630  68c8              LDR      r0,[r1,#0xc]          ;2806
000632  6028              STR      r0,[r5,#0]            ;2806  ; pxCurrentTCB
000634  bd70              POP      {r4-r6,pc}
;;;2818   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSuspend PROC
;;;1565   
;;;1566   	void vTaskSuspend( TaskHandle_t xTaskToSuspend )
000636  b570              PUSH     {r4-r6,lr}
;;;1567   	{
000638  4604              MOV      r4,r0
;;;1568   	TCB_t *pxTCB;
;;;1569   
;;;1570   		taskENTER_CRITICAL();
00063a  f7fffffe          BL       vPortEnterCritical
;;;1571   		{
;;;1572   			/* If null is passed in here then it is the running task that is
;;;1573   			being suspended. */
;;;1574   			pxTCB = prvGetTCBFromHandle( xTaskToSuspend );
00063e  4d83              LDR      r5,|L1.2124|
000640  b904              CBNZ     r4,|L1.1604|
000642  682c              LDR      r4,[r5,#0]  ; pxCurrentTCB
                  |L1.1604|
;;;1575   
;;;1576   			traceTASK_SUSPEND( pxTCB );
;;;1577   
;;;1578   			/* Remove task from the ready/delayed list and place in the
;;;1579   			suspended list. */
;;;1580   			if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000644  1d20              ADDS     r0,r4,#4
000646  f7fffffe          BL       uxListRemove
00064a  b958              CBNZ     r0,|L1.1636|
;;;1581   			{
;;;1582   				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
00064c  6ae0              LDR      r0,[r4,#0x2c]
00064e  4a82              LDR      r2,|L1.2136|
000650  eb000180          ADD      r1,r0,r0,LSL #2
000654  f8521021          LDR      r1,[r2,r1,LSL #2]
000658  b921              CBNZ     r1,|L1.1636|
00065a  2101              MOVS     r1,#1
00065c  4081              LSLS     r1,r1,r0
00065e  6928              LDR      r0,[r5,#0x10]  ; uxTopReadyPriority
000660  4388              BICS     r0,r0,r1
000662  6128              STR      r0,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.1636|
;;;1583   			}
;;;1584   			else
;;;1585   			{
;;;1586   				mtCOVERAGE_TEST_MARKER();
;;;1587   			}
;;;1588   
;;;1589   			/* Is the task waiting on an event also? */
;;;1590   			if( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) != NULL )
000664  6aa0              LDR      r0,[r4,#0x28]
000666  b118              CBZ      r0,|L1.1648|
;;;1591   			{
;;;1592   				( void ) uxListRemove( &( pxTCB->xEventListItem ) );
000668  f1040018          ADD      r0,r4,#0x18
00066c  f7fffffe          BL       uxListRemove
                  |L1.1648|
;;;1593   			}
;;;1594   			else
;;;1595   			{
;;;1596   				mtCOVERAGE_TEST_MARKER();
;;;1597   			}
;;;1598   
;;;1599   			vListInsertEnd( &xSuspendedTaskList, &( pxTCB->xStateListItem ) );
000670  1d21              ADDS     r1,r4,#4
000672  4878              LDR      r0,|L1.2132|
000674  f7fffffe          BL       vListInsertEnd
;;;1600   		}
;;;1601   		taskEXIT_CRITICAL();
000678  f7fffffe          BL       vPortExitCritical
;;;1602   
;;;1603   		if( xSchedulerRunning != pdFALSE )
00067c  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
00067e  b128              CBZ      r0,|L1.1676|
;;;1604   		{
;;;1605   			/* Reset the next expected unblock time in case it referred to the
;;;1606   			task that is now in the Suspended state. */
;;;1607   			taskENTER_CRITICAL();
000680  f7fffffe          BL       vPortEnterCritical
;;;1608   			{
;;;1609   				prvResetNextTaskUnblockTime();
000684  f7fffffe          BL       prvResetNextTaskUnblockTime
;;;1610   			}
;;;1611   			taskEXIT_CRITICAL();
000688  f7fffffe          BL       vPortExitCritical
                  |L1.1676|
;;;1612   		}
;;;1613   		else
;;;1614   		{
;;;1615   			mtCOVERAGE_TEST_MARKER();
;;;1616   		}
;;;1617   
;;;1618   		if( pxTCB == pxCurrentTCB )
00068c  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00068e  4284              CMP      r4,r0
000690  d113              BNE      |L1.1722|
;;;1619   		{
;;;1620   			if( xSchedulerRunning != pdFALSE )
000692  6968              LDR      r0,[r5,#0x14]  ; xSchedulerRunning
000694  b190              CBZ      r0,|L1.1724|
;;;1621   			{
;;;1622   				/* The current task has just been suspended. */
;;;1623   				configASSERT( uxSchedulerSuspended == 0 );
000696  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000698  b138              CBZ      r0,|L1.1706|
00069a  f2406257          MOV      r2,#0x657
00069e  f2af218c          ADR      r1,|L1.1044|
0006a2  f2af2074          ADR      r0,|L1.1072|
0006a6  f7fffffe          BL       __2printf
                  |L1.1706|
;;;1624   				portYIELD_WITHIN_API();
0006aa  4969              LDR      r1,|L1.2128|
0006ac  f04f5080          MOV      r0,#0x10000000
0006b0  6008              STR      r0,[r1,#0]
0006b2  f3bf8f4f          DSB      
0006b6  f3bf8f6f          ISB      
                  |L1.1722|
;;;1625   			}
;;;1626   			else
;;;1627   			{
;;;1628   				/* The scheduler is not running, but the task that was pointed
;;;1629   				to by pxCurrentTCB has just been suspended and pxCurrentTCB
;;;1630   				must be adjusted to point to a different task. */
;;;1631   				if( listCURRENT_LIST_LENGTH( &xSuspendedTaskList ) == uxCurrentNumberOfTasks )
;;;1632   				{
;;;1633   					/* No other tasks are ready, so set pxCurrentTCB back to
;;;1634   					NULL so when the next task is created pxCurrentTCB will
;;;1635   					be set to point to it no matter what its relative priority
;;;1636   					is. */
;;;1637   					pxCurrentTCB = NULL;
;;;1638   				}
;;;1639   				else
;;;1640   				{
;;;1641   					vTaskSwitchContext();
;;;1642   				}
;;;1643   			}
;;;1644   		}
;;;1645   		else
;;;1646   		{
;;;1647   			mtCOVERAGE_TEST_MARKER();
;;;1648   		}
;;;1649   	}
0006ba  bd70              POP      {r4-r6,pc}
                  |L1.1724|
0006bc  4865              LDR      r0,|L1.2132|
0006be  68a9              LDR      r1,[r5,#8]            ;1631  ; uxCurrentNumberOfTasks
0006c0  6800              LDR      r0,[r0,#0]            ;1631  ; xSuspendedTaskList
0006c2  4288              CMP      r0,r1                 ;1631
0006c4  d102              BNE      |L1.1740|
0006c6  2000              MOVS     r0,#0                 ;1637
0006c8  6028              STR      r0,[r5,#0]            ;1637  ; pxCurrentTCB
0006ca  bd70              POP      {r4-r6,pc}
                  |L1.1740|
0006cc  e8bd4070          POP      {r4-r6,lr}            ;1641
0006d0  e7fe              B        vTaskSwitchContext
;;;1650   
                          ENDP

                  prvTaskIsTaskSuspended PROC
;;;1655   
;;;1656   	static BaseType_t prvTaskIsTaskSuspended( const TaskHandle_t xTask )
0006d2  b570              PUSH     {r4-r6,lr}
;;;1657   	{
;;;1658   	BaseType_t xReturn = pdFALSE;
0006d4  2500              MOVS     r5,#0
;;;1659   	const TCB_t * const pxTCB = ( TCB_t * ) xTask;
0006d6  0004              MOVS     r4,r0
0006d8  d107              BNE      |L1.1770|
;;;1660   
;;;1661   		/* Accesses xPendingReadyList so must be called from a critical
;;;1662   		section. */
;;;1663   
;;;1664   		/* It does not make sense to check if the calling task is suspended. */
;;;1665   		configASSERT( xTask );
0006da  f2406281          MOV      r2,#0x681
0006de  f2af21cc          ADR      r1,|L1.1044|
0006e2  f2af20b4          ADR      r0,|L1.1072|
0006e6  f7fffffe          BL       __2printf
                  |L1.1770|
;;;1666   
;;;1667   		/* Is the task being resumed actually in the suspended list? */
;;;1668   		if( listIS_CONTAINED_WITHIN( &xSuspendedTaskList, &( pxTCB->xStateListItem ) ) != pdFALSE )
0006ea  495a              LDR      r1,|L1.2132|
0006ec  6960              LDR      r0,[r4,#0x14]
0006ee  4288              CMP      r0,r1
0006f0  d105              BNE      |L1.1790|
;;;1669   		{
;;;1670   			/* Has the task already been resumed from within an ISR? */
;;;1671   			if( listIS_CONTAINED_WITHIN( &xPendingReadyList, &( pxTCB->xEventListItem ) ) == pdFALSE )
0006f2  6aa0              LDR      r0,[r4,#0x28]
0006f4  3928              SUBS     r1,r1,#0x28
0006f6  4288              CMP      r0,r1
0006f8  d001              BEQ      |L1.1790|
;;;1672   			{
;;;1673   				/* Is it in the suspended list because it is in the	Suspended
;;;1674   				state, or because is is blocked with no timeout? */
;;;1675   				if( listIS_CONTAINED_WITHIN( NULL, &( pxTCB->xEventListItem ) ) != pdFALSE )
0006fa  b900              CBNZ     r0,|L1.1790|
;;;1676   				{
;;;1677   					xReturn = pdTRUE;
0006fc  2501              MOVS     r5,#1
                  |L1.1790|
;;;1678   				}
;;;1679   				else
;;;1680   				{
;;;1681   					mtCOVERAGE_TEST_MARKER();
;;;1682   				}
;;;1683   			}
;;;1684   			else
;;;1685   			{
;;;1686   				mtCOVERAGE_TEST_MARKER();
;;;1687   			}
;;;1688   		}
;;;1689   		else
;;;1690   		{
;;;1691   			mtCOVERAGE_TEST_MARKER();
;;;1692   		}
;;;1693   
;;;1694   		return xReturn;
0006fe  4628              MOV      r0,r5
;;;1695   	} /*lint !e818 xTask cannot be a pointer to const because it is a typedef. */
000700  bd70              POP      {r4-r6,pc}
;;;1696   
                          ENDP

                  vTaskResume PROC
;;;1701   
;;;1702   	void vTaskResume( TaskHandle_t xTaskToResume )
000702  b570              PUSH     {r4-r6,lr}
;;;1703   	{
;;;1704   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
000704  0004              MOVS     r4,r0
000706  d02b              BEQ      |L1.1888|
;;;1705   
;;;1706   		/* It does not make sense to resume the calling task. */
;;;1707   		configASSERT( xTaskToResume );
;;;1708   
;;;1709   		/* The parameter cannot be NULL as it is impossible to resume the
;;;1710   		currently executing task. */
;;;1711   		if( ( pxTCB != NULL ) && ( pxTCB != pxCurrentTCB ) )
000708  4d50              LDR      r5,|L1.2124|
00070a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
00070c  4284              CMP      r4,r0
00070e  d031              BEQ      |L1.1908|
;;;1712   		{
;;;1713   			taskENTER_CRITICAL();
000710  f7fffffe          BL       vPortEnterCritical
;;;1714   			{
;;;1715   				if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
000714  4620              MOV      r0,r4
000716  f7fffffe          BL       prvTaskIsTaskSuspended
00071a  b1e8              CBZ      r0,|L1.1880|
;;;1716   				{
;;;1717   					traceTASK_RESUME( pxTCB );
;;;1718   
;;;1719   					/* As we are in a critical section we can access the ready
;;;1720   					lists even if the scheduler is suspended. */
;;;1721   					( void ) uxListRemove(  &( pxTCB->xStateListItem ) );
00071c  1d20              ADDS     r0,r4,#4
00071e  f7fffffe          BL       uxListRemove
;;;1722   					prvAddTaskToReadyList( pxTCB );
000722  6ae0              LDR      r0,[r4,#0x2c]
000724  2101              MOVS     r1,#1
000726  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000728  4081              LSLS     r1,r1,r0
00072a  4311              ORRS     r1,r1,r2
00072c  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
00072e  494a              LDR      r1,|L1.2136|
000730  eb000080          ADD      r0,r0,r0,LSL #2
000734  eb010080          ADD      r0,r1,r0,LSL #2
000738  1d21              ADDS     r1,r4,#4
00073a  f7fffffe          BL       vListInsertEnd
;;;1723   
;;;1724   					/* We may have just resumed a higher priority task. */
;;;1725   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
00073e  6ae0              LDR      r0,[r4,#0x2c]
000740  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000742  6ac9              LDR      r1,[r1,#0x2c]
000744  4288              CMP      r0,r1
000746  d307              BCC      |L1.1880|
;;;1726   					{
;;;1727   						/* This yield may not cause the task just resumed to run,
;;;1728   						but will leave the lists in the correct state for the
;;;1729   						next yield. */
;;;1730   						taskYIELD_IF_USING_PREEMPTION();
000748  4941              LDR      r1,|L1.2128|
00074a  f04f5080          MOV      r0,#0x10000000
00074e  6008              STR      r0,[r1,#0]
000750  f3bf8f4f          DSB      
000754  f3bf8f6f          ISB      
                  |L1.1880|
;;;1731   					}
;;;1732   					else
;;;1733   					{
;;;1734   						mtCOVERAGE_TEST_MARKER();
;;;1735   					}
;;;1736   				}
;;;1737   				else
;;;1738   				{
;;;1739   					mtCOVERAGE_TEST_MARKER();
;;;1740   				}
;;;1741   			}
;;;1742   			taskEXIT_CRITICAL();
000758  e8bd4070          POP      {r4-r6,lr}
00075c  f7ffbffe          B.W      vPortExitCritical
                  |L1.1888|
000760  f24062ab          MOV      r2,#0x6ab             ;1707
000764  f2af3154          ADR      r1,|L1.1044|
000768  f2af303c          ADR      r0,|L1.1072|
00076c  e8bd4070          POP      {r4-r6,lr}            ;1707
000770  f7ffbffe          B.W      __2printf
                  |L1.1908|
;;;1743   		}
;;;1744   		else
;;;1745   		{
;;;1746   			mtCOVERAGE_TEST_MARKER();
;;;1747   		}
;;;1748   	}
000774  bd70              POP      {r4-r6,pc}
;;;1749   
                          ENDP

                  xTaskResumeFromISR PROC
;;;1755   
;;;1756   	BaseType_t xTaskResumeFromISR( TaskHandle_t xTaskToResume )
000776  e92d41f0          PUSH     {r4-r8,lr}
;;;1757   	{
;;;1758   	BaseType_t xYieldRequired = pdFALSE;
00077a  2600              MOVS     r6,#0
;;;1759   	TCB_t * const pxTCB = ( TCB_t * ) xTaskToResume;
00077c  0004              MOVS     r4,r0
00077e  d107              BNE      |L1.1936|
;;;1760   	UBaseType_t uxSavedInterruptStatus;
;;;1761   
;;;1762   		configASSERT( xTaskToResume );
000780  f24062e2          MOV      r2,#0x6e2
000784  f2af3174          ADR      r1,|L1.1044|
000788  f2af305c          ADR      r0,|L1.1072|
00078c  f7fffffe          BL       __2printf
                  |L1.1936|
;;;1763   
;;;1764   		/* RTOS ports that support interrupt nesting have the concept of a
;;;1765   		maximum	system call (or maximum API call) interrupt priority.
;;;1766   		Interrupts that are	above the maximum system call priority are keep
;;;1767   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;1768   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;1769   		is defined in FreeRTOSConfig.h then
;;;1770   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;1771   		failure if a FreeRTOS API function is called from an interrupt that has
;;;1772   		been assigned a priority above the configured maximum system call
;;;1773   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;1774   		from interrupts	that have been assigned a priority at or (logically)
;;;1775   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;1776   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;1777   		simple as possible.  More information (albeit Cortex-M specific) is
;;;1778   		provided on the following link:
;;;1779   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;1780   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000790  f7fffffe          BL       vPortValidateInterruptPriority
000794  2050              MOVS     r0,#0x50
000796  f3ef8511          MRS      r5,BASEPRI
00079a  f3808811          MSR      BASEPRI,r0
00079e  f3bf8f4f          DSB      
0007a2  f3bf8f6f          ISB      
;;;1781   
;;;1782   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;1783   		{
;;;1784   			if( prvTaskIsTaskSuspended( pxTCB ) != pdFALSE )
0007a6  4620              MOV      r0,r4
0007a8  f7fffffe          BL       prvTaskIsTaskSuspended
0007ac  b1f0              CBZ      r0,|L1.2028|
;;;1785   			{
;;;1786   				traceTASK_RESUME_FROM_ISR( pxTCB );
;;;1787   
;;;1788   				/* Check the ready lists can be accessed. */
;;;1789   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
0007ae  4f27              LDR      r7,|L1.2124|
0007b0  6b38              LDR      r0,[r7,#0x30]  ; uxSchedulerSuspended
0007b2  b120              CBZ      r0,|L1.1982|
;;;1790   				{
;;;1791   					/* Ready lists can be accessed so move the task from the
;;;1792   					suspended list to the ready list directly. */
;;;1793   					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
;;;1794   					{
;;;1795   						xYieldRequired = pdTRUE;
;;;1796   					}
;;;1797   					else
;;;1798   					{
;;;1799   						mtCOVERAGE_TEST_MARKER();
;;;1800   					}
;;;1801   
;;;1802   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;1803   					prvAddTaskToReadyList( pxTCB );
;;;1804   				}
;;;1805   				else
;;;1806   				{
;;;1807   					/* The delayed or ready lists cannot be accessed so the task
;;;1808   					is held in the pending ready list until the scheduler is
;;;1809   					unsuspended. */
;;;1810   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
0007b4  4827              LDR      r0,|L1.2132|
0007b6  f1040118          ADD      r1,r4,#0x18
0007ba  3828              SUBS     r0,r0,#0x28
0007bc  e014              B        |L1.2024|
                  |L1.1982|
0007be  6ae0              LDR      r0,[r4,#0x2c]         ;1793
0007c0  6839              LDR      r1,[r7,#0]            ;1793  ; pxCurrentTCB
0007c2  6ac9              LDR      r1,[r1,#0x2c]         ;1793
0007c4  4288              CMP      r0,r1                 ;1793
0007c6  d300              BCC      |L1.1994|
0007c8  2601              MOVS     r6,#1                 ;1795
                  |L1.1994|
0007ca  1d20              ADDS     r0,r4,#4              ;1802
0007cc  f7fffffe          BL       uxListRemove
0007d0  6ae0              LDR      r0,[r4,#0x2c]         ;1803
0007d2  2101              MOVS     r1,#1                 ;1803
0007d4  693a              LDR      r2,[r7,#0x10]         ;1803  ; uxTopReadyPriority
0007d6  4081              LSLS     r1,r1,r0              ;1803
0007d8  4311              ORRS     r1,r1,r2              ;1803
0007da  6139              STR      r1,[r7,#0x10]         ;1803  ; uxTopReadyPriority
0007dc  491e              LDR      r1,|L1.2136|
0007de  eb000080          ADD      r0,r0,r0,LSL #2       ;1803
0007e2  eb010080          ADD      r0,r1,r0,LSL #2       ;1803
0007e6  1d21              ADDS     r1,r4,#4              ;1803
                  |L1.2024|
0007e8  f7fffffe          BL       vListInsertEnd
                  |L1.2028|
0007ec  f3858811          MSR      BASEPRI,r5            ;1803
;;;1811   				}
;;;1812   			}
;;;1813   			else
;;;1814   			{
;;;1815   				mtCOVERAGE_TEST_MARKER();
;;;1816   			}
;;;1817   		}
;;;1818   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;1819   
;;;1820   		return xYieldRequired;
0007f0  4630              MOV      r0,r6
                  |L1.2034|
;;;1821   	}
0007f2  e462              B        |L1.186|
;;;1822   
                          ENDP

                  prvIdleTask PROC
;;;3130    */
;;;3131   static portTASK_FUNCTION( prvIdleTask, pvParameters )
0007f4  4e18              LDR      r6,|L1.2136|
;;;3132   {
;;;3133   	/* Stop warnings. */
;;;3134   	( void ) pvParameters;
;;;3135   
;;;3136   	/** THIS IS THE RTOS IDLE TASK - WHICH IS CREATED AUTOMATICALLY WHEN THE
;;;3137   	SCHEDULER IS STARTED. **/
;;;3138   
;;;3139   	for( ;; )
;;;3140   	{
;;;3141   		/* See if any tasks have deleted themselves - if so then the idle task
;;;3142   		is responsible for freeing the deleted task's TCB and stack. */
;;;3143   		prvCheckTasksWaitingTermination();
;;;3144   
;;;3145   		#if ( configUSE_PREEMPTION == 0 )
;;;3146   		{
;;;3147   			/* If we are not using preemption we keep forcing a task switch to
;;;3148   			see if any other task has become available.  If we are using
;;;3149   			preemption we don't need to do this as any task becoming available
;;;3150   			will automatically get the processor anyway. */
;;;3151   			taskYIELD();
;;;3152   		}
;;;3153   		#endif /* configUSE_PREEMPTION */
;;;3154   
;;;3155   		#if ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) )
;;;3156   		{
;;;3157   			/* When using preemption tasks of equal priority will be
;;;3158   			timesliced.  If a task that is sharing the idle priority is ready
;;;3159   			to run then the idle task should yield before the end of the
;;;3160   			timeslice.
;;;3161   
;;;3162   			A critical region is not required here as we are just reading from
;;;3163   			the list, and an occasional incorrect value will not matter.  If
;;;3164   			the ready list at the idle priority contains more than one task
;;;3165   			then a task other than the idle task is ready to execute. */
;;;3166   			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( UBaseType_t ) 1 )
;;;3167   			{
;;;3168   				taskYIELD();
0007f6  f04f5480          MOV      r4,#0x10000000
0007fa  4d15              LDR      r5,|L1.2128|
                  |L1.2044|
0007fc  f7fffffe          BL       prvCheckTasksWaitingTermination
000800  6830              LDR      r0,[r6,#0]            ;3166  ; pxReadyTasksLists
000802  2801              CMP      r0,#1                 ;3166
000804  d9fa              BLS      |L1.2044|
000806  602c              STR      r4,[r5,#0]
000808  f3bf8f4f          DSB      
00080c  f3bf8f6f          ISB      
000810  e7f4              B        |L1.2044|
;;;3169   			}
;;;3170   			else
;;;3171   			{
;;;3172   				mtCOVERAGE_TEST_MARKER();
;;;3173   			}
;;;3174   		}
;;;3175   		#endif /* ( ( configUSE_PREEMPTION == 1 ) && ( configIDLE_SHOULD_YIELD == 1 ) ) */
;;;3176   
;;;3177   		#if ( configUSE_IDLE_HOOK == 1 )
;;;3178   		{
;;;3179   			extern void vApplicationIdleHook( void );
;;;3180   
;;;3181   			/* Call the user defined function from within the idle task.  This
;;;3182   			allows the application designer to add background functionality
;;;3183   			without the overhead of a separate task.
;;;3184   			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
;;;3185   			CALL A FUNCTION THAT MIGHT BLOCK. */
;;;3186   			vApplicationIdleHook();
;;;3187   		}
;;;3188   		#endif /* configUSE_IDLE_HOOK */
;;;3189   
;;;3190   		/* This conditional compilation should use inequality to 0, not equality
;;;3191   		to 1.  This is to ensure portSUPPRESS_TICKS_AND_SLEEP() is called when
;;;3192   		user defined low power mode	implementations require
;;;3193   		configUSE_TICKLESS_IDLE to be set to a value other than 1. */
;;;3194   		#if ( configUSE_TICKLESS_IDLE != 0 )
;;;3195   		{
;;;3196   		TickType_t xExpectedIdleTime;
;;;3197   
;;;3198   			/* It is not desirable to suspend then resume the scheduler on
;;;3199   			each iteration of the idle task.  Therefore, a preliminary
;;;3200   			test of the expected idle time is performed without the
;;;3201   			scheduler suspended.  The result here is not necessarily
;;;3202   			valid. */
;;;3203   			xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3204   
;;;3205   			if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3206   			{
;;;3207   				vTaskSuspendAll();
;;;3208   				{
;;;3209   					/* Now the scheduler is suspended, the expected idle
;;;3210   					time can be sampled again, and this time its value can
;;;3211   					be used. */
;;;3212   					configASSERT( xNextTaskUnblockTime >= xTickCount );
;;;3213   					xExpectedIdleTime = prvGetExpectedIdleTime();
;;;3214   
;;;3215   					if( xExpectedIdleTime >= configEXPECTED_IDLE_TIME_BEFORE_SLEEP )
;;;3216   					{
;;;3217   						traceLOW_POWER_IDLE_BEGIN();
;;;3218   						portSUPPRESS_TICKS_AND_SLEEP( xExpectedIdleTime );
;;;3219   						traceLOW_POWER_IDLE_END();
;;;3220   					}
;;;3221   					else
;;;3222   					{
;;;3223   						mtCOVERAGE_TEST_MARKER();
;;;3224   					}
;;;3225   				}
;;;3226   				( void ) xTaskResumeAll();
;;;3227   			}
;;;3228   			else
;;;3229   			{
;;;3230   				mtCOVERAGE_TEST_MARKER();
;;;3231   			}
;;;3232   		}
;;;3233   		#endif /* configUSE_TICKLESS_IDLE */
;;;3234   	}
;;;3235   }
;;;3236   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskStartScheduler PROC
;;;1825   
;;;1826   void vTaskStartScheduler( void )
000812  b51c              PUSH     {r2-r4,lr}
;;;1827   {
;;;1828   BaseType_t xReturn;
;;;1829   
;;;1830   	/* Add the idle task at the lowest priority. */
;;;1831   	#if( configSUPPORT_STATIC_ALLOCATION == 1 )
;;;1832   	{
;;;1833   		StaticTask_t *pxIdleTaskTCBBuffer = NULL;
;;;1834   		StackType_t *pxIdleTaskStackBuffer = NULL;
;;;1835   		uint32_t ulIdleTaskStackSize;
;;;1836   
;;;1837   		/* The Idle task is created using user provided RAM - obtain the
;;;1838   		address of the RAM then create the idle task. */
;;;1839   		vApplicationGetIdleTaskMemory( &pxIdleTaskTCBBuffer, &pxIdleTaskStackBuffer, &ulIdleTaskStackSize );
;;;1840   		xIdleTaskHandle = xTaskCreateStatic(	prvIdleTask,
;;;1841   												"IDLE",
;;;1842   												ulIdleTaskStackSize,
;;;1843   												( void * ) NULL,
;;;1844   												( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1845   												pxIdleTaskStackBuffer,
;;;1846   												pxIdleTaskTCBBuffer ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1847   
;;;1848   		if( xIdleTaskHandle != NULL )
;;;1849   		{
;;;1850   			xReturn = pdPASS;
;;;1851   		}
;;;1852   		else
;;;1853   		{
;;;1854   			xReturn = pdFAIL;
;;;1855   		}
;;;1856   	}
;;;1857   	#else
;;;1858   	{
;;;1859   		/* The Idle task is being created using dynamically allocated RAM. */
;;;1860   		xReturn = xTaskCreate(	prvIdleTask,
000814  480d              LDR      r0,|L1.2124|
000816  2400              MOVS     r4,#0
000818  302c              ADDS     r0,r0,#0x2c
00081a  e9cd4000          STRD     r4,r0,[sp,#0]
00081e  4623              MOV      r3,r4
000820  2280              MOVS     r2,#0x80
000822  a10e              ADR      r1,|L1.2140|
000824  480f              LDR      r0,|L1.2148|
000826  f7fffffe          BL       xTaskCreate
;;;1861   								"IDLE", configMINIMAL_STACK_SIZE,
;;;1862   								( void * ) NULL,
;;;1863   								( tskIDLE_PRIORITY | portPRIVILEGE_BIT ),
;;;1864   								&xIdleTaskHandle ); /*lint !e961 MISRA exception, justified as it is not a redundant explicit cast to all supported compilers. */
;;;1865   	}
;;;1866   	#endif /* configSUPPORT_STATIC_ALLOCATION */
;;;1867   
;;;1868   	#if ( configUSE_TIMERS == 1 )
;;;1869   	{
;;;1870   		if( xReturn == pdPASS )
;;;1871   		{
;;;1872   			xReturn = xTimerCreateTimerTask();
;;;1873   		}
;;;1874   		else
;;;1875   		{
;;;1876   			mtCOVERAGE_TEST_MARKER();
;;;1877   		}
;;;1878   	}
;;;1879   	#endif /* configUSE_TIMERS */
;;;1880   
;;;1881   	if( xReturn == pdPASS )
00082a  2801              CMP      r0,#1
00082c  d00c              BEQ      |L1.2120|
00082e  1c40              ADDS     r0,r0,#1
;;;1882   	{
;;;1883   		/* Interrupts are turned off here, to ensure a tick does not occur
;;;1884   		before or during the call to xPortStartScheduler().  The stacks of
;;;1885   		the created tasks contain a status word with interrupts switched on
;;;1886   		so interrupts will automatically get re-enabled when the first task
;;;1887   		starts to run. */
;;;1888   		portDISABLE_INTERRUPTS();
;;;1889   
;;;1890   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;1891   		{
;;;1892   			/* Switch Newlib's _impure_ptr variable to point to the _reent
;;;1893   			structure specific to the task that will run first. */
;;;1894   			_impure_ptr = &( pxCurrentTCB->xNewLib_reent );
;;;1895   		}
;;;1896   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;1897   
;;;1898   		xNextTaskUnblockTime = portMAX_DELAY;
;;;1899   		xSchedulerRunning = pdTRUE;
;;;1900   		xTickCount = ( TickType_t ) 0U;
;;;1901   
;;;1902   		/* If configGENERATE_RUN_TIME_STATS is defined then the following
;;;1903   		macro must be defined to configure the timer/counter used to generate
;;;1904   		the run time counter time base. */
;;;1905   		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();
;;;1906   
;;;1907   		/* Setting up the timer tick is hardware specific and thus in the
;;;1908   		portable interface. */
;;;1909   		if( xPortStartScheduler() != pdFALSE )
;;;1910   		{
;;;1911   			/* Should not reach here as if the scheduler is running the
;;;1912   			function will not return. */
;;;1913   		}
;;;1914   		else
;;;1915   		{
;;;1916   			/* Should only reach here if a task calls xTaskEndScheduler(). */
;;;1917   		}
;;;1918   	}
;;;1919   	else
;;;1920   	{
;;;1921   		/* This line will only be reached if the kernel could not be started,
;;;1922   		because there was not enough FreeRTOS heap to create the idle task
;;;1923   		or the timer task. */
;;;1924   		configASSERT( xReturn != errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY );
000830  d12b              BNE      |L1.2186|
000832  f2407284          MOV      r2,#0x784
000836  f2af4124          ADR      r1,|L1.1044|
00083a  f2af400c          ADR      r0,|L1.1072|
00083e  b002              ADD      sp,sp,#8
000840  e8bd4010          POP      {r4,lr}
000844  f7ffbffe          B.W      __2printf
                  |L1.2120|
000848  2050              MOVS     r0,#0x50
00084a  e00d              B        |L1.2152|
                  |L1.2124|
                          DCD      ||.data||
                  |L1.2128|
                          DCD      0xe000ed04
                  |L1.2132|
                          DCD      ||.bss||+0x2d0
                  |L1.2136|
                          DCD      ||.bss||
                  |L1.2140|
00085c  49444c45          DCB      "IDLE",0
000860  00      
000861  00                DCB      0
000862  00                DCB      0
000863  00                DCB      0
                  |L1.2148|
                          DCD      prvIdleTask
                  |L1.2152|
000868  f3808811          MSR      BASEPRI,r0
00086c  f3bf8f4f          DSB      
000870  f3bf8f6f          ISB      
000874  48fb              LDR      r0,|L1.3172|
000876  f04f31ff          MOV      r1,#0xffffffff        ;1898
00087a  6281              STR      r1,[r0,#0x28]         ;1898  ; xNextTaskUnblockTime
00087c  2101              MOVS     r1,#1                 ;1899
00087e  6141              STR      r1,[r0,#0x14]         ;1899  ; xSchedulerRunning
000880  60c4              STR      r4,[r0,#0xc]          ;1900  ; xTickCount
000882  e8bd401c          POP      {r2-r4,lr}            ;1909
000886  f7ffbffe          B.W      xPortStartScheduler
                  |L1.2186|
;;;1925   	}
;;;1926   
;;;1927   	/* Prevent compiler warnings if INCLUDE_xTaskGetIdleTaskHandle is set to 0,
;;;1928   	meaning xIdleTaskHandle is not used anywhere else. */
;;;1929   	( void ) xIdleTaskHandle;
;;;1930   }
00088a  bd1c              POP      {r2-r4,pc}
;;;1931   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskEndScheduler PROC
;;;1932   
;;;1933   void vTaskEndScheduler( void )
00088c  2050              MOVS     r0,#0x50
00088e  f3808811          MSR      BASEPRI,r0
000892  f3bf8f4f          DSB      
000896  f3bf8f6f          ISB      
;;;1934   {
;;;1935   	/* Stop the scheduler interrupts and call the portable scheduler end
;;;1936   	routine so the original ISRs can be restored if necessary.  The port
;;;1937   	layer must ensure interrupts enable	bit is left in the correct state. */
;;;1938   	portDISABLE_INTERRUPTS();
;;;1939   	xSchedulerRunning = pdFALSE;
00089a  49f2              LDR      r1,|L1.3172|
00089c  2000              MOVS     r0,#0
00089e  6148              STR      r0,[r1,#0x14]  ; xSchedulerRunning
;;;1940   	vPortEndScheduler();
0008a0  f7ffbffe          B.W      vPortEndScheduler
;;;1941   }
;;;1942   /*----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCount PROC
;;;2126   
;;;2127   TickType_t xTaskGetTickCount( void )
0008a4  48ef              LDR      r0,|L1.3172|
;;;2128   {
;;;2129   TickType_t xTicks;
;;;2130   
;;;2131   	/* Critical section required if running on a 16 bit processor. */
;;;2132   	portTICK_TYPE_ENTER_CRITICAL();
;;;2133   	{
;;;2134   		xTicks = xTickCount;
0008a6  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2135   	}
;;;2136   	portTICK_TYPE_EXIT_CRITICAL();
;;;2137   
;;;2138   	return xTicks;
;;;2139   }
0008a8  4770              BX       lr
;;;2140   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetTickCountFromISR PROC
;;;2141   
;;;2142   TickType_t xTaskGetTickCountFromISR( void )
0008aa  b510              PUSH     {r4,lr}
;;;2143   {
;;;2144   TickType_t xReturn;
;;;2145   UBaseType_t uxSavedInterruptStatus;
;;;2146   
;;;2147   	/* RTOS ports that support interrupt nesting have the concept of a maximum
;;;2148   	system call (or maximum API call) interrupt priority.  Interrupts that are
;;;2149   	above the maximum system call priority are kept permanently enabled, even
;;;2150   	when the RTOS kernel is in a critical section, but cannot make any calls to
;;;2151   	FreeRTOS API functions.  If configASSERT() is defined in FreeRTOSConfig.h
;;;2152   	then portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;2153   	failure if a FreeRTOS API function is called from an interrupt that has been
;;;2154   	assigned a priority above the configured maximum system call priority.
;;;2155   	Only FreeRTOS functions that end in FromISR can be called from interrupts
;;;2156   	that have been assigned a priority at or (logically) below the maximum
;;;2157   	system call	interrupt priority.  FreeRTOS maintains a separate interrupt
;;;2158   	safe API to ensure interrupt entry is as fast and as simple as possible.
;;;2159   	More information (albeit Cortex-M specific) is provided on the following
;;;2160   	link: http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;2161   	portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
0008ac  f7fffffe          BL       vPortValidateInterruptPriority
;;;2162   
;;;2163   	uxSavedInterruptStatus = portTICK_TYPE_SET_INTERRUPT_MASK_FROM_ISR();
;;;2164   	{
;;;2165   		xReturn = xTickCount;
0008b0  48ec              LDR      r0,|L1.3172|
0008b2  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
;;;2166   	}
;;;2167   	portTICK_TYPE_CLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;2168   
;;;2169   	return xReturn;
;;;2170   }
0008b4  bd10              POP      {r4,pc}
;;;2171   /*-----------------------------------------------------------*/
                          ENDP

                  uxTaskGetNumberOfTasks PROC
;;;2172   
;;;2173   UBaseType_t uxTaskGetNumberOfTasks( void )
0008b6  48eb              LDR      r0,|L1.3172|
;;;2174   {
;;;2175   	/* A critical section is not required because the variables are of type
;;;2176   	BaseType_t. */
;;;2177   	return uxCurrentNumberOfTasks;
0008b8  6880              LDR      r0,[r0,#8]  ; uxCurrentNumberOfTasks
;;;2178   }
0008ba  4770              BX       lr
;;;2179   /*-----------------------------------------------------------*/
                          ENDP

                  pcTaskGetName PROC
;;;2180   
;;;2181   char *pcTaskGetName( TaskHandle_t xTaskToQuery ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
0008bc  b510              PUSH     {r4,lr}
;;;2182   {
0008be  b110              CBZ      r0,|L1.2246|
;;;2183   TCB_t *pxTCB;
;;;2184   
;;;2185   	/* If null is passed in here then the name of the calling task is being
;;;2186   	queried. */
;;;2187   	pxTCB = prvGetTCBFromHandle( xTaskToQuery );
0008c0  4604              MOV      r4,r0
                  |L1.2242|
;;;2188   	configASSERT( pxTCB );
0008c2  b11c              CBZ      r4,|L1.2252|
0008c4  e00a              B        |L1.2268|
                  |L1.2246|
0008c6  48e7              LDR      r0,|L1.3172|
0008c8  6804              LDR      r4,[r0,#0]            ;2187  ; pxCurrentTCB
0008ca  e7fa              B        |L1.2242|
                  |L1.2252|
0008cc  f640028c          MOV      r2,#0x88c
0008d0  f2af41c0          ADR      r1,|L1.1044|
0008d4  f2af40a8          ADR      r0,|L1.1072|
0008d8  f7fffffe          BL       __2printf
                  |L1.2268|
;;;2189   	return &( pxTCB->pcTaskName[ 0 ] );
0008dc  f1040034          ADD      r0,r4,#0x34
;;;2190   }
0008e0  bd10              POP      {r4,pc}
;;;2191   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnEventList PROC
;;;2819   
;;;2820   void vTaskPlaceOnEventList( List_t * const pxEventList, const TickType_t xTicksToWait )
0008e2  b570              PUSH     {r4-r6,lr}
;;;2821   {
0008e4  460d              MOV      r5,r1
0008e6  0004              MOVS     r4,r0
0008e8  d107              BNE      |L1.2298|
;;;2822   	configASSERT( pxEventList );
0008ea  f6403206          MOV      r2,#0xb06
0008ee  f2af41dc          ADR      r1,|L1.1044|
0008f2  f2af40c4          ADR      r0,|L1.1072|
0008f6  f7fffffe          BL       __2printf
                  |L1.2298|
;;;2823   
;;;2824   	/* THIS FUNCTION MUST BE CALLED WITH EITHER INTERRUPTS DISABLED OR THE
;;;2825   	SCHEDULER SUSPENDED AND THE QUEUE BEING ACCESSED LOCKED. */
;;;2826   
;;;2827   	/* Place the event list item of the TCB in the appropriate event list.
;;;2828   	This is placed in the list in priority order so the highest priority task
;;;2829   	is the first to be woken by the event.  The queue that contains the event
;;;2830   	list is locked, preventing simultaneous access from interrupts. */
;;;2831   	vListInsert( pxEventList, &( pxCurrentTCB->xEventListItem ) );
0008fa  48da              LDR      r0,|L1.3172|
0008fc  6801              LDR      r1,[r0,#0]  ; pxCurrentTCB
0008fe  4620              MOV      r0,r4
000900  3118              ADDS     r1,r1,#0x18
000902  f7fffffe          BL       vListInsert
;;;2832   
;;;2833   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000906  4628              MOV      r0,r5
000908  e8bd4070          POP      {r4-r6,lr}
00090c  2101              MOVS     r1,#1
00090e  e7fe              B        prvAddCurrentTaskToDelayedList
;;;2834   }
;;;2835   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskPlaceOnUnorderedEventList PROC
;;;2836   
;;;2837   void vTaskPlaceOnUnorderedEventList( List_t * pxEventList, const TickType_t xItemValue, const TickType_t xTicksToWait )
000910  e92d41f0          PUSH     {r4-r8,lr}
;;;2838   {
000914  4617              MOV      r7,r2
000916  460e              MOV      r6,r1
000918  0005              MOVS     r5,r0
00091a  d107              BNE      |L1.2348|
;;;2839   	configASSERT( pxEventList );
00091c  f6403217          MOV      r2,#0xb17
000920  f2af5110          ADR      r1,|L1.1044|
000924  f2af40f8          ADR      r0,|L1.1072|
000928  f7fffffe          BL       __2printf
                  |L1.2348|
;;;2840   
;;;2841   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2842   	the event groups implementation. */
;;;2843   	configASSERT( uxSchedulerSuspended != 0 );
00092c  4ccd              LDR      r4,|L1.3172|
00092e  6b20              LDR      r0,[r4,#0x30]  ; uxSchedulerSuspended
000930  b938              CBNZ     r0,|L1.2370|
000932  f640321b          MOV      r2,#0xb1b
000936  f2af5124          ADR      r1,|L1.1044|
00093a  f2af500c          ADR      r0,|L1.1072|
00093e  f7fffffe          BL       __2printf
                  |L1.2370|
;;;2844   
;;;2845   	/* Store the item value in the event list item.  It is safe to access the
;;;2846   	event list item here as interrupts won't access the event list item of a
;;;2847   	task that is not in the Blocked state. */
;;;2848   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
000942  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000944  f0464000          ORR      r0,r6,#0x80000000
;;;2849   
;;;2850   	/* Place the event list item of the TCB at the end of the appropriate event
;;;2851   	list.  It is safe to access the event list here because it is part of an
;;;2852   	event group implementation - and interrupts don't access event groups
;;;2853   	directly (instead they access them indirectly by pending function calls to
;;;2854   	the task level). */
;;;2855   	vListInsertEnd( pxEventList, &( pxCurrentTCB->xEventListItem ) );
000948  6188              STR      r0,[r1,#0x18]
00094a  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
00094c  4628              MOV      r0,r5
00094e  3118              ADDS     r1,r1,#0x18
000950  f7fffffe          BL       vListInsertEnd
;;;2856   
;;;2857   	prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000954  4638              MOV      r0,r7
000956  e8bd41f0          POP      {r4-r8,lr}
00095a  2101              MOVS     r1,#1
00095c  e7fe              B        prvAddCurrentTaskToDelayedList
;;;2858   }
;;;2859   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromEventList PROC
;;;2893   
;;;2894   BaseType_t xTaskRemoveFromEventList( const List_t * const pxEventList )
00095e  e92d41f0          PUSH     {r4-r8,lr}
;;;2895   {
;;;2896   TCB_t *pxUnblockedTCB;
;;;2897   BaseType_t xReturn;
;;;2898   
;;;2899   	/* THIS FUNCTION MUST BE CALLED FROM A CRITICAL SECTION.  It can also be
;;;2900   	called from a critical section within an ISR. */
;;;2901   
;;;2902   	/* The event list is sorted in priority order, so the first in the list can
;;;2903   	be removed as it is known to be the highest priority.  Remove the TCB from
;;;2904   	the delayed list, and add it to the ready list.
;;;2905   
;;;2906   	If an event is for a queue that is locked then this function will never
;;;2907   	get called - the lock count on the queue will get modified instead.  This
;;;2908   	means exclusive access to the event list is guaranteed here.
;;;2909   
;;;2910   	This function assumes that a check has already been made to ensure that
;;;2911   	pxEventList is not empty. */
;;;2912   	pxUnblockedTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
000962  68c0              LDR      r0,[r0,#0xc]
000964  68c4              LDR      r4,[r0,#0xc]          ;2895
000966  b93c              CBNZ     r4,|L1.2424|
;;;2913   	configASSERT( pxUnblockedTCB );
000968  f6403261          MOV      r2,#0xb61
00096c  f2af515c          ADR      r1,|L1.1044|
000970  f2af5044          ADR      r0,|L1.1072|
000974  f7fffffe          BL       __2printf
                  |L1.2424|
;;;2914   	( void ) uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
000978  f1040018          ADD      r0,r4,#0x18
00097c  4607              MOV      r7,r0
00097e  f7fffffe          BL       uxListRemove
;;;2915   
;;;2916   	if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000982  4db8              LDR      r5,|L1.3172|
000984  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
;;;2917   	{
;;;2918   		( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
;;;2919   		prvAddTaskToReadyList( pxUnblockedTCB );
000986  2601              MOVS     r6,#1
000988  b158              CBZ      r0,|L1.2466|
00098a  4639              MOV      r1,r7                 ;2916
;;;2920   	}
;;;2921   	else
;;;2922   	{
;;;2923   		/* The delayed and ready lists cannot be accessed, so hold this task
;;;2924   		pending until the scheduler is resumed. */
;;;2925   		vListInsertEnd( &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
00098c  48b6              LDR      r0,|L1.3176|
                  |L1.2446|
00098e  f7fffffe          BL       vListInsertEnd
;;;2926   	}
;;;2927   
;;;2928   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000992  6ae0              LDR      r0,[r4,#0x2c]
000994  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000996  6ac9              LDR      r1,[r1,#0x2c]
000998  4288              CMP      r0,r1
00099a  d912              BLS      |L1.2498|
;;;2929   	{
;;;2930   		/* Return true if the task removed from the event list has a higher
;;;2931   		priority than the calling task.  This allows the calling task to know if
;;;2932   		it should force a context switch now. */
;;;2933   		xReturn = pdTRUE;
00099c  2001              MOVS     r0,#1
;;;2934   
;;;2935   		/* Mark that a yield is pending in case the user is not using the
;;;2936   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2937   		xYieldPending = pdTRUE;
00099e  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
;;;2938   	}
;;;2939   	else
;;;2940   	{
;;;2941   		xReturn = pdFALSE;
;;;2942   	}
;;;2943   
;;;2944   	#if( configUSE_TICKLESS_IDLE != 0 )
;;;2945   	{
;;;2946   		/* If a task is blocked on a kernel object then xNextTaskUnblockTime
;;;2947   		might be set to the blocked task's time out time.  If the task is
;;;2948   		unblocked for a reason other than a timeout xNextTaskUnblockTime is
;;;2949   		normally left unchanged, because it is automatically reset to a new
;;;2950   		value when the tick count equals xNextTaskUnblockTime.  However if
;;;2951   		tickless idling is used it might be more important to enter sleep mode
;;;2952   		at the earliest possible time - so reset xNextTaskUnblockTime here to
;;;2953   		ensure it is updated at the earliest possible time. */
;;;2954   		prvResetNextTaskUnblockTime();
;;;2955   	}
;;;2956   	#endif
;;;2957   
;;;2958   	return xReturn;
;;;2959   }
0009a0  e412              B        |L1.456|
                  |L1.2466|
0009a2  1d20              ADDS     r0,r4,#4              ;2918
0009a4  f7fffffe          BL       uxListRemove
0009a8  6ae0              LDR      r0,[r4,#0x2c]         ;2919
0009aa  692a              LDR      r2,[r5,#0x10]         ;2919  ; uxTopReadyPriority
0009ac  fa06f100          LSL      r1,r6,r0              ;2919
0009b0  4311              ORRS     r1,r1,r2              ;2919
0009b2  6129              STR      r1,[r5,#0x10]         ;2919  ; uxTopReadyPriority
0009b4  49ad              LDR      r1,|L1.3180|
0009b6  eb000080          ADD      r0,r0,r0,LSL #2       ;2919
0009ba  eb010080          ADD      r0,r1,r0,LSL #2       ;2919
0009be  1d21              ADDS     r1,r4,#4              ;2919
0009c0  e7e5              B        |L1.2446|
                  |L1.2498|
0009c2  2000              MOVS     r0,#0                 ;2941
0009c4  e4dd              B        |L1.898|
;;;2960   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskRemoveFromUnorderedEventList PROC
;;;2961   
;;;2962   BaseType_t xTaskRemoveFromUnorderedEventList( ListItem_t * pxEventListItem, const TickType_t xItemValue )
0009c6  b570              PUSH     {r4-r6,lr}
;;;2963   {
;;;2964   TCB_t *pxUnblockedTCB;
;;;2965   BaseType_t xReturn;
;;;2966   
;;;2967   	/* THIS FUNCTION MUST BE CALLED WITH THE SCHEDULER SUSPENDED.  It is used by
;;;2968   	the event flags implementation. */
;;;2969   	configASSERT( uxSchedulerSuspended != pdFALSE );
0009c8  4da6              LDR      r5,|L1.3172|
0009ca  4606              MOV      r6,r0                 ;2963
0009cc  460c              MOV      r4,r1                 ;2963
0009ce  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
0009d0  b938              CBNZ     r0,|L1.2530|
0009d2  f6403299          MOV      r2,#0xb99
0009d6  f2af51c4          ADR      r1,|L1.1044|
0009da  f2af50ac          ADR      r0,|L1.1072|
0009de  f7fffffe          BL       __2printf
                  |L1.2530|
;;;2970   
;;;2971   	/* Store the new item value in the event list. */
;;;2972   	listSET_LIST_ITEM_VALUE( pxEventListItem, xItemValue | taskEVENT_LIST_ITEM_VALUE_IN_USE );
0009e2  f0444000          ORR      r0,r4,#0x80000000
;;;2973   
;;;2974   	/* Remove the event list form the event flag.  Interrupts do not access
;;;2975   	event flags. */
;;;2976   	pxUnblockedTCB = ( TCB_t * ) listGET_LIST_ITEM_OWNER( pxEventListItem );
0009e6  6030              STR      r0,[r6,#0]
;;;2977   	configASSERT( pxUnblockedTCB );
0009e8  68f4              LDR      r4,[r6,#0xc]
0009ea  b93c              CBNZ     r4,|L1.2556|
0009ec  f64032a1          MOV      r2,#0xba1
0009f0  f2af51e0          ADR      r1,|L1.1044|
0009f4  f2af50c8          ADR      r0,|L1.1072|
0009f8  f7fffffe          BL       __2printf
                  |L1.2556|
;;;2978   	( void ) uxListRemove( pxEventListItem );
0009fc  4630              MOV      r0,r6
0009fe  f7fffffe          BL       uxListRemove
;;;2979   
;;;2980   	/* Remove the task from the delayed list and add it to the ready list.  The
;;;2981   	scheduler is suspended so interrupts will not be accessing the ready
;;;2982   	lists. */
;;;2983   	( void ) uxListRemove( &( pxUnblockedTCB->xStateListItem ) );
000a02  1d20              ADDS     r0,r4,#4
000a04  f7fffffe          BL       uxListRemove
;;;2984   	prvAddTaskToReadyList( pxUnblockedTCB );
000a08  6ae0              LDR      r0,[r4,#0x2c]
000a0a  2601              MOVS     r6,#1
000a0c  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000a0e  fa06f100          LSL      r1,r6,r0
000a12  4311              ORRS     r1,r1,r2
000a14  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000a16  4995              LDR      r1,|L1.3180|
000a18  eb000080          ADD      r0,r0,r0,LSL #2
000a1c  eb010080          ADD      r0,r1,r0,LSL #2
000a20  1d21              ADDS     r1,r4,#4
000a22  f7fffffe          BL       vListInsertEnd
;;;2985   
;;;2986   	if( pxUnblockedTCB->uxPriority > pxCurrentTCB->uxPriority )
000a26  6ae0              LDR      r0,[r4,#0x2c]
000a28  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000a2a  6ac9              LDR      r1,[r1,#0x2c]
000a2c  4288              CMP      r0,r1
000a2e  d902              BLS      |L1.2614|
;;;2987   	{
;;;2988   		/* Return true if the task removed from the event list has
;;;2989   		a higher priority than the calling task.  This allows
;;;2990   		the calling task to know if it should force a context
;;;2991   		switch now. */
;;;2992   		xReturn = pdTRUE;
000a30  2001              MOVS     r0,#1
;;;2993   
;;;2994   		/* Mark that a yield is pending in case the user is not using the
;;;2995   		"xHigherPriorityTaskWoken" parameter to an ISR safe FreeRTOS function. */
;;;2996   		xYieldPending = pdTRUE;
000a32  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
;;;2997   	}
;;;2998   	else
;;;2999   	{
;;;3000   		xReturn = pdFALSE;
;;;3001   	}
;;;3002   
;;;3003   	return xReturn;
;;;3004   }
000a34  bd70              POP      {r4-r6,pc}
                  |L1.2614|
000a36  2000              MOVS     r0,#0                 ;3000
000a38  bd70              POP      {r4-r6,pc}
;;;3005   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskSetTimeOutState PROC
;;;3006   
;;;3007   void vTaskSetTimeOutState( TimeOut_t * const pxTimeOut )
000a3a  b510              PUSH     {r4,lr}
;;;3008   {
000a3c  0004              MOVS     r4,r0
000a3e  d107              BNE      |L1.2640|
;;;3009   	configASSERT( pxTimeOut );
000a40  f64032c1          MOV      r2,#0xbc1
000a44  f2af6134          ADR      r1,|L1.1044|
000a48  f2af601c          ADR      r0,|L1.1072|
000a4c  f7fffffe          BL       __2printf
                  |L1.2640|
;;;3010   	pxTimeOut->xOverflowCount = xNumOfOverflows;
000a50  4884              LDR      r0,|L1.3172|
000a52  6a01              LDR      r1,[r0,#0x20]  ; xNumOfOverflows
;;;3011   	pxTimeOut->xTimeOnEntering = xTickCount;
000a54  6021              STR      r1,[r4,#0]
000a56  68c0              LDR      r0,[r0,#0xc]  ; xTickCount
000a58  6060              STR      r0,[r4,#4]
;;;3012   }
000a5a  bd10              POP      {r4,pc}
;;;3013   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskCheckForTimeOut PROC
;;;3014   
;;;3015   BaseType_t xTaskCheckForTimeOut( TimeOut_t * const pxTimeOut, TickType_t * const pxTicksToWait )
000a5c  b570              PUSH     {r4-r6,lr}
;;;3016   {
000a5e  460d              MOV      r5,r1
000a60  0004              MOVS     r4,r0
000a62  d107              BNE      |L1.2676|
;;;3017   BaseType_t xReturn;
;;;3018   
;;;3019   	configASSERT( pxTimeOut );
000a64  f64032cb          MOV      r2,#0xbcb
000a68  f2af6158          ADR      r1,|L1.1044|
000a6c  f2af6040          ADR      r0,|L1.1072|
000a70  f7fffffe          BL       __2printf
                  |L1.2676|
;;;3020   	configASSERT( pxTicksToWait );
000a74  b93d              CBNZ     r5,|L1.2694|
000a76  f64032cc          MOV      r2,#0xbcc
000a7a  f2af6168          ADR      r1,|L1.1044|
000a7e  f2af6050          ADR      r0,|L1.1072|
000a82  f7fffffe          BL       __2printf
                  |L1.2694|
;;;3021   
;;;3022   	taskENTER_CRITICAL();
000a86  f7fffffe          BL       vPortEnterCritical
;;;3023   	{
;;;3024   		/* Minor optimisation.  The tick count cannot change in this block. */
;;;3025   		const TickType_t xConstTickCount = xTickCount;
000a8a  4a76              LDR      r2,|L1.3172|
000a8c  68d0              LDR      r0,[r2,#0xc]  ; xTickCount
;;;3026   
;;;3027   		#if( INCLUDE_xTaskAbortDelay == 1 )
;;;3028   			if( pxCurrentTCB->ucDelayAborted != pdFALSE )
;;;3029   			{
;;;3030   				/* The delay was aborted, which is not the same as a time out,
;;;3031   				but has the same result. */
;;;3032   				pxCurrentTCB->ucDelayAborted = pdFALSE;
;;;3033   				xReturn = pdTRUE;
;;;3034   			}
;;;3035   			else
;;;3036   		#endif
;;;3037   
;;;3038   		#if ( INCLUDE_vTaskSuspend == 1 )
;;;3039   			if( *pxTicksToWait == portMAX_DELAY )
000a8e  6829              LDR      r1,[r5,#0]
000a90  1c4b              ADDS     r3,r1,#1
000a92  d00f              BEQ      |L1.2740|
;;;3040   			{
;;;3041   				/* If INCLUDE_vTaskSuspend is set to 1 and the block time
;;;3042   				specified is the maximum block time then the task should block
;;;3043   				indefinitely, and therefore never time out. */
;;;3044   				xReturn = pdFALSE;
;;;3045   			}
;;;3046   			else
;;;3047   		#endif
;;;3048   
;;;3049   		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( xConstTickCount >= pxTimeOut->xTimeOnEntering ) ) /*lint !e525 Indentation preferred as is to make code within pre-processor directives clearer. */
000a94  6823              LDR      r3,[r4,#0]
000a96  6a12              LDR      r2,[r2,#0x20]  ; xNumOfOverflows
000a98  4293              CMP      r3,r2
000a9a  d002              BEQ      |L1.2722|
000a9c  6862              LDR      r2,[r4,#4]
000a9e  4282              CMP      r2,r0
000aa0  d90a              BLS      |L1.2744|
                  |L1.2722|
;;;3050   		{
;;;3051   			/* The tick count is greater than the time at which
;;;3052   			vTaskSetTimeout() was called, but has also overflowed since
;;;3053   			vTaskSetTimeOut() was called.  It must have wrapped all the way
;;;3054   			around and gone past again. This passed since vTaskSetTimeout()
;;;3055   			was called. */
;;;3056   			xReturn = pdTRUE;
;;;3057   		}
;;;3058   		else if( ( ( TickType_t ) ( xConstTickCount - pxTimeOut->xTimeOnEntering ) ) < *pxTicksToWait ) /*lint !e961 Explicit casting is only redundant with some compilers, whereas others require it to prevent integer conversion errors. */
000aa2  6862              LDR      r2,[r4,#4]
000aa4  1a80              SUBS     r0,r0,r2
000aa6  4288              CMP      r0,r1
000aa8  d206              BCS      |L1.2744|
;;;3059   		{
;;;3060   			/* Not a genuine timeout. Adjust parameters for time remaining. */
;;;3061   			*pxTicksToWait -= ( xConstTickCount - pxTimeOut->xTimeOnEntering );
000aaa  1a08              SUBS     r0,r1,r0
;;;3062   			vTaskSetTimeOutState( pxTimeOut );
000aac  6028              STR      r0,[r5,#0]
000aae  4620              MOV      r0,r4
000ab0  f7fffffe          BL       vTaskSetTimeOutState
                  |L1.2740|
000ab4  2400              MOVS     r4,#0                 ;3044
000ab6  e000              B        |L1.2746|
                  |L1.2744|
;;;3063   			xReturn = pdFALSE;
;;;3064   		}
;;;3065   		else
;;;3066   		{
;;;3067   			xReturn = pdTRUE;
000ab8  2401              MOVS     r4,#1
                  |L1.2746|
;;;3068   		}
;;;3069   	}
;;;3070   	taskEXIT_CRITICAL();
000aba  f7fffffe          BL       vPortExitCritical
;;;3071   
;;;3072   	return xReturn;
000abe  4620              MOV      r0,r4
;;;3073   }
000ac0  bd70              POP      {r4-r6,pc}
;;;3074   /*-----------------------------------------------------------*/
                          ENDP

                  vTaskMissedYield PROC
;;;3075   
;;;3076   void vTaskMissedYield( void )
000ac2  4968              LDR      r1,|L1.3172|
;;;3077   {
;;;3078   	xYieldPending = pdTRUE;
000ac4  2001              MOVS     r0,#1
000ac6  61c8              STR      r0,[r1,#0x1c]  ; xYieldPending
;;;3079   }
000ac8  4770              BX       lr
;;;3080   /*-----------------------------------------------------------*/
                          ENDP

                  xTaskGetCurrentTaskHandle PROC
;;;3660   
;;;3661   	TaskHandle_t xTaskGetCurrentTaskHandle( void )
000aca  4866              LDR      r0,|L1.3172|
;;;3662   	{
;;;3663   	TaskHandle_t xReturn;
;;;3664   
;;;3665   		/* A critical section is not required as this is not called from
;;;3666   		an interrupt and the current TCB will always be the same for any
;;;3667   		individual execution thread. */
;;;3668   		xReturn = pxCurrentTCB;
000acc  6800              LDR      r0,[r0,#0]  ; pxCurrentTCB
;;;3669   
;;;3670   		return xReturn;
;;;3671   	}
000ace  4770              BX       lr
;;;3672   
                          ENDP

                  xTaskGetSchedulerState PROC
;;;3677   
;;;3678   	BaseType_t xTaskGetSchedulerState( void )
000ad0  4864              LDR      r0,|L1.3172|
;;;3679   	{
;;;3680   	BaseType_t xReturn;
;;;3681   
;;;3682   		if( xSchedulerRunning == pdFALSE )
000ad2  6941              LDR      r1,[r0,#0x14]  ; xSchedulerRunning
000ad4  b119              CBZ      r1,|L1.2782|
;;;3683   		{
;;;3684   			xReturn = taskSCHEDULER_NOT_STARTED;
;;;3685   		}
;;;3686   		else
;;;3687   		{
;;;3688   			if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000ad6  6b00              LDR      r0,[r0,#0x30]  ; uxSchedulerSuspended
000ad8  b118              CBZ      r0,|L1.2786|
;;;3689   			{
;;;3690   				xReturn = taskSCHEDULER_RUNNING;
;;;3691   			}
;;;3692   			else
;;;3693   			{
;;;3694   				xReturn = taskSCHEDULER_SUSPENDED;
000ada  2000              MOVS     r0,#0
;;;3695   			}
;;;3696   		}
;;;3697   
;;;3698   		return xReturn;
;;;3699   	}
000adc  4770              BX       lr
                  |L1.2782|
000ade  2001              MOVS     r0,#1                 ;3684
000ae0  4770              BX       lr
                  |L1.2786|
000ae2  2002              MOVS     r0,#2                 ;3690
000ae4  4770              BX       lr
;;;3700   
                          ENDP

                  vTaskPriorityInherit PROC
;;;3705   
;;;3706   	void vTaskPriorityInherit( TaskHandle_t const pxMutexHolder )
000ae6  b570              PUSH     {r4-r6,lr}
;;;3707   	{
;;;3708   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000ae8  0004              MOVS     r4,r0
000aea  d039              BEQ      |L1.2912|
;;;3709   
;;;3710   		/* If the mutex was given back by an interrupt while the queue was
;;;3711   		locked then the mutex holder might now be NULL. */
;;;3712   		if( pxMutexHolder != NULL )
;;;3713   		{
;;;3714   			/* If the holder of the mutex has a priority below the priority of
;;;3715   			the task attempting to obtain the mutex then it will temporarily
;;;3716   			inherit the priority of the task attempting to obtain the mutex. */
;;;3717   			if( pxTCB->uxPriority < pxCurrentTCB->uxPriority )
000aec  4d5d              LDR      r5,|L1.3172|
000aee  6ae0              LDR      r0,[r4,#0x2c]
000af0  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000af2  6ac9              LDR      r1,[r1,#0x2c]
000af4  4288              CMP      r0,r1
000af6  d233              BCS      |L1.2912|
;;;3718   			{
;;;3719   				/* Adjust the mutex holder state to account for its new
;;;3720   				priority.  Only reset the event list item value if the value is
;;;3721   				not	being used for anything else. */
;;;3722   				if( ( listGET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ) ) & taskEVENT_LIST_ITEM_VALUE_IN_USE ) == 0UL )
000af8  69a0              LDR      r0,[r4,#0x18]
000afa  2800              CMP      r0,#0
000afc  db04              BLT      |L1.2824|
;;;3723   				{
;;;3724   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000afe  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000b00  6ac0              LDR      r0,[r0,#0x2c]
000b02  f1c00020          RSB      r0,r0,#0x20
000b06  61a0              STR      r0,[r4,#0x18]
                  |L1.2824|
;;;3725   				}
;;;3726   				else
;;;3727   				{
;;;3728   					mtCOVERAGE_TEST_MARKER();
;;;3729   				}
;;;3730   
;;;3731   				/* If the task being modified is in the ready state it will need
;;;3732   				to be moved into a new list. */
;;;3733   				if( listIS_CONTAINED_WITHIN( &( pxReadyTasksLists[ pxTCB->uxPriority ] ), &( pxTCB->xStateListItem ) ) != pdFALSE )
000b08  6ae0              LDR      r0,[r4,#0x2c]
000b0a  4e58              LDR      r6,|L1.3180|
000b0c  eb000080          ADD      r0,r0,r0,LSL #2
000b10  6961              LDR      r1,[r4,#0x14]
000b12  eb060080          ADD      r0,r6,r0,LSL #2
000b16  4281              CMP      r1,r0
000b18  d11f              BNE      |L1.2906|
;;;3734   				{
;;;3735   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000b1a  1d20              ADDS     r0,r4,#4
000b1c  f7fffffe          BL       uxListRemove
;;;3736   					{
;;;3737   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000b20  2101              MOVS     r1,#1
000b22  b950              CBNZ     r0,|L1.2874|
000b24  6ae0              LDR      r0,[r4,#0x2c]
000b26  eb000280          ADD      r2,r0,r0,LSL #2
000b2a  f8562022          LDR      r2,[r6,r2,LSL #2]
000b2e  b922              CBNZ     r2,|L1.2874|
000b30  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000b32  fa01f000          LSL      r0,r1,r0
000b36  4382              BICS     r2,r2,r0
000b38  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.2874|
;;;3738   					}
;;;3739   					else
;;;3740   					{
;;;3741   						mtCOVERAGE_TEST_MARKER();
;;;3742   					}
;;;3743   
;;;3744   					/* Inherit the priority before being moved into the new list. */
;;;3745   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000b3a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000b3c  6ac0              LDR      r0,[r0,#0x2c]
;;;3746   					prvAddTaskToReadyList( pxTCB );
000b3e  62e0              STR      r0,[r4,#0x2c]
000b40  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000b42  4081              LSLS     r1,r1,r0
000b44  4311              ORRS     r1,r1,r2
000b46  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000b48  eb000080          ADD      r0,r0,r0,LSL #2
000b4c  eb060080          ADD      r0,r6,r0,LSL #2
000b50  1d21              ADDS     r1,r4,#4
000b52  e8bd4070          POP      {r4-r6,lr}
000b56  f7ffbffe          B.W      vListInsertEnd
                  |L1.2906|
;;;3747   				}
;;;3748   				else
;;;3749   				{
;;;3750   					/* Just inherit the priority. */
;;;3751   					pxTCB->uxPriority = pxCurrentTCB->uxPriority;
000b5a  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000b5c  6ac0              LDR      r0,[r0,#0x2c]
000b5e  62e0              STR      r0,[r4,#0x2c]
                  |L1.2912|
;;;3752   				}
;;;3753   
;;;3754   				traceTASK_PRIORITY_INHERIT( pxTCB, pxCurrentTCB->uxPriority );
;;;3755   			}
;;;3756   			else
;;;3757   			{
;;;3758   				mtCOVERAGE_TEST_MARKER();
;;;3759   			}
;;;3760   		}
;;;3761   		else
;;;3762   		{
;;;3763   			mtCOVERAGE_TEST_MARKER();
;;;3764   		}
;;;3765   	}
000b60  bd70              POP      {r4-r6,pc}
;;;3766   
                          ENDP

                  xTaskPriorityDisinherit PROC
;;;3771   
;;;3772   	BaseType_t xTaskPriorityDisinherit( TaskHandle_t const pxMutexHolder )
000b62  b570              PUSH     {r4-r6,lr}
;;;3773   	{
;;;3774   	TCB_t * const pxTCB = ( TCB_t * ) pxMutexHolder;
000b64  0004              MOVS     r4,r0
;;;3775   	BaseType_t xReturn = pdFALSE;
000b66  f04f0600          MOV      r6,#0
000b6a  d040              BEQ      |L1.3054|
;;;3776   
;;;3777   		if( pxMutexHolder != NULL )
;;;3778   		{
;;;3779   			/* A task can only have an inherited priority if it holds the mutex.
;;;3780   			If the mutex is held by a task then it cannot be given from an
;;;3781   			interrupt, and if a mutex is given by the holding task then it must
;;;3782   			be the running state task. */
;;;3783   			configASSERT( pxTCB == pxCurrentTCB );
000b6c  4d3d              LDR      r5,|L1.3172|
000b6e  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000b70  4284              CMP      r4,r0
000b72  d007              BEQ      |L1.2948|
000b74  f64062c7          MOV      r2,#0xec7
000b78  f2af7168          ADR      r1,|L1.1044|
000b7c  f2af7050          ADR      r0,|L1.1072|
000b80  f7fffffe          BL       __2printf
                  |L1.2948|
;;;3784   
;;;3785   			configASSERT( pxTCB->uxMutexesHeld );
000b84  6ca0              LDR      r0,[r4,#0x48]
000b86  b938              CBNZ     r0,|L1.2968|
000b88  f64062c9          MOV      r2,#0xec9
000b8c  f2af717c          ADR      r1,|L1.1044|
000b90  f2af7064          ADR      r0,|L1.1072|
000b94  f7fffffe          BL       __2printf
                  |L1.2968|
;;;3786   			( pxTCB->uxMutexesHeld )--;
000b98  6ca0              LDR      r0,[r4,#0x48]
000b9a  1e40              SUBS     r0,r0,#1
;;;3787   
;;;3788   			/* Has the holder of the mutex inherited the priority of another
;;;3789   			task? */
;;;3790   			if( pxTCB->uxPriority != pxTCB->uxBasePriority )
000b9c  64a0              STR      r0,[r4,#0x48]
000b9e  6c62              LDR      r2,[r4,#0x44]
000ba0  6ae1              LDR      r1,[r4,#0x2c]
000ba2  4291              CMP      r1,r2
000ba4  d023              BEQ      |L1.3054|
;;;3791   			{
;;;3792   				/* Only disinherit if no other mutexes are held. */
;;;3793   				if( pxTCB->uxMutexesHeld == ( UBaseType_t ) 0 )
000ba6  bb10              CBNZ     r0,|L1.3054|
;;;3794   				{
;;;3795   					/* A task can only have an inherited priority if it holds
;;;3796   					the mutex.  If the mutex is held by a task then it cannot be
;;;3797   					given from an interrupt, and if a mutex is given by the
;;;3798   					holding	task then it must be the running state task.  Remove
;;;3799   					the	holding task from the ready	list. */
;;;3800   					if( uxListRemove( &( pxTCB->xStateListItem ) ) == ( UBaseType_t ) 0 )
000ba8  1d20              ADDS     r0,r4,#4
000baa  f7fffffe          BL       uxListRemove
;;;3801   					{
;;;3802   						taskRESET_READY_PRIORITY( pxTCB->uxPriority );
000bae  492f              LDR      r1,|L1.3180|
000bb0  2201              MOVS     r2,#1
000bb2  b950              CBNZ     r0,|L1.3018|
000bb4  6ae0              LDR      r0,[r4,#0x2c]
000bb6  eb000380          ADD      r3,r0,r0,LSL #2
000bba  f8513023          LDR      r3,[r1,r3,LSL #2]
000bbe  b923              CBNZ     r3,|L1.3018|
000bc0  692b              LDR      r3,[r5,#0x10]  ; uxTopReadyPriority
000bc2  fa02f000          LSL      r0,r2,r0
000bc6  4383              BICS     r3,r3,r0
000bc8  612b              STR      r3,[r5,#0x10]  ; uxTopReadyPriority
                  |L1.3018|
;;;3803   					}
;;;3804   					else
;;;3805   					{
;;;3806   						mtCOVERAGE_TEST_MARKER();
;;;3807   					}
;;;3808   
;;;3809   					/* Disinherit the priority before adding the task into the
;;;3810   					new	ready list. */
;;;3811   					traceTASK_PRIORITY_DISINHERIT( pxTCB, pxTCB->uxBasePriority );
;;;3812   					pxTCB->uxPriority = pxTCB->uxBasePriority;
000bca  6c60              LDR      r0,[r4,#0x44]
;;;3813   
;;;3814   					/* Reset the event list item value.  It cannot be in use for
;;;3815   					any other purpose if this task is running, and it must be
;;;3816   					running to give back the mutex. */
;;;3817   					listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxTCB->uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000bcc  62e0              STR      r0,[r4,#0x2c]
000bce  f1c00020          RSB      r0,r0,#0x20
;;;3818   					prvAddTaskToReadyList( pxTCB );
000bd2  61a0              STR      r0,[r4,#0x18]
000bd4  6ae0              LDR      r0,[r4,#0x2c]
000bd6  692b              LDR      r3,[r5,#0x10]  ; uxTopReadyPriority
000bd8  4082              LSLS     r2,r2,r0
000bda  431a              ORRS     r2,r2,r3
000bdc  612a              STR      r2,[r5,#0x10]  ; uxTopReadyPriority
000bde  eb000080          ADD      r0,r0,r0,LSL #2
000be2  eb010080          ADD      r0,r1,r0,LSL #2
000be6  1d21              ADDS     r1,r4,#4
000be8  f7fffffe          BL       vListInsertEnd
;;;3819   
;;;3820   					/* Return true to indicate that a context switch is required.
;;;3821   					This is only actually required in the corner case whereby
;;;3822   					multiple mutexes were held and the mutexes were given back
;;;3823   					in an order different to that in which they were taken.
;;;3824   					If a context switch did not occur when the first mutex was
;;;3825   					returned, even if a task was waiting on it, then a context
;;;3826   					switch should occur when the last mutex is returned whether
;;;3827   					a task is waiting on it or not. */
;;;3828   					xReturn = pdTRUE;
000bec  2601              MOVS     r6,#1
                  |L1.3054|
;;;3829   				}
;;;3830   				else
;;;3831   				{
;;;3832   					mtCOVERAGE_TEST_MARKER();
;;;3833   				}
;;;3834   			}
;;;3835   			else
;;;3836   			{
;;;3837   				mtCOVERAGE_TEST_MARKER();
;;;3838   			}
;;;3839   		}
;;;3840   		else
;;;3841   		{
;;;3842   			mtCOVERAGE_TEST_MARKER();
;;;3843   		}
;;;3844   
;;;3845   		return xReturn;
000bee  4630              MOV      r0,r6
;;;3846   	}
000bf0  bd70              POP      {r4-r6,pc}
;;;3847   
                          ENDP

                  uxTaskResetEventItemValue PROC
;;;4161   
;;;4162   TickType_t uxTaskResetEventItemValue( void )
000bf2  491c              LDR      r1,|L1.3172|
;;;4163   {
;;;4164   TickType_t uxReturn;
;;;4165   
;;;4166   	uxReturn = listGET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ) );
000bf4  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4167   
;;;4168   	/* Reset the event list item to its normal value - so it can be used with
;;;4169   	queues and semaphores. */
;;;4170   	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xEventListItem ), ( ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) pxCurrentTCB->uxPriority ) ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000bf6  680a              LDR      r2,[r1,#0]  ; pxCurrentTCB
000bf8  6980              LDR      r0,[r0,#0x18]         ;4166
000bfa  6ad2              LDR      r2,[r2,#0x2c]
000bfc  6809              LDR      r1,[r1,#0]  ; pxCurrentTCB
000bfe  f1c20220          RSB      r2,r2,#0x20
000c02  618a              STR      r2,[r1,#0x18]
;;;4171   
;;;4172   	return uxReturn;
;;;4173   }
000c04  4770              BX       lr
;;;4174   /*-----------------------------------------------------------*/
                          ENDP

                  pvTaskIncrementMutexHeldCount PROC
;;;4177   
;;;4178   	void *pvTaskIncrementMutexHeldCount( void )
000c06  4917              LDR      r1,|L1.3172|
;;;4179   	{
;;;4180   		/* If xSemaphoreCreateMutex() is called before any tasks have been created
;;;4181   		then pxCurrentTCB will be NULL. */
;;;4182   		if( pxCurrentTCB != NULL )
000c08  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000c0a  b118              CBZ      r0,|L1.3092|
;;;4183   		{
;;;4184   			( pxCurrentTCB->uxMutexesHeld )++;
000c0c  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
000c0e  6c82              LDR      r2,[r0,#0x48]
000c10  1c52              ADDS     r2,r2,#1
000c12  6482              STR      r2,[r0,#0x48]
                  |L1.3092|
;;;4185   		}
;;;4186   
;;;4187   		return pxCurrentTCB;
000c14  6808              LDR      r0,[r1,#0]  ; pxCurrentTCB
;;;4188   	}
000c16  4770              BX       lr
;;;4189   
                          ENDP

                  ulTaskNotifyTake PROC
;;;4194   
;;;4195   	uint32_t ulTaskNotifyTake( BaseType_t xClearCountOnExit, TickType_t xTicksToWait )
000c18  b570              PUSH     {r4-r6,lr}
;;;4196   	{
000c1a  460c              MOV      r4,r1
000c1c  4606              MOV      r6,r0
;;;4197   	uint32_t ulReturn;
;;;4198   
;;;4199   		taskENTER_CRITICAL();
000c1e  f7fffffe          BL       vPortEnterCritical
;;;4200   		{
;;;4201   			/* Only block if the notification count is not already non-zero. */
;;;4202   			if( pxCurrentTCB->ulNotifiedValue == 0UL )
000c22  4d10              LDR      r5,|L1.3172|
000c24  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000c26  6cc0              LDR      r0,[r0,#0x4c]
000c28  b980              CBNZ     r0,|L1.3148|
;;;4203   			{
;;;4204   				/* Mark this task as waiting for a notification. */
;;;4205   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000c2a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000c2c  2001              MOVS     r0,#1
000c2e  f8810050          STRB     r0,[r1,#0x50]
;;;4206   
;;;4207   				if( xTicksToWait > ( TickType_t ) 0 )
000c32  b15c              CBZ      r4,|L1.3148|
;;;4208   				{
;;;4209   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000c34  2101              MOVS     r1,#1
000c36  4620              MOV      r0,r4
000c38  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4210   					traceTASK_NOTIFY_TAKE_BLOCK();
;;;4211   
;;;4212   					/* All ports are written to allow a yield in a critical
;;;4213   					section (some will yield immediately, others wait until the
;;;4214   					critical section exits) - but it is not something that
;;;4215   					application code should ever do. */
;;;4216   					portYIELD_WITHIN_API();
000c3c  490c              LDR      r1,|L1.3184|
000c3e  f04f5080          MOV      r0,#0x10000000
000c42  6008              STR      r0,[r1,#0]
000c44  f3bf8f4f          DSB      
000c48  f3bf8f6f          ISB      
                  |L1.3148|
;;;4217   				}
;;;4218   				else
;;;4219   				{
;;;4220   					mtCOVERAGE_TEST_MARKER();
;;;4221   				}
;;;4222   			}
;;;4223   			else
;;;4224   			{
;;;4225   				mtCOVERAGE_TEST_MARKER();
;;;4226   			}
;;;4227   		}
;;;4228   		taskEXIT_CRITICAL();
000c4c  f7fffffe          BL       vPortExitCritical
;;;4229   
;;;4230   		taskENTER_CRITICAL();
000c50  f7fffffe          BL       vPortEnterCritical
;;;4231   		{
;;;4232   			traceTASK_NOTIFY_TAKE();
;;;4233   			ulReturn = pxCurrentTCB->ulNotifiedValue;
000c54  6828              LDR      r0,[r5,#0]  ; pxCurrentTCB
000c56  6cc4              LDR      r4,[r0,#0x4c]
000c58  2000              MOVS     r0,#0
;;;4234   
;;;4235   			if( ulReturn != 0UL )
000c5a  b174              CBZ      r4,|L1.3194|
;;;4236   			{
;;;4237   				if( xClearCountOnExit != pdFALSE )
000c5c  b156              CBZ      r6,|L1.3188|
;;;4238   				{
;;;4239   					pxCurrentTCB->ulNotifiedValue = 0UL;
000c5e  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000c60  64c8              STR      r0,[r1,#0x4c]
000c62  e00a              B        |L1.3194|
                  |L1.3172|
                          DCD      ||.data||
                  |L1.3176|
                          DCD      ||.bss||+0x2a8
                  |L1.3180|
                          DCD      ||.bss||
                  |L1.3184|
                          DCD      0xe000ed04
                  |L1.3188|
;;;4240   				}
;;;4241   				else
;;;4242   				{
;;;4243   					pxCurrentTCB->ulNotifiedValue = ulReturn - 1;
000c74  682a              LDR      r2,[r5,#0]  ; pxCurrentTCB
000c76  1e61              SUBS     r1,r4,#1
000c78  64d1              STR      r1,[r2,#0x4c]
                  |L1.3194|
;;;4244   				}
;;;4245   			}
;;;4246   			else
;;;4247   			{
;;;4248   				mtCOVERAGE_TEST_MARKER();
;;;4249   			}
;;;4250   
;;;4251   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000c7a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000c7c  f8810050          STRB     r0,[r1,#0x50]
;;;4252   		}
;;;4253   		taskEXIT_CRITICAL();
000c80  f7fffffe          BL       vPortExitCritical
;;;4254   
;;;4255   		return ulReturn;
000c84  4620              MOV      r0,r4
;;;4256   	}
000c86  bd70              POP      {r4-r6,pc}
;;;4257   
                          ENDP

                  xTaskNotifyWait PROC
;;;4262   
;;;4263   	BaseType_t xTaskNotifyWait( uint32_t ulBitsToClearOnEntry, uint32_t ulBitsToClearOnExit, uint32_t *pulNotificationValue, TickType_t xTicksToWait )
000c88  e92d41f0          PUSH     {r4-r8,lr}
;;;4264   	{
000c8c  461e              MOV      r6,r3
000c8e  4615              MOV      r5,r2
000c90  4688              MOV      r8,r1
000c92  4607              MOV      r7,r0
;;;4265   	BaseType_t xReturn;
;;;4266   
;;;4267   		taskENTER_CRITICAL();
000c94  f7fffffe          BL       vPortEnterCritical
;;;4268   		{
;;;4269   			/* Only block if a notification is not already pending. */
;;;4270   			if( pxCurrentTCB->ucNotifyState != taskNOTIFICATION_RECEIVED )
000c98  4cfa              LDR      r4,|L1.4228|
000c9a  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000c9c  f8900050          LDRB     r0,[r0,#0x50]
000ca0  2802              CMP      r0,#2
000ca2  d014              BEQ      |L1.3278|
;;;4271   			{
;;;4272   				/* Clear bits in the task's notification value as bits may get
;;;4273   				set	by the notifying task or interrupt.  This can be used to
;;;4274   				clear the value to zero. */
;;;4275   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnEntry;
000ca4  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000ca6  6cc1              LDR      r1,[r0,#0x4c]
000ca8  43b9              BICS     r1,r1,r7
000caa  64c1              STR      r1,[r0,#0x4c]
;;;4276   
;;;4277   				/* Mark this task as waiting for a notification. */
;;;4278   				pxCurrentTCB->ucNotifyState = taskWAITING_NOTIFICATION;
000cac  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000cae  2001              MOVS     r0,#1
000cb0  f8810050          STRB     r0,[r1,#0x50]
;;;4279   
;;;4280   				if( xTicksToWait > ( TickType_t ) 0 )
000cb4  b15e              CBZ      r6,|L1.3278|
;;;4281   				{
;;;4282   					prvAddCurrentTaskToDelayedList( xTicksToWait, pdTRUE );
000cb6  2101              MOVS     r1,#1
000cb8  4630              MOV      r0,r6
000cba  f7fffffe          BL       prvAddCurrentTaskToDelayedList
;;;4283   					traceTASK_NOTIFY_WAIT_BLOCK();
;;;4284   
;;;4285   					/* All ports are written to allow a yield in a critical
;;;4286   					section (some will yield immediately, others wait until the
;;;4287   					critical section exits) - but it is not something that
;;;4288   					application code should ever do. */
;;;4289   					portYIELD_WITHIN_API();
000cbe  49f2              LDR      r1,|L1.4232|
000cc0  f04f5080          MOV      r0,#0x10000000
000cc4  6008              STR      r0,[r1,#0]
000cc6  f3bf8f4f          DSB      
000cca  f3bf8f6f          ISB      
                  |L1.3278|
;;;4290   				}
;;;4291   				else
;;;4292   				{
;;;4293   					mtCOVERAGE_TEST_MARKER();
;;;4294   				}
;;;4295   			}
;;;4296   			else
;;;4297   			{
;;;4298   				mtCOVERAGE_TEST_MARKER();
;;;4299   			}
;;;4300   		}
;;;4301   		taskEXIT_CRITICAL();
000cce  f7fffffe          BL       vPortExitCritical
;;;4302   
;;;4303   		taskENTER_CRITICAL();
000cd2  f7fffffe          BL       vPortEnterCritical
;;;4304   		{
;;;4305   			traceTASK_NOTIFY_WAIT();
;;;4306   
;;;4307   			if( pulNotificationValue != NULL )
000cd6  b115              CBZ      r5,|L1.3294|
;;;4308   			{
;;;4309   				/* Output the current notification value, which may or may not
;;;4310   				have changed. */
;;;4311   				*pulNotificationValue = pxCurrentTCB->ulNotifiedValue;
000cd8  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000cda  6cc0              LDR      r0,[r0,#0x4c]
000cdc  6028              STR      r0,[r5,#0]
                  |L1.3294|
;;;4312   			}
;;;4313   
;;;4314   			/* If ucNotifyValue is set then either the task never entered the
;;;4315   			blocked state (because a notification was already pending) or the
;;;4316   			task unblocked because of a notification.  Otherwise the task
;;;4317   			unblocked because of a timeout. */
;;;4318   			if( pxCurrentTCB->ucNotifyState == taskWAITING_NOTIFICATION )
000cde  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000ce0  f8900050          LDRB     r0,[r0,#0x50]
000ce4  2801              CMP      r0,#1
000ce6  d00d              BEQ      |L1.3332|
;;;4319   			{
;;;4320   				/* A notification was not received. */
;;;4321   				xReturn = pdFALSE;
;;;4322   			}
;;;4323   			else
;;;4324   			{
;;;4325   				/* A notification was already pending or a notification was
;;;4326   				received while the task was waiting. */
;;;4327   				pxCurrentTCB->ulNotifiedValue &= ~ulBitsToClearOnExit;
000ce8  6820              LDR      r0,[r4,#0]  ; pxCurrentTCB
000cea  6cc1              LDR      r1,[r0,#0x4c]
000cec  ea210108          BIC      r1,r1,r8
000cf0  64c1              STR      r1,[r0,#0x4c]
;;;4328   				xReturn = pdTRUE;
000cf2  2501              MOVS     r5,#1
                  |L1.3316|
;;;4329   			}
;;;4330   
;;;4331   			pxCurrentTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000cf4  6821              LDR      r1,[r4,#0]  ; pxCurrentTCB
000cf6  2000              MOVS     r0,#0
000cf8  f8810050          STRB     r0,[r1,#0x50]
;;;4332   		}
;;;4333   		taskEXIT_CRITICAL();
000cfc  f7fffffe          BL       vPortExitCritical
;;;4334   
;;;4335   		return xReturn;
000d00  4628              MOV      r0,r5
;;;4336   	}
000d02  e576              B        |L1.2034|
                  |L1.3332|
000d04  2500              MOVS     r5,#0                 ;4321
000d06  e7f5              B        |L1.3316|
;;;4337   
                          ENDP

                  xTaskGenericNotify PROC
;;;4342   
;;;4343   	BaseType_t xTaskGenericNotify( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue )
000d08  e92d41f0          PUSH     {r4-r8,lr}
;;;4344   	{
000d0c  461f              MOV      r7,r3
000d0e  4690              MOV      r8,r2
000d10  460d              MOV      r5,r1
000d12  0004              MOVS     r4,r0
;;;4345   	TCB_t * pxTCB;
;;;4346   	BaseType_t xReturn = pdPASS;
000d14  f04f0601          MOV      r6,#1
000d18  d107              BNE      |L1.3370|
;;;4347   	uint8_t ucOriginalNotifyState;
;;;4348   
;;;4349   		configASSERT( xTaskToNotify );
000d1a  f24102fd          MOV      r2,#0x10fd
000d1e  f6af110c          ADR      r1,|L1.1044|
000d22  f6af00f4          ADR      r0,|L1.1072|
000d26  f7fffffe          BL       __2printf
                  |L1.3370|
;;;4350   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4351   
;;;4352   		taskENTER_CRITICAL();
000d2a  f7fffffe          BL       vPortEnterCritical
;;;4353   		{
;;;4354   			if( pulPreviousNotificationValue != NULL )
000d2e  b10f              CBZ      r7,|L1.3380|
;;;4355   			{
;;;4356   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000d30  6ce0              LDR      r0,[r4,#0x4c]
000d32  6038              STR      r0,[r7,#0]
                  |L1.3380|
;;;4357   			}
;;;4358   
;;;4359   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000d34  f8940050          LDRB     r0,[r4,#0x50]
;;;4360   
;;;4361   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000d38  2102              MOVS     r1,#2
000d3a  f8841050          STRB     r1,[r4,#0x50]
;;;4362   
;;;4363   			switch( eAction )
000d3e  f1b80f05          CMP      r8,#5
000d42  d20e              BCS      |L1.3426|
000d44  e8dff008          TBB      [pc,r8]
000d48  0d03060c          DCB      0x0d,0x03,0x06,0x0c
000d4c  0a00              DCB      0x0a,0x00
;;;4364   			{
;;;4365   				case eSetBits	:
;;;4366   					pxTCB->ulNotifiedValue |= ulValue;
000d4e  6ce1              LDR      r1,[r4,#0x4c]
000d50  4329              ORRS     r1,r1,r5
;;;4367   					break;
000d52  e001              B        |L1.3416|
;;;4368   
;;;4369   				case eIncrement	:
;;;4370   					( pxTCB->ulNotifiedValue )++;
000d54  6ce1              LDR      r1,[r4,#0x4c]
000d56  1c49              ADDS     r1,r1,#1
                  |L1.3416|
000d58  64e1              STR      r1,[r4,#0x4c]         ;4366
000d5a  e002              B        |L1.3426|
;;;4371   					break;
;;;4372   
;;;4373   				case eSetValueWithOverwrite	:
;;;4374   					pxTCB->ulNotifiedValue = ulValue;
;;;4375   					break;
;;;4376   
;;;4377   				case eSetValueWithoutOverwrite :
;;;4378   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000d5c  2802              CMP      r0,#2
000d5e  d003              BEQ      |L1.3432|
;;;4379   					{
;;;4380   						pxTCB->ulNotifiedValue = ulValue;
000d60  64e5              STR      r5,[r4,#0x4c]
                  |L1.3426|
;;;4381   					}
;;;4382   					else
;;;4383   					{
;;;4384   						/* The value could not be written to the task. */
;;;4385   						xReturn = pdFAIL;
;;;4386   					}
;;;4387   					break;
;;;4388   
;;;4389   				case eNoAction:
;;;4390   					/* The task is being notified without its notify value being
;;;4391   					updated. */
;;;4392   					break;
;;;4393   			}
;;;4394   
;;;4395   			traceTASK_NOTIFY();
;;;4396   
;;;4397   			/* If the task is in the blocked state specifically to wait for a
;;;4398   			notification then unblock it now. */
;;;4399   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000d62  2801              CMP      r0,#1
000d64  d002              BEQ      |L1.3436|
000d66  e02a              B        |L1.3518|
                  |L1.3432|
000d68  2600              MOVS     r6,#0                 ;4385
000d6a  e028              B        |L1.3518|
                  |L1.3436|
;;;4400   			{
;;;4401   				( void ) uxListRemove( &( pxTCB->xStateListItem ) );
000d6c  1d20              ADDS     r0,r4,#4
000d6e  f7fffffe          BL       uxListRemove
;;;4402   				prvAddTaskToReadyList( pxTCB );
000d72  4dc4              LDR      r5,|L1.4228|
000d74  6ae0              LDR      r0,[r4,#0x2c]
000d76  2101              MOVS     r1,#1
000d78  692a              LDR      r2,[r5,#0x10]  ; uxTopReadyPriority
000d7a  4081              LSLS     r1,r1,r0
000d7c  4311              ORRS     r1,r1,r2
000d7e  6129              STR      r1,[r5,#0x10]  ; uxTopReadyPriority
000d80  49c2              LDR      r1,|L1.4236|
000d82  eb000080          ADD      r0,r0,r0,LSL #2
000d86  eb010080          ADD      r0,r1,r0,LSL #2
000d8a  1d21              ADDS     r1,r4,#4
000d8c  f7fffffe          BL       vListInsertEnd
;;;4403   
;;;4404   				/* The task should not have been on an event list. */
;;;4405   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000d90  6aa0              LDR      r0,[r4,#0x28]
000d92  b138              CBZ      r0,|L1.3492|
000d94  f2411235          MOV      r2,#0x1135
000d98  f6af1188          ADR      r1,|L1.1044|
000d9c  f6af1070          ADR      r0,|L1.1072|
000da0  f7fffffe          BL       __2printf
                  |L1.3492|
;;;4406   
;;;4407   				#if( configUSE_TICKLESS_IDLE != 0 )
;;;4408   				{
;;;4409   					/* If a task is blocked waiting for a notification then
;;;4410   					xNextTaskUnblockTime might be set to the blocked task's time
;;;4411   					out time.  If the task is unblocked for a reason other than
;;;4412   					a timeout xNextTaskUnblockTime is normally left unchanged,
;;;4413   					because it will automatically get reset to a new value when
;;;4414   					the tick count equals xNextTaskUnblockTime.  However if
;;;4415   					tickless idling is used it might be more important to enter
;;;4416   					sleep mode at the earliest possible time - so reset
;;;4417   					xNextTaskUnblockTime here to ensure it is updated at the
;;;4418   					earliest possible time. */
;;;4419   					prvResetNextTaskUnblockTime();
;;;4420   				}
;;;4421   				#endif
;;;4422   
;;;4423   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000da4  6ae0              LDR      r0,[r4,#0x2c]
000da6  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000da8  6ac9              LDR      r1,[r1,#0x2c]
000daa  4288              CMP      r0,r1
000dac  d907              BLS      |L1.3518|
;;;4424   				{
;;;4425   					/* The notified task has a priority above the currently
;;;4426   					executing task so a yield is required. */
;;;4427   					taskYIELD_IF_USING_PREEMPTION();
000dae  49b6              LDR      r1,|L1.4232|
000db0  f04f5080          MOV      r0,#0x10000000
000db4  6008              STR      r0,[r1,#0]
000db6  f3bf8f4f          DSB      
000dba  f3bf8f6f          ISB      
                  |L1.3518|
;;;4428   				}
;;;4429   				else
;;;4430   				{
;;;4431   					mtCOVERAGE_TEST_MARKER();
;;;4432   				}
;;;4433   			}
;;;4434   			else
;;;4435   			{
;;;4436   				mtCOVERAGE_TEST_MARKER();
;;;4437   			}
;;;4438   		}
;;;4439   		taskEXIT_CRITICAL();
000dbe  f7fffffe          BL       vPortExitCritical
;;;4440   
;;;4441   		return xReturn;
000dc2  4630              MOV      r0,r6
;;;4442   	}
000dc4  e515              B        |L1.2034|
;;;4443   
                          ENDP

                  xTaskGenericNotifyFromISR PROC
;;;4448   
;;;4449   	BaseType_t xTaskGenericNotifyFromISR( TaskHandle_t xTaskToNotify, uint32_t ulValue, eNotifyAction eAction, uint32_t *pulPreviousNotificationValue, BaseType_t *pxHigherPriorityTaskWoken )
000dc6  e92d47f0          PUSH     {r4-r10,lr}
;;;4450   	{
000dca  461f              MOV      r7,r3
000dcc  f8dd9020          LDR      r9,[sp,#0x20]
000dd0  4692              MOV      r10,r2
000dd2  460d              MOV      r5,r1
000dd4  0004              MOVS     r4,r0
;;;4451   	TCB_t * pxTCB;
;;;4452   	uint8_t ucOriginalNotifyState;
;;;4453   	BaseType_t xReturn = pdPASS;
000dd6  f04f0801          MOV      r8,#1
000dda  d107              BNE      |L1.3564|
;;;4454   	UBaseType_t uxSavedInterruptStatus;
;;;4455   
;;;4456   		configASSERT( xTaskToNotify );
000ddc  f2411268          MOV      r2,#0x1168
000de0  f6af11d0          ADR      r1,|L1.1044|
000de4  f6af10b8          ADR      r0,|L1.1072|
000de8  f7fffffe          BL       __2printf
                  |L1.3564|
;;;4457   
;;;4458   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4459   		maximum	system call (or maximum API call) interrupt priority.
;;;4460   		Interrupts that are	above the maximum system call priority are keep
;;;4461   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4462   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4463   		is defined in FreeRTOSConfig.h then
;;;4464   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4465   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4466   		been assigned a priority above the configured maximum system call
;;;4467   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4468   		from interrupts	that have been assigned a priority at or (logically)
;;;4469   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4470   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4471   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4472   		provided on the following link:
;;;4473   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4474   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000dec  f7fffffe          BL       vPortValidateInterruptPriority
000df0  2050              MOVS     r0,#0x50
000df2  f3ef8611          MRS      r6,BASEPRI
000df6  f3808811          MSR      BASEPRI,r0
000dfa  f3bf8f4f          DSB      
000dfe  f3bf8f6f          ISB      
;;;4475   
;;;4476   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4477   
;;;4478   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4479   		{
;;;4480   			if( pulPreviousNotificationValue != NULL )
000e02  b10f              CBZ      r7,|L1.3592|
;;;4481   			{
;;;4482   				*pulPreviousNotificationValue = pxTCB->ulNotifiedValue;
000e04  6ce0              LDR      r0,[r4,#0x4c]
000e06  6038              STR      r0,[r7,#0]
                  |L1.3592|
;;;4483   			}
;;;4484   
;;;4485   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000e08  f8940050          LDRB     r0,[r4,#0x50]
;;;4486   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000e0c  2102              MOVS     r1,#2
000e0e  f8841050          STRB     r1,[r4,#0x50]
;;;4487   
;;;4488   			switch( eAction )
000e12  f1ba0f05          CMP      r10,#5
000e16  d20e              BCS      |L1.3638|
000e18  e8dff00a          TBB      [pc,r10]
000e1c  0d03060c          DCB      0x0d,0x03,0x06,0x0c
000e20  0a00              DCB      0x0a,0x00
;;;4489   			{
;;;4490   				case eSetBits	:
;;;4491   					pxTCB->ulNotifiedValue |= ulValue;
000e22  6ce1              LDR      r1,[r4,#0x4c]
000e24  4329              ORRS     r1,r1,r5
;;;4492   					break;
000e26  e001              B        |L1.3628|
;;;4493   
;;;4494   				case eIncrement	:
;;;4495   					( pxTCB->ulNotifiedValue )++;
000e28  6ce1              LDR      r1,[r4,#0x4c]
000e2a  1c49              ADDS     r1,r1,#1
                  |L1.3628|
000e2c  64e1              STR      r1,[r4,#0x4c]         ;4491
000e2e  e002              B        |L1.3638|
;;;4496   					break;
;;;4497   
;;;4498   				case eSetValueWithOverwrite	:
;;;4499   					pxTCB->ulNotifiedValue = ulValue;
;;;4500   					break;
;;;4501   
;;;4502   				case eSetValueWithoutOverwrite :
;;;4503   					if( ucOriginalNotifyState != taskNOTIFICATION_RECEIVED )
000e30  2802              CMP      r0,#2
000e32  d003              BEQ      |L1.3644|
;;;4504   					{
;;;4505   						pxTCB->ulNotifiedValue = ulValue;
000e34  64e5              STR      r5,[r4,#0x4c]
                  |L1.3638|
;;;4506   					}
;;;4507   					else
;;;4508   					{
;;;4509   						/* The value could not be written to the task. */
;;;4510   						xReturn = pdFAIL;
;;;4511   					}
;;;4512   					break;
;;;4513   
;;;4514   				case eNoAction :
;;;4515   					/* The task is being notified without its notify value being
;;;4516   					updated. */
;;;4517   					break;
;;;4518   			}
;;;4519   
;;;4520   			traceTASK_NOTIFY_FROM_ISR();
;;;4521   
;;;4522   			/* If the task is in the blocked state specifically to wait for a
;;;4523   			notification then unblock it now. */
;;;4524   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000e36  2801              CMP      r0,#1
000e38  d003              BEQ      |L1.3650|
000e3a  e031              B        |L1.3744|
                  |L1.3644|
000e3c  f04f0800          MOV      r8,#0                 ;4510
000e40  e02e              B        |L1.3744|
                  |L1.3650|
;;;4525   			{
;;;4526   				/* The task should not have been on an event list. */
;;;4527   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000e42  6aa0              LDR      r0,[r4,#0x28]
000e44  b138              CBZ      r0,|L1.3670|
000e46  f24112af          MOV      r2,#0x11af
000e4a  f6af2138          ADR      r1,|L1.1044|
000e4e  f6af2020          ADR      r0,|L1.1072|
000e52  f7fffffe          BL       __2printf
                  |L1.3670|
;;;4528   
;;;4529   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000e56  4d8b              LDR      r5,|L1.4228|
000e58  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000e5a  2701              MOVS     r7,#1                 ;4453
000e5c  b178              CBZ      r0,|L1.3710|
;;;4530   				{
;;;4531   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4532   					prvAddTaskToReadyList( pxTCB );
;;;4533   				}
;;;4534   				else
;;;4535   				{
;;;4536   					/* The delayed and ready lists cannot be accessed, so hold
;;;4537   					this task pending until the scheduler is resumed. */
;;;4538   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000e5e  f1040118          ADD      r1,r4,#0x18
000e62  488b              LDR      r0,|L1.4240|
                  |L1.3684|
000e64  f7fffffe          BL       vListInsertEnd
;;;4539   				}
;;;4540   
;;;4541   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000e68  6ae0              LDR      r0,[r4,#0x2c]
000e6a  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000e6c  6ac9              LDR      r1,[r1,#0x2c]
000e6e  4288              CMP      r0,r1
000e70  d916              BLS      |L1.3744|
;;;4542   				{
;;;4543   					/* The notified task has a priority above the currently
;;;4544   					executing task so a yield is required. */
;;;4545   					if( pxHigherPriorityTaskWoken != NULL )
000e72  f1b90f00          CMP      r9,#0
000e76  d012              BEQ      |L1.3742|
;;;4546   					{
;;;4547   						*pxHigherPriorityTaskWoken = pdTRUE;
000e78  f8c97000          STR      r7,[r9,#0]
000e7c  e010              B        |L1.3744|
                  |L1.3710|
000e7e  1d20              ADDS     r0,r4,#4              ;4531
000e80  f7fffffe          BL       uxListRemove
000e84  6ae0              LDR      r0,[r4,#0x2c]         ;4532
000e86  692a              LDR      r2,[r5,#0x10]         ;4532  ; uxTopReadyPriority
000e88  fa07f100          LSL      r1,r7,r0              ;4532
000e8c  4311              ORRS     r1,r1,r2              ;4532
000e8e  6129              STR      r1,[r5,#0x10]         ;4532  ; uxTopReadyPriority
000e90  eb000180          ADD      r1,r0,r0,LSL #2       ;4532
000e94  487d              LDR      r0,|L1.4236|
000e96  eb000081          ADD      r0,r0,r1,LSL #2       ;4532
000e9a  1d21              ADDS     r1,r4,#4              ;4532
000e9c  e7e2              B        |L1.3684|
                  |L1.3742|
;;;4548   					}
;;;4549   					else
;;;4550   					{
;;;4551   						/* Mark that a yield is pending in case the user is not
;;;4552   						using the "xHigherPriorityTaskWoken" parameter to an ISR
;;;4553   						safe FreeRTOS function. */
;;;4554   						xYieldPending = pdTRUE;
000e9e  61ef              STR      r7,[r5,#0x1c]  ; xYieldPending
                  |L1.3744|
000ea0  f3868811          MSR      BASEPRI,r6
;;;4555   					}
;;;4556   				}
;;;4557   				else
;;;4558   				{
;;;4559   					mtCOVERAGE_TEST_MARKER();
;;;4560   				}
;;;4561   			}
;;;4562   		}
;;;4563   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4564   
;;;4565   		return xReturn;
000ea4  4640              MOV      r0,r8
                  |L1.3750|
;;;4566   	}
000ea6  e8bd87f0          POP      {r4-r10,pc}
;;;4567   
                          ENDP

                  vTaskNotifyGiveFromISR PROC
;;;4572   
;;;4573   	void vTaskNotifyGiveFromISR( TaskHandle_t xTaskToNotify, BaseType_t *pxHigherPriorityTaskWoken )
000eaa  e92d41f0          PUSH     {r4-r8,lr}
;;;4574   	{
000eae  4688              MOV      r8,r1
000eb0  0004              MOVS     r4,r0
000eb2  d107              BNE      |L1.3780|
;;;4575   	TCB_t * pxTCB;
;;;4576   	uint8_t ucOriginalNotifyState;
;;;4577   	UBaseType_t uxSavedInterruptStatus;
;;;4578   
;;;4579   		configASSERT( xTaskToNotify );
000eb4  f24112e3          MOV      r2,#0x11e3
000eb8  f6af21a8          ADR      r1,|L1.1044|
000ebc  f6af2090          ADR      r0,|L1.1072|
000ec0  f7fffffe          BL       __2printf
                  |L1.3780|
;;;4580   
;;;4581   		/* RTOS ports that support interrupt nesting have the concept of a
;;;4582   		maximum	system call (or maximum API call) interrupt priority.
;;;4583   		Interrupts that are	above the maximum system call priority are keep
;;;4584   		permanently enabled, even when the RTOS kernel is in a critical section,
;;;4585   		but cannot make any calls to FreeRTOS API functions.  If configASSERT()
;;;4586   		is defined in FreeRTOSConfig.h then
;;;4587   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID() will result in an assertion
;;;4588   		failure if a FreeRTOS API function is called from an interrupt that has
;;;4589   		been assigned a priority above the configured maximum system call
;;;4590   		priority.  Only FreeRTOS functions that end in FromISR can be called
;;;4591   		from interrupts	that have been assigned a priority at or (logically)
;;;4592   		below the maximum system call interrupt priority.  FreeRTOS maintains a
;;;4593   		separate interrupt safe API to ensure interrupt entry is as fast and as
;;;4594   		simple as possible.  More information (albeit Cortex-M specific) is
;;;4595   		provided on the following link:
;;;4596   		http://www.freertos.org/RTOS-Cortex-M3-M4.html */
;;;4597   		portASSERT_IF_INTERRUPT_PRIORITY_INVALID();
000ec4  f7fffffe          BL       vPortValidateInterruptPriority
000ec8  2050              MOVS     r0,#0x50
000eca  f3ef8711          MRS      r7,BASEPRI
000ece  f3808811          MSR      BASEPRI,r0
000ed2  f3bf8f4f          DSB      
000ed6  f3bf8f6f          ISB      
;;;4598   
;;;4599   		pxTCB = ( TCB_t * ) xTaskToNotify;
;;;4600   
;;;4601   		uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
;;;4602   		{
;;;4603   			ucOriginalNotifyState = pxTCB->ucNotifyState;
000eda  f8940050          LDRB     r0,[r4,#0x50]
;;;4604   			pxTCB->ucNotifyState = taskNOTIFICATION_RECEIVED;
000ede  2102              MOVS     r1,#2
000ee0  f8841050          STRB     r1,[r4,#0x50]
;;;4605   
;;;4606   			/* 'Giving' is equivalent to incrementing a count in a counting
;;;4607   			semaphore. */
;;;4608   			( pxTCB->ulNotifiedValue )++;
000ee4  6ce1              LDR      r1,[r4,#0x4c]
000ee6  1c49              ADDS     r1,r1,#1
000ee8  64e1              STR      r1,[r4,#0x4c]
;;;4609   
;;;4610   			traceTASK_NOTIFY_GIVE_FROM_ISR();
;;;4611   
;;;4612   			/* If the task is in the blocked state specifically to wait for a
;;;4613   			notification then unblock it now. */
;;;4614   			if( ucOriginalNotifyState == taskWAITING_NOTIFICATION )
000eea  2801              CMP      r0,#1
000eec  d12e              BNE      |L1.3916|
;;;4615   			{
;;;4616   				/* The task should not have been on an event list. */
;;;4617   				configASSERT( listLIST_ITEM_CONTAINER( &( pxTCB->xEventListItem ) ) == NULL );
000eee  6aa0              LDR      r0,[r4,#0x28]
000ef0  b138              CBZ      r0,|L1.3842|
000ef2  f2412209          MOV      r2,#0x1209
000ef6  f6af21e4          ADR      r1,|L1.1044|
000efa  f6af20cc          ADR      r0,|L1.1072|
000efe  f7fffffe          BL       __2printf
                  |L1.3842|
;;;4618   
;;;4619   				if( uxSchedulerSuspended == ( UBaseType_t ) pdFALSE )
000f02  4d60              LDR      r5,|L1.4228|
000f04  6b28              LDR      r0,[r5,#0x30]  ; uxSchedulerSuspended
000f06  2601              MOVS     r6,#1                 ;4576
000f08  b178              CBZ      r0,|L1.3882|
;;;4620   				{
;;;4621   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;4622   					prvAddTaskToReadyList( pxTCB );
;;;4623   				}
;;;4624   				else
;;;4625   				{
;;;4626   					/* The delayed and ready lists cannot be accessed, so hold
;;;4627   					this task pending until the scheduler is resumed. */
;;;4628   					vListInsertEnd( &( xPendingReadyList ), &( pxTCB->xEventListItem ) );
000f0a  f1040118          ADD      r1,r4,#0x18
000f0e  4860              LDR      r0,|L1.4240|
                  |L1.3856|
000f10  f7fffffe          BL       vListInsertEnd
;;;4629   				}
;;;4630   
;;;4631   				if( pxTCB->uxPriority > pxCurrentTCB->uxPriority )
000f14  6ae0              LDR      r0,[r4,#0x2c]
000f16  6829              LDR      r1,[r5,#0]  ; pxCurrentTCB
000f18  6ac9              LDR      r1,[r1,#0x2c]
000f1a  4288              CMP      r0,r1
000f1c  d916              BLS      |L1.3916|
;;;4632   				{
;;;4633   					/* The notified task has a priority above the currently
;;;4634   					executing task so a yield is required. */
;;;4635   					if( pxHigherPriorityTaskWoken != NULL )
000f1e  f1b80f00          CMP      r8,#0
000f22  d012              BEQ      |L1.3914|
;;;4636   					{
;;;4637   						*pxHigherPriorityTaskWoken = pdTRUE;
000f24  f8c86000          STR      r6,[r8,#0]
000f28  e010              B        |L1.3916|
                  |L1.3882|
000f2a  1d20              ADDS     r0,r4,#4              ;4621
000f2c  f7fffffe          BL       uxListRemove
000f30  6ae0              LDR      r0,[r4,#0x2c]         ;4622
000f32  692a              LDR      r2,[r5,#0x10]         ;4622  ; uxTopReadyPriority
000f34  fa06f100          LSL      r1,r6,r0              ;4622
000f38  4311              ORRS     r1,r1,r2              ;4622
000f3a  6129              STR      r1,[r5,#0x10]         ;4622  ; uxTopReadyPriority
000f3c  4953              LDR      r1,|L1.4236|
000f3e  eb000080          ADD      r0,r0,r0,LSL #2       ;4622
000f42  eb010080          ADD      r0,r1,r0,LSL #2       ;4622
000f46  1d21              ADDS     r1,r4,#4              ;4622
000f48  e7e2              B        |L1.3856|
                  |L1.3914|
;;;4638   					}
;;;4639   					else
;;;4640   					{
;;;4641   						/* Mark that a yield is pending in case the user is not
;;;4642   						using the "xHigherPriorityTaskWoken" parameter in an ISR
;;;4643   						safe FreeRTOS function. */
;;;4644   						xYieldPending = pdTRUE;
000f4a  61ee              STR      r6,[r5,#0x1c]  ; xYieldPending
                  |L1.3916|
000f4c  f3878811          MSR      BASEPRI,r7
;;;4645   					}
;;;4646   				}
;;;4647   				else
;;;4648   				{
;;;4649   					mtCOVERAGE_TEST_MARKER();
;;;4650   				}
;;;4651   			}
;;;4652   		}
;;;4653   		portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );
;;;4654   	}
000f50  e44f              B        |L1.2034|
;;;4655   
                          ENDP

                  xTaskNotifyStateClear PROC
;;;4661   
;;;4662   	BaseType_t xTaskNotifyStateClear( TaskHandle_t xTask )
000f52  b510              PUSH     {r4,lr}
;;;4663   	{
000f54  b158              CBZ      r0,|L1.3950|
;;;4664   	TCB_t *pxTCB;
;;;4665   	BaseType_t xReturn;
;;;4666   
;;;4667   		/* If null is passed in here then it is the calling task that is having
;;;4668   		its notification state cleared. */
;;;4669   		pxTCB = prvGetTCBFromHandle( xTask );
000f56  4604              MOV      r4,r0
                  |L1.3928|
;;;4670   
;;;4671   		taskENTER_CRITICAL();
000f58  f7fffffe          BL       vPortEnterCritical
;;;4672   		{
;;;4673   			if( pxTCB->ucNotifyState == taskNOTIFICATION_RECEIVED )
000f5c  f8940050          LDRB     r0,[r4,#0x50]
000f60  2802              CMP      r0,#2
000f62  d007              BEQ      |L1.3956|
;;;4674   			{
;;;4675   				pxTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
;;;4676   				xReturn = pdPASS;
;;;4677   			}
;;;4678   			else
;;;4679   			{
;;;4680   				xReturn = pdFAIL;
000f64  2400              MOVS     r4,#0
                  |L1.3942|
;;;4681   			}
;;;4682   		}
;;;4683   		taskEXIT_CRITICAL();
000f66  f7fffffe          BL       vPortExitCritical
;;;4684   
;;;4685   		return xReturn;
000f6a  4620              MOV      r0,r4
;;;4686   	}
000f6c  bd10              POP      {r4,pc}
                  |L1.3950|
000f6e  4845              LDR      r0,|L1.4228|
000f70  6804              LDR      r4,[r0,#0]            ;4669  ; pxCurrentTCB
000f72  e7f1              B        |L1.3928|
                  |L1.3956|
000f74  2000              MOVS     r0,#0                 ;4675
000f76  f8840050          STRB     r0,[r4,#0x50]         ;4675
000f7a  2401              MOVS     r4,#1                 ;4676
000f7c  e7f3              B        |L1.3942|
;;;4687   
                          ENDP

                  prvInitialiseNewTask PROC
;;;766    
;;;767    static void prvInitialiseNewTask( 	TaskFunction_t pxTaskCode,
000f7e  e92d47f0          PUSH     {r4-r10,lr}
;;;768    									const char * const pcName,
;;;769    									const uint32_t ulStackDepth,
;;;770    									void * const pvParameters,
;;;771    									UBaseType_t uxPriority,
;;;772    									TaskHandle_t * const pxCreatedTask,
;;;773    									TCB_t *pxNewTCB,
;;;774    									const MemoryRegion_t * const xRegions ) /*lint !e971 Unqualified char types are allowed for strings and single characters only. */
;;;775    {
000f82  460e              MOV      r6,r1
000f84  e9dd8409          LDRD     r8,r4,[sp,#0x24]
000f88  4682              MOV      r10,r0
;;;776    StackType_t *pxTopOfStack;
;;;777    UBaseType_t x;
;;;778    
;;;779    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;780    		/* Should the task be created in privileged mode? */
;;;781    		BaseType_t xRunPrivileged;
;;;782    		if( ( uxPriority & portPRIVILEGE_BIT ) != 0U )
;;;783    		{
;;;784    			xRunPrivileged = pdTRUE;
;;;785    		}
;;;786    		else
;;;787    		{
;;;788    			xRunPrivileged = pdFALSE;
;;;789    		}
;;;790    		uxPriority &= ~portPRIVILEGE_BIT;
;;;791    	#endif /* portUSING_MPU_WRAPPERS == 1 */
;;;792    
;;;793    	/* Avoid dependency on memset() if it is not required. */
;;;794    	#if( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) )
;;;795    	{
;;;796    		/* Fill the stack with a known value to assist debugging. */
;;;797    		( void ) memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) ulStackDepth * sizeof( StackType_t ) );
;;;798    	}
;;;799    	#endif /* ( ( configCHECK_FOR_STACK_OVERFLOW > 1 ) || ( ( configUSE_TRACE_FACILITY == 1 ) || ( INCLUDE_uxTaskGetStackHighWaterMark == 1 ) ) ) */
;;;800    
;;;801    	/* Calculate the top of stack address.  This depends on whether the stack
;;;802    	grows from high memory to low (as per the 80x86) or vice versa.
;;;803    	portSTACK_GROWTH is used to make the result positive or negative as required
;;;804    	by the port. */
;;;805    	#if( portSTACK_GROWTH < 0 )
;;;806    	{
;;;807    		pxTopOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
000f8a  f06f0103          MVN      r1,#3
000f8e  6b20              LDR      r0,[r4,#0x30]
000f90  eb010182          ADD      r1,r1,r2,LSL #2
000f94  4408              ADD      r0,r0,r1
000f96  9d08              LDR      r5,[sp,#0x20]
;;;808    		pxTopOfStack = ( StackType_t * ) ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack ) & ( ~( ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) ) ); /*lint !e923 MISRA exception.  Avoiding casts between pointers and integers is not practical.  Size differences accounted for using portPOINTER_SIZE_TYPE type. */
000f98  f0200707          BIC      r7,r0,#7
000f9c  4699              MOV      r9,r3                 ;775
;;;809    
;;;810    		/* Check the alignment of the calculated top of stack is correct. */
;;;811    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxTopOfStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
000f9e  0778              LSLS     r0,r7,#29
000fa0  d005              BEQ      |L1.4014|
000fa2  f240322b          MOV      r2,#0x32b
000fa6  a13b              ADR      r1,|L1.4244|
000fa8  a041              ADR      r0,|L1.4272|
000faa  f7fffffe          BL       __2printf
                  |L1.4014|
;;;812    	}
;;;813    	#else /* portSTACK_GROWTH */
;;;814    	{
;;;815    		pxTopOfStack = pxNewTCB->pxStack;
;;;816    
;;;817    		/* Check the alignment of the stack buffer is correct. */
;;;818    		configASSERT( ( ( ( portPOINTER_SIZE_TYPE ) pxNewTCB->pxStack & ( portPOINTER_SIZE_TYPE ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );
;;;819    
;;;820    		/* The other extreme of the stack space is required if stack checking is
;;;821    		performed. */
;;;822    		pxNewTCB->pxEndOfStack = pxNewTCB->pxStack + ( ulStackDepth - ( uint32_t ) 1 );
;;;823    	}
;;;824    	#endif /* portSTACK_GROWTH */
;;;825    
;;;826    	/* Store the task name in the TCB. */
;;;827    	for( x = ( UBaseType_t ) 0; x < ( UBaseType_t ) configMAX_TASK_NAME_LEN; x++ )
000fae  2000              MOVS     r0,#0
                  |L1.4016|
;;;828    	{
;;;829    		pxNewTCB->pcTaskName[ x ] = pcName[ x ];
000fb0  1822              ADDS     r2,r4,r0
000fb2  5c31              LDRB     r1,[r6,r0]
000fb4  f8821034          STRB     r1,[r2,#0x34]
;;;830    
;;;831    		/* Don't copy all configMAX_TASK_NAME_LEN if the string is shorter than
;;;832    		configMAX_TASK_NAME_LEN characters just in case the memory after the
;;;833    		string is not accessible (extremely unlikely). */
;;;834    		if( pcName[ x ] == 0x00 )
000fb8  5c31              LDRB     r1,[r6,r0]
000fba  b111              CBZ      r1,|L1.4034|
000fbc  1c40              ADDS     r0,r0,#1
000fbe  2810              CMP      r0,#0x10              ;827
000fc0  d3f6              BCC      |L1.4016|
                  |L1.4034|
;;;835    		{
;;;836    			break;
;;;837    		}
;;;838    		else
;;;839    		{
;;;840    			mtCOVERAGE_TEST_MARKER();
;;;841    		}
;;;842    	}
;;;843    
;;;844    	/* Ensure the name string is terminated in the case that the string length
;;;845    	was greater or equal to configMAX_TASK_NAME_LEN. */
;;;846    	pxNewTCB->pcTaskName[ configMAX_TASK_NAME_LEN - 1 ] = '\0';
000fc2  2600              MOVS     r6,#0
000fc4  f8846043          STRB     r6,[r4,#0x43]
;;;847    
;;;848    	/* This is used as an array index so must ensure it's not too large.  First
;;;849    	remove the privilege bit if one is present. */
;;;850    	if( uxPriority >= ( UBaseType_t ) configMAX_PRIORITIES )
000fc8  2d20              CMP      r5,#0x20
000fca  d300              BCC      |L1.4046|
;;;851    	{
;;;852    		uxPriority = ( UBaseType_t ) configMAX_PRIORITIES - ( UBaseType_t ) 1U;
000fcc  251f              MOVS     r5,#0x1f
                  |L1.4046|
;;;853    	}
;;;854    	else
;;;855    	{
;;;856    		mtCOVERAGE_TEST_MARKER();
;;;857    	}
;;;858    
;;;859    	pxNewTCB->uxPriority = uxPriority;
;;;860    	#if ( configUSE_MUTEXES == 1 )
;;;861    	{
;;;862    		pxNewTCB->uxBasePriority = uxPriority;
;;;863    		pxNewTCB->uxMutexesHeld = 0;
;;;864    	}
;;;865    	#endif /* configUSE_MUTEXES */
;;;866    
;;;867    	vListInitialiseItem( &( pxNewTCB->xStateListItem ) );
000fce  62e5              STR      r5,[r4,#0x2c]
000fd0  e9c45611          STRD     r5,r6,[r4,#0x44]
000fd4  1d20              ADDS     r0,r4,#4
000fd6  f7fffffe          BL       vListInitialiseItem
;;;868    	vListInitialiseItem( &( pxNewTCB->xEventListItem ) );
000fda  f1040018          ADD      r0,r4,#0x18
000fde  f7fffffe          BL       vListInitialiseItem
;;;869    
;;;870    	/* Set the pxNewTCB as a link back from the ListItem_t.  This is so we can get
;;;871    	back to	the containing TCB from a generic item in a list. */
;;;872    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xStateListItem ), pxNewTCB );
000fe2  6124              STR      r4,[r4,#0x10]
;;;873    
;;;874    	/* Event lists are always in priority order. */
;;;875    	listSET_LIST_ITEM_VALUE( &( pxNewTCB->xEventListItem ), ( TickType_t ) configMAX_PRIORITIES - ( TickType_t ) uxPriority ); /*lint !e961 MISRA exception as the casts are only redundant for some ports. */
000fe4  f1c50020          RSB      r0,r5,#0x20
;;;876    	listSET_LIST_ITEM_OWNER( &( pxNewTCB->xEventListItem ), pxNewTCB );
000fe8  6264              STR      r4,[r4,#0x24]
000fea  61a0              STR      r0,[r4,#0x18]
;;;877    
;;;878    	#if ( portCRITICAL_NESTING_IN_TCB == 1 )
;;;879    	{
;;;880    		pxNewTCB->uxCriticalNesting = ( UBaseType_t ) 0U;
;;;881    	}
;;;882    	#endif /* portCRITICAL_NESTING_IN_TCB */
;;;883    
;;;884    	#if ( configUSE_APPLICATION_TASK_TAG == 1 )
;;;885    	{
;;;886    		pxNewTCB->pxTaskTag = NULL;
;;;887    	}
;;;888    	#endif /* configUSE_APPLICATION_TASK_TAG */
;;;889    
;;;890    	#if ( configGENERATE_RUN_TIME_STATS == 1 )
;;;891    	{
;;;892    		pxNewTCB->ulRunTimeCounter = 0UL;
;;;893    	}
;;;894    	#endif /* configGENERATE_RUN_TIME_STATS */
;;;895    
;;;896    	#if ( portUSING_MPU_WRAPPERS == 1 )
;;;897    	{
;;;898    		vPortStoreTaskMPUSettings( &( pxNewTCB->xMPUSettings ), xRegions, pxNewTCB->pxStack, ulStackDepth );
;;;899    	}
;;;900    	#else
;;;901    	{
;;;902    		/* Avoid compiler warning about unreferenced parameter. */
;;;903    		( void ) xRegions;
;;;904    	}
;;;905    	#endif
;;;906    
;;;907    	#if( configNUM_THREAD_LOCAL_STORAGE_POINTERS != 0 )
;;;908    	{
;;;909    		for( x = 0; x < ( UBaseType_t ) configNUM_THREAD_LOCAL_STORAGE_POINTERS; x++ )
;;;910    		{
;;;911    			pxNewTCB->pvThreadLocalStoragePointers[ x ] = NULL;
;;;912    		}
;;;913    	}
;;;914    	#endif
;;;915    
;;;916    	#if ( configUSE_TASK_NOTIFICATIONS == 1 )
;;;917    	{
;;;918    		pxNewTCB->ulNotifiedValue = 0;
000fec  64e6              STR      r6,[r4,#0x4c]
;;;919    		pxNewTCB->ucNotifyState = taskNOT_WAITING_NOTIFICATION;
000fee  f8846050          STRB     r6,[r4,#0x50]
;;;920    	}
;;;921    	#endif
;;;922    
;;;923    	#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;924    	{
;;;925    		/* Initialise this task's Newlib reent structure. */
;;;926    		_REENT_INIT_PTR( ( &( pxNewTCB->xNewLib_reent ) ) );
;;;927    	}
;;;928    	#endif
;;;929    
;;;930    	#if( INCLUDE_xTaskAbortDelay == 1 )
;;;931    	{
;;;932    		pxNewTCB->ucDelayAborted = pdFALSE;
;;;933    	}
;;;934    	#endif
;;;935    
;;;936    	/* Initialize the TCB stack to look as if the task was already running,
;;;937    	but had been interrupted by the scheduler.  The return address is set
;;;938    	to the start of the task function. Once the stack has been initialised
;;;939    	the	top of stack variable is updated. */
;;;940    	#if( portUSING_MPU_WRAPPERS == 1 )
;;;941    	{
;;;942    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
;;;943    	}
;;;944    	#else /* portUSING_MPU_WRAPPERS */
;;;945    	{
;;;946    		pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
000ff2  464a              MOV      r2,r9
000ff4  4651              MOV      r1,r10
000ff6  4638              MOV      r0,r7
000ff8  f7fffffe          BL       pxPortInitialiseStack
;;;947    	}
;;;948    	#endif /* portUSING_MPU_WRAPPERS */
;;;949    
;;;950    	if( ( void * ) pxCreatedTask != NULL )
000ffc  6020              STR      r0,[r4,#0]
000ffe  f1b80f00          CMP      r8,#0
001002  d001              BEQ      |L1.4104|
;;;951    	{
;;;952    		/* Pass the handle out in an anonymous way.  The handle can be used to
;;;953    		change the created task's priority, delete the created task, etc.*/
;;;954    		*pxCreatedTask = ( TaskHandle_t ) pxNewTCB;
001004  f8c84000          STR      r4,[r8,#0]
                  |L1.4104|
;;;955    	}
;;;956    	else
;;;957    	{
;;;958    		mtCOVERAGE_TEST_MARKER();
;;;959    	}
;;;960    }
001008  e74d              B        |L1.3750|
;;;961    /*-----------------------------------------------------------*/
                          ENDP

                  prvResetNextTaskUnblockTime PROC
;;;3634   
;;;3635   static void prvResetNextTaskUnblockTime( void )
00100a  481e              LDR      r0,|L1.4228|
;;;3636   {
;;;3637   TCB_t *pxTCB;
;;;3638   
;;;3639   	if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
00100c  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
00100e  6809              LDR      r1,[r1,#0]
001010  b129              CBZ      r1,|L1.4126|
;;;3640   	{
;;;3641   		/* The new current delayed list is empty.  Set xNextTaskUnblockTime to
;;;3642   		the maximum possible value so it is	extremely unlikely that the
;;;3643   		if( xTickCount >= xNextTaskUnblockTime ) test will pass until
;;;3644   		there is an item in the delayed list. */
;;;3645   		xNextTaskUnblockTime = portMAX_DELAY;
;;;3646   	}
;;;3647   	else
;;;3648   	{
;;;3649   		/* The new current delayed list is not empty, get the value of
;;;3650   		the item at the head of the delayed list.  This is the time at
;;;3651   		which the task at the head of the delayed list should be removed
;;;3652   		from the Blocked state. */
;;;3653   		( pxTCB ) = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
001012  6b41              LDR      r1,[r0,#0x34]  ; pxDelayedTaskList
001014  68c9              LDR      r1,[r1,#0xc]
001016  68c9              LDR      r1,[r1,#0xc]
;;;3654   		xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( ( pxTCB )->xStateListItem ) );
001018  6849              LDR      r1,[r1,#4]
                  |L1.4122|
00101a  6281              STR      r1,[r0,#0x28]         ;3645  ; xNextTaskUnblockTime
;;;3655   	}
;;;3656   }
00101c  4770              BX       lr
                  |L1.4126|
00101e  f04f31ff          MOV      r1,#0xffffffff        ;3645
001022  e7fa              B        |L1.4122|
;;;3657   /*-----------------------------------------------------------*/
                          ENDP

                  prvDeleteTCB PROC
;;;3580   
;;;3581   	static void prvDeleteTCB( TCB_t *pxTCB )
001024  b510              PUSH     {r4,lr}
;;;3582   	{
001026  4604              MOV      r4,r0
;;;3583   		/* This call is required specifically for the TriCore port.  It must be
;;;3584   		above the vPortFree() calls.  The call is also used by ports/demos that
;;;3585   		want to allocate and clean RAM statically. */
;;;3586   		portCLEAN_UP_TCB( pxTCB );
;;;3587   
;;;3588   		/* Free up the memory allocated by the scheduler for the task.  It is up
;;;3589   		to the task to free any memory allocated at the application level. */
;;;3590   		#if ( configUSE_NEWLIB_REENTRANT == 1 )
;;;3591   		{
;;;3592   			_reclaim_reent( &( pxTCB->xNewLib_reent ) );
;;;3593   		}
;;;3594   		#endif /* configUSE_NEWLIB_REENTRANT */
;;;3595   
;;;3596   		#if( ( configSUPPORT_DYNAMIC_ALLOCATION == 1 ) && ( configSUPPORT_STATIC_ALLOCATION == 0 ) && ( portUSING_MPU_WRAPPERS == 0 ) )
;;;3597   		{
;;;3598   			/* The task can only have been allocated dynamically - free both
;;;3599   			the stack and TCB. */
;;;3600   			vPortFree( pxTCB->pxStack );
001028  6b00              LDR      r0,[r0,#0x30]
00102a  f7fffffe          BL       vPortFree
;;;3601   			vPortFree( pxTCB );
00102e  4620              MOV      r0,r4
001030  e8bd4010          POP      {r4,lr}
001034  f7ffbffe          B.W      vPortFree
;;;3602   		}
;;;3603   		#elif( tskSTATIC_AND_DYNAMIC_ALLOCATION_POSSIBLE == 1 )
;;;3604   		{
;;;3605   			/* The task could have been allocated statically or dynamically, so
;;;3606   			check what was statically allocated before trying to free the
;;;3607   			memory. */
;;;3608   			if( pxTCB->ucStaticallyAllocated == tskDYNAMICALLY_ALLOCATED_STACK_AND_TCB )
;;;3609   			{
;;;3610   				/* Both the stack and TCB were allocated dynamically, so both
;;;3611   				must be freed. */
;;;3612   				vPortFree( pxTCB->pxStack );
;;;3613   				vPortFree( pxTCB );
;;;3614   			}
;;;3615   			else if( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_ONLY )
;;;3616   			{
;;;3617   				/* Only the stack was statically allocated, so the TCB is the
;;;3618   				only memory that must be freed. */
;;;3619   				vPortFree( pxTCB );
;;;3620   			}
;;;3621   			else
;;;3622   			{
;;;3623   				/* Neither the stack nor the TCB were allocated dynamically, so
;;;3624   				nothing needs to be freed. */
;;;3625   				configASSERT( pxTCB->ucStaticallyAllocated == tskSTATICALLY_ALLOCATED_STACK_AND_TCB	)
;;;3626   				mtCOVERAGE_TEST_MARKER();
;;;3627   			}
;;;3628   		}
;;;3629   		#endif /* configSUPPORT_DYNAMIC_ALLOCATION */
;;;3630   	}
;;;3631   
                          ENDP

                  prvCheckTasksWaitingTermination PROC
;;;3364   
;;;3365   static void prvCheckTasksWaitingTermination( void )
001038  b570              PUSH     {r4-r6,lr}
;;;3366   {
;;;3367   
;;;3368   	/** THIS FUNCTION IS CALLED FROM THE RTOS IDLE TASK **/
;;;3369   
;;;3370   	#if ( INCLUDE_vTaskDelete == 1 )
;;;3371   	{
;;;3372   		BaseType_t xListIsEmpty;
;;;3373   
;;;3374   		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
;;;3375   		too often in the idle task. */
;;;3376   		while( uxDeletedTasksWaitingCleanUp > ( UBaseType_t ) 0U )
;;;3377   		{
;;;3378   			vTaskSuspendAll();
;;;3379   			{
;;;3380   				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
00103a  4e15              LDR      r6,|L1.4240|
;;;3381   			}
;;;3382   			( void ) xTaskResumeAll();
;;;3383   
;;;3384   			if( xListIsEmpty == pdFALSE )
;;;3385   			{
;;;3386   				TCB_t *pxTCB;
;;;3387   
;;;3388   				taskENTER_CRITICAL();
;;;3389   				{
;;;3390   					pxTCB = ( TCB_t * ) listGET_OWNER_OF_HEAD_ENTRY( ( &xTasksWaitingTermination ) );
;;;3391   					( void ) uxListRemove( &( pxTCB->xStateListItem ) );
;;;3392   					--uxCurrentNumberOfTasks;
00103c  4d11              LDR      r5,|L1.4228|
00103e  3614              ADDS     r6,r6,#0x14           ;3380
001040  e01c              B        |L1.4220|
                  |L1.4162|
001042  f7fffffe          BL       vTaskSuspendAll
001046  6830              LDR      r0,[r6,#0]            ;3380  ; xTasksWaitingTermination
001048  b120              CBZ      r0,|L1.4180|
00104a  2400              MOVS     r4,#0                 ;3380
                  |L1.4172|
00104c  f7fffffe          BL       xTaskResumeAll
001050  b9a4              CBNZ     r4,|L1.4220|
001052  e001              B        |L1.4184|
                  |L1.4180|
001054  2401              MOVS     r4,#1                 ;3380
001056  e7f9              B        |L1.4172|
                  |L1.4184|
001058  f7fffffe          BL       vPortEnterCritical
00105c  68f0              LDR      r0,[r6,#0xc]          ;3390  ; xTasksWaitingTermination
00105e  68c4              LDR      r4,[r0,#0xc]          ;3391
001060  1d20              ADDS     r0,r4,#4              ;3391
001062  f7fffffe          BL       uxListRemove
001066  68a8              LDR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
001068  1e40              SUBS     r0,r0,#1
00106a  60a8              STR      r0,[r5,#8]  ; uxCurrentNumberOfTasks
;;;3393   					--uxDeletedTasksWaitingCleanUp;
00106c  6868              LDR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
00106e  1e40              SUBS     r0,r0,#1
001070  6068              STR      r0,[r5,#4]  ; uxDeletedTasksWaitingCleanUp
;;;3394   				}
;;;3395   				taskEXIT_CRITICAL();
001072  f7fffffe          BL       vPortExitCritical
;;;3396   
;;;3397   				prvDeleteTCB( pxTCB );
001076  4620              MOV      r0,r4
001078  f7fffffe          BL       prvDeleteTCB
                  |L1.4220|
00107c  6868              LDR      r0,[r5,#4]            ;3376  ; uxDeletedTasksWaitingCleanUp
00107e  2800              CMP      r0,#0                 ;3376
001080  d1df              BNE      |L1.4162|
;;;3398   			}
;;;3399   			else
;;;3400   			{
;;;3401   				mtCOVERAGE_TEST_MARKER();
;;;3402   			}
;;;3403   		}
;;;3404   	}
;;;3405   	#endif /* INCLUDE_vTaskDelete */
;;;3406   }
001082  bd70              POP      {r4-r6,pc}
                  |L1.4228|
                          DCD      ||.data||
                  |L1.4232|
                          DCD      0xe000ed04
                  |L1.4236|
                          DCD      ||.bss||
                  |L1.4240|
                          DCD      ||.bss||+0x2a8
                  |L1.4244|
001094  2e2e5c2e          DCB      "..\\..\\FreeRTOS\\src\\tasks.c",0
001098  2e5c4672
00109c  65655254
0010a0  4f535c73
0010a4  72635c74
0010a8  61736b73
0010ac  2e6300  
0010af  00                DCB      0
                  |L1.4272|
0010b0  4572726f          DCB      "Error:%s,%d\r\n",0
0010b4  723a2573
0010b8  2c25640d
0010bc  0a00    
0010be  00                DCB      0
0010bf  00                DCB      0
                          ENDP


                          AREA ||.bss||, DATA, NOINIT, ALIGN=2

                  pxReadyTasksLists
                          %        640
                  xDelayedTaskList1
                          %        20
                  xDelayedTaskList2
                          %        20
                  xPendingReadyList
                          %        20
                  xTasksWaitingTermination
                          %        20
                  xSuspendedTaskList
                          %        20

                          AREA ||.data||, DATA, ALIGN=2

                  pxCurrentTCB
                          DCD      0x00000000
                  uxDeletedTasksWaitingCleanUp
                          DCD      0x00000000
                  uxCurrentNumberOfTasks
                          DCD      0x00000000
                  xTickCount
                          DCD      0x00000000
                  uxTopReadyPriority
                          DCD      0x00000000
                  xSchedulerRunning
                          DCD      0x00000000
                  uxPendedTicks
                          DCD      0x00000000
                  xYieldPending
                          DCD      0x00000000
                  xNumOfOverflows
                          DCD      0x00000000
                  uxTaskNumber
                          DCD      0x00000000
                  xNextTaskUnblockTime
                          DCD      0x00000000
                  xIdleTaskHandle
                          DCD      0x00000000
                  uxSchedulerSuspended
                          DCD      0x00000000
                  pxDelayedTaskList
                          DCD      0x00000000
                  pxOverflowDelayedTaskList
                          DCD      0x00000000
